# Listing Generator (lg)

Генератор plain‑text‑листинга исходников для AI‑ассистентов, code‑review и быстрого обмена контекстом.

---

## Зачем нужен этот инструмент?

Современные AI‑копилоты (ChatGPT, Copilot Chat, Gemini, Claude и др.) работают лучше всего, когда видят **весь релевантный код одним куском**. Копировать десятки файлов вручную — боль, а отдавать весь репозиторий архивом — расточительно по токенам.
`lg` обходит дерево проекта, сшивает подходящие файлы в единый компактный листинг и печатает его в `stdout` — готово к вставке или пайпу куда угодно.

Используйте, чтобы:

* показать только изменённые файлы перед коммитом;
* поделиться минимальным воспроизводимым примером с коллегами или в баг‑репорте;
* сделать снапшот кода для рефакторинга или генерации документации с помощью LLM;
* автоматически генерировать готовые задачи/prompts на основе шаблонов;

---

## Ключевые возможности

| Возможность                         | Детали                                                                                                                         |
|-------------------------------------|--------------------------------------------------------------------------------------------------------------------------------|
| **Кроссплатформенная CLI**          | Windows, macOS, Linux. Внешние бинарники не нужны.                                                                             |
| **Автопоиск корня проекта**         | Поднимается вверх в поисках `.git` или `listing_config.yaml`.                                                                  |
| **Понимание `.gitignore`**          | Использует ваши правила игнора (полный синтаксис при установленном пакете `pathspec`).                                         |
| **YAML-конфиг**                     | Human-friendly, работает по секциям, поддерживает комментарии, вложенность и типизацию через dataclass-модели.                 |
| **Продвинутая фильтрация**          | Белые / черные (`allow`/`block`) списки с рекурсивными правилами на каждом уровне дерева.                                      |
| **Несколько расширений**            | Настраиваемый список: `.py`, `.md`, `.qml` и др.                                                                               |
| **Режимы `all` и `changes`**        | Листинг всех файлов **или** только изменённых в рабочем дереве (staged + unstaged + untracked).                                |
| **Диагностика фильтров**            | Флаг `--list-included` выводит только пути, прошедшие фильтрацию (debug-режим).                                                |
| **Расширенная статистика листинга** | Флаг `--stats` строит ASCII-таблицу с размером файлов, токенами, долями в промте и в окне модели                               |
| **Плагинные адаптеры**              | Языко-специфичные правила лежат в `lg/adapters/`. Можно добавить новые без правок ядра.                                        |
| **Дружит с сабмодулями**            | Инструмент живёт в отдельном репо — подключайте через `git submodule` или симлинк.                                             |
| **Шаблонизация промтов**            | Создание контекстных промтов на основе шаблонов<br/>Система управления ветками диалогов для AI-ассистентов                     |
| **Вложенные контексты**             | Шаблон может включать другой шаблон через `${tpl:path/to/template}`; шаблоны могут храниться в подпапках `lg-cfg/contexts/**`. |
| **Markdown Code Fencing**           | Автоматическое оборачивание блоков кода в `fenced`-обёртки с указанием языка (\`\`\`python, \`\`\`bash и др.)                  |
| **Markdown Header Normalization**   | Нормализация уровней заголовков Markdown: удаление top-level H1 и понижение всех заголовков до max-уровня                      |
| **Python 3.8+**                     | Тестировалось до 3.12. Нулевые runtime-зависимости (dev-зависимости только для разработки).                                    |

---

## Структура проекта-клиента

```

my-project/
├─ lg/                     # сабмодуль или симлинк на репозиторий инструмента
├─ lg-cfg/                 # вся конфигурация для lg
│   ├─ config.yaml         # мультисекционный YAML-конфиг
│   └─ contexts/           # папка с Markdown-шаблонами промтов
│       └─ <имя>.tmpl.md   # шаблон для контекстного промта
└─ …                       # остальная структура вашего проекта

````

- **`lg/`** — сам инструмент (можно подключать как Git-сабмодуль или симлинк).  
- **`lg-cfg/config.yaml`** — единый YAML-файл со всеми секциями, раньше это был `listing_config.yaml`.  
- **`lg-cfg/contexts/`** — шаблоны промтов в формате Markdown с плейсхолдерами `${section}`.

---

## Подключение инструмента к проекту

### Git‑сабмодуль (рекомендуемый способ)

```bash
# Добавить сабмодуль в каталог lg/
git submodule add https://github.com/your-org/lg.git lg

# Инициализировать/обновить после клонирования
git submodule update --init --remote

# Получить свежую версию инструмента позднее
git submodule update --remote lg
```

> **Плюсы**: версия инструмента фиксируется хэшем, подходит для любых ОС, легко обновлять через Git.  
> **Минусы**: команда `git clone` нужна с флагом `--recursive` *или* отдельной инициализацией субмодулей.

### Символическая ссылка (для локальной разработки)

> Работает только если вся команда использует совместимую ОС; симлинки в Windows требуют режим *Developer Mode* или админ‑права.

**Windows (PowerShell ≥ 5):**

```powershell
New-Item -ItemType SymbolicLink -Path lg -Target C:\path\to\lg
```

**Linux / macOS:**

```bash
ln -s ~/dev/lg lg
```

После создания симлинка инструмент доступен так же, как и при использовании сабмодуля.


### Способы запуска после подключения

| Вариант                            | Команда из корня проекта                                                                                                                               | Комментарии                                                                                                                               |
| ---------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------ | ----------------------------------------------------------------------------------------------------------------------------------------- |
| **Editable‑режим** | `pip install -e ./lg`  ← один раз<br>`listing-generator --config my.listing_config.json`                                                               | Самый короткий UX. Пакет `lg` добавляется в `PYTHONPATH`, появляется entry‑point `listing-generator`. Конфликтов с dev‑зависимостями нет. |
| **Двойной namespace**              | `python -m lg.lg.cli --root . --config my.listing_config.json`                                                                                         | Работает без установки. Полезно, если нельзя писать в venv или хочется «разового» запуска.                                                |
| **Run‑конфигурация PyCharm**       | *Type*: **Python**.<br>*Script*: `<MODULE>`.<br>*Module name*: `lg.cli`. | Позволяет запускать генератор одной кнопкой ⏵ в IDE. Работает с сабмодулем и симлинком.                                                   |

По умолчанию:

* ищется `listing_config.yaml` в текущей директории;
* режим `all`: берутся все подходящие файлы;
* применяются `.gitignore` + YAML-фильтрация;
* выводится единый текстовый листинг.

---

## CLI: базовые сценарии

```bash
# 1. Листинг кода из секции (по умолчанию 'all')
listing-generator --section <имя_секции>

# 2. Листинг только изменённых файлов
listing-generator --section <имя_секции> --mode changes

# 3. Отладочный режим: показать только пути файлов
listing-generator --section <имя_секции> --list-included

# 4. Получить список всех секций из конфига
listing-generator --list-sections

# 5. Сгенерировать контекст-промт по шаблону
listing-generator --context <имя_шаблона>

# 6. Контекст + отладочный список путей
listing-generator --context <имя_шаблона> --list-included

# 7. Листинг + расширенная статистика
listing-generator --section <имя_секции> \
                  --list-included --stats \
                  --sort size \
                  --model o3
````

Все команды автоматически работают из корня проекта (`PWD`) и ищут конфиг в `lg-cfg/config.yaml`.

## CLI-опции

```
usage: listing-generator [-h] [-s SECTION] [--mode {all,changes}]
                         [--list-included] [--list-sections]
                         [--context NAME] [--code-fence] [--max-heading-level N]
                         [--stats] [--sort {path,size,share}] [--model NAME]
                         [-v]

options:
  -h, --help                Show this help message and exit.
  -s, --section SECTION     Имя секции в lg-cfg/config.yaml (default: all)
  --mode {all,changes}      all = весь проект; changes = только изменённые
  --list-included           Только пути файлов, прошедших фильтрацию
    * --stats                   Показать таблицу с размерами, токенами и сводной статистикой
    * --sort {path,size,share}  Критерий сортировки таблицы (default: path)
    * --model NAME              Целевая LLM-модель для расчёта доли окна контекста (default: o3)
  --list-sections           Вывести список доступных секций
  --list-sections           Вывести список доступных секций
  --context NAME            Сгенерировать промт по шаблону NAME.tmpl.md
  --code-fence              Оборачивать каждый файл в fenced-блок (\`\`\`lang) (override config.code\_fence)
  --max-heading-level N     Максимальный уровень заголовков для нормализации Markdown (override config.markdown.max\_heading\_level)
  -v, --verbose             Увеличить подробность логов (можно -vv)
```

---

## Аналитика размера и токенов (`--stats`)

Флаг `--stats` (используется **совместно** с `--list-included`) превращает
вывод «путей файлов» в полноценную ASCII-таблицу:

```text
PATH                                      SIZE   TOKENS  PROMPT%    CTX%
───────────────────────────────────────────────────────────────────────
src/utils.py                           3.2 KiB      812      2.7     0.4
core/data/big_model.json             512.8 KiB  132 900     45.1    66.5‼
───────────────────────────────────────────────────────────────────────
TOTAL                                  1.1 MiB  294 650    100.0   147.3
```

* **SIZE** — читаемый размер файла.
* **TOKENS** — точный подсчёт через `tiktoken` для выбранной модели.
* **PROMPT%** — доля файла в суммарном листинге.
* **CTX%** — доля окна контекста модели; `‼` помечает файлы, которые не помещаются без обрезки.


Параметры:

| Флаг      | Значение по умолчанию  | Описание                                              |
|-----------|------------------------|-------------------------------------------------------|
| `--sort`  | `path`                 | Сортировка строк (`path`, `size`, `share`).           |
| `--model` | `o3`                   | Имя модели для расчёта окна (см. встроенный словарь). |

Поддерживаемые модели и их размеры контекста зашиты прямо в код (`o3`,
`gpt-4o`, `gpt-4o-mini`, `claude-3-opus`, `claude-3-sonnet`,
`gemini-1.5-pro`).

> **Зависимость:** для работы `--stats` требуется пакет `tiktoken` — он уже
> добавлен в `pyproject.toml`, но при установке старых окружений убедитесь,
> что выполнено `pip install -e ./lg`.

---

## Пример шаблона контекста

```markdown
Вводная часть и общее описание проекта.

== Документация по проекту ==

${tpl:docs/architecture}                 <!-- включаем другой шаблон -->

== Текущий исходный код модуля `core-model` ==

Сейчас в рамках данного проекта мы ведем разработку модуля `core-model`.

Предоставляю актуальный исходный код данного модуля:

${core-model-src}

== Дорожная карта разработки модуля `core-model` ==

${core-model-roadmap}
```

Запуск:

```bash
listing-generator --context core-model > prompt.md
# имя может содержать подпапку
listing-generator --context docs/architecture > prompt.md
```

В результате `prompt.md` будет готов к вставке в диалог с AI-ассистентом.

---

## Формат конфига (`lg-cfg/config.yaml`)

```yaml
schema_version: 4

# --- Глобальные настройки ---
# Пропускать пустые файлы (default: true)
skip_empty: true
# Оборачивать файлы в fenced-блоки (default: true)
code_fence: true
# Какие расширения обрабатывать
extensions:
  - ".py"
  - ".java"

all:
   # --- Параметры адаптеров ---
   python:
     # Пропускать полностью пустые .py-файлы
     skip_empty: true
     # Пропускать тривиальные __init__.py
     skip_trivial_inits: true
     # Максимум значимых строк в __init__.py для его оставления
     trivial_init_max_noncomment: 1
   
   java:
     # Не пропускать пустые .java-файлы
     skip_empty: false
     # Пропускать файлы с только Spring-аннотациями
     skip_trivial_spring_annots: true
   
   markdown:
     # нормализовать заголовки не выше H3
     max_heading_level: 3
   
   # --- Система фильтрации (Allow/Block-Tree) ---
   filters:
     # ------------------------------------------------------------------
     # 1) ГЛОБАЛЬНЫЙ УЗЕЛ (КОРЕНЬ РЕПО)
     #    strategy: “разрешено всё, КРОМЕ явно перечисленного”
     # ------------------------------------------------------------------
     mode: block                 # default-allow
     block:                      # → вычёркиваем мусор, бинарники и большие данные
       - ".git/"
       - "**/__pycache__/**"
       - "**/*.pyc"
       - "**/*.log"
       - "node_modules/"
   
     # ------------------------------------------------------------------
     # 2) ПОДДЕРЕВО secure/ — переворачиваем логику:
     #    strategy: “запрещено всё, КРОМЕ явно перечисленного”
     # ------------------------------------------------------------------
     children:
       secure:
         mode: allow             # default-deny
         allow:                  # → раскрываем ровно то, что нужно ревью
           - "*.py"              # код
           - "*.md"              # документация
   
         # --------------------------------------------------------------
         # 3) точечный сабдиректории secure/artifacts/
         #    здесь снова «доступно всё, кроме *.tmp»
         # --------------------------------------------------------------
         children:
           artifacts:
             mode: block         # default-allow
             block:
               - "**/*.tmp"
```

Фильтрация делается **до** языковых адаптеров:

1. Сначала применяется `.gitignore`-правило (через `pathspec`).
2. Затем — дерево `filters` из `listing_config.yaml`.
   * `mode: allow`  → белый список (по умолчанию всё запрещено).
   * `mode: block`  → чёрный список (по умолчанию всё разрешено).
   * При пересечении allow+block — блокировка сильнее.
   * Директория `foo/` эквивалентна маске `foo/**`.
   * Все пути обрабатываются как POSIX-lowercase.
3. Только допущенные файлы доходят до адаптера, где ещё отбрасываются пустые или тривиальные.

### Пример конфига с разными секциями

```yaml
schema_version: 4
# Секция для создания общей документации по проекту
docs:
  extensions: [".md"]
  markdown:
    max_heading_level: 2  
  filters:
    mode: allow
    allow:
      - "/README.md"
      - "/docs/"
# Секция для передачи исходного кода для подмодуля `core-model`
core-model-src:
  extensions: [".py", ".md", ".yaml", ".json", ".txt", ".toml"]
  python:
    skip_empty: true
    skip_trivial_inits: true
    trivial_init_max_noncomment: 1
  filters:
    mode: allow
    allow:
      - "/core-model/"
    children:
      core-model:
        mode: block
        block:
          - "/ROADMAP.md"
          - ".pytest_cache"
# Секция для планирования дорожной карты разработки подмодуля `core-model`
core-model-roadmap:
  extensions: [".md"]
  filters:
    mode: allow
    allow:
      - "/core-model/ROADMAP.md"
```

---

## Разработка

```bash
# установка инструментов разработчика
pip install -e .[dev]

# запуск юнит-тестов
pytest -q
```

---

## Лицензия

MIT License — подробности в файле `LICENSE`.

