# ТЗ: LG CLI — новая система режимов и тегов

## 1. Цели

Реализовать новую модель режимов и тегов в LG CLI с учётом:
- контекстной зависимости mode‑sets/tag‑sets;
- фронтматтера `.ctx.md` для подключения мета‑секций;
- наследования секций (`extends`) с детерминированным мерджем;
- поддержки `runs` в режимах (без интерпретации CLI);
- строгого правила: **ровно один интеграционный набор режимов** в контексте.

Обратная совместимость со старой моделью **не требуется**.

---

## 2. Область работ

### Включено
- новая модель данных режимов/тегов, встроенная в секции;
- резолв `extends` + транзитивный сбор секций из шаблонов;
- фронтматтер `include` в `.ctx.md`;
- новые CLI-команды list mode‑sets/tag‑sets с фильтрацией по контексту/провайдеру;
- обновление валидации `{% mode %}`;
- переработка Adaptive‑подсистемы и `RunContext` под новую модель;
- обновление JSON‑схем для list‑ответов;
- передача `--provider` в команды `render`/`report` для идентификации AI‑провайдера;
- новый условный оператор `provider:<base-id>` для проверки активного AI‑провайдера.

### Не включено
- миграция старых `modes.yaml`/`tags.yaml` (будет отдельно);
- изменения формата `runs` (остаётся строковым);
- изменения логики фильтров `filters` и `targets` (они **не** наследуются).

---

## 3. Новая модель данных

### 3.1. Расширения SectionCfg
Секция может содержать новые поля:

```yaml
extends: ["base/section", "tags/common"]
mode-sets:
  <id>:
    title: "..."
    modes:
      <mode-id>:
        title: "..."
        description: "..."
        tags: ["tag1", "tag2"]
        default_task: "..."
        vcs_mode: "all|changes|branch-changes"
        runs:
          <provider-id>: "..."

tag-sets:
  <id>:
    title: "..."
    tags:
      <tag-id>:
        title: "..."
        description: "..."
```

Примечания:
- Декларация глобальных тегов **не поддерживается** (они существуют, но не объявляются явно).
- `runs` — строка, интерпретируется только UI-плагинами.
- Наличие `runs` в **любом** режиме внутри набора делает набор **интеграционным**.

### 3.2. Мета‑секции
Секция **без `filters`** — мета‑секция. Она:
- не должна рендериться напрямую;
- может использоваться в `extends` или в `frontmatter.include`.

Попытка рендерить мета‑секцию → ошибка.

---

## 4. Наследование секций (`extends`)

### 4.1. Правила
- `mode-sets` и `tag-sets` объединяются по `id`.
- При коллизии `mode.id` или `tag.id`: **child wins**.
- `title`/`description` могут переопределяться (разрешено «переименование»).
- Наследуются и мерджатся:
  - `mode-sets`, `tag-sets`, `tags`
  - `extensions`
  - адаптер‑конфиги
  - `skip_empty`, `path_labels`
- **Не наследуются:** `filters`, `targets`.

### 4.2. Порядок мерджа
- Внутри секции: `extends` разворачивается **depth‑first, left‑to‑right**, затем применяется локальная секция.

---

## 5. Расчёт режимов/тегов для контекста

### 5.1. Источники
1) Все секции, найденные в шаблоне контекста (транзитивно по `${section}` и include tpl/ctx).
2) Секции из frontmatter `include`.

### 5.2. Исключения
- `${md:...}` не учитываются (не описывают mode‑sets/tag‑sets).
- Условия `{% if %}` не выполняются — секции в них **всё равно** учитываются.

### 5.3. Правило единственного интеграционного набора
После резолва всех mode‑sets для контекста:
- **ровно один** набор должен быть интеграционным;
- если интеграционных 0 или >1 → ошибка.

---

## 6. Frontmatter в `.ctx.md`

Формат:

```markdown
---
include:
  - "modes/base"
  - "tags/base"
---
```

Также допустим короткий вариант:

```markdown
---
include: ["ai-interaction"]
---
```

`include` содержит секции (обычно мета‑секции), которые добавляются в расчёт mode‑sets/tag‑sets, но **не рендерятся**.

Требования:
- frontmatter парсится только в `.ctx.md`;
- frontmatter удаляется из текста перед рендером;
- `include` поддерживает относительные и адресные ссылки как у секций.

---

## 7. Изменения в архитектуре CLI

### 7.1. Новые модули (рекомендуется)

1) `lg/adaptive/model.py`
   - новые модели `ModeSet`, `Mode`, `TagSet`, `Tag`, `RunsMap`.
2) `lg/adaptive/section_loader.py`
   - извлечение адаптивных данных из SectionCfg;
   - резолв `extends`.
3) `lg/adaptive/context_resolver.py`
   - сбор секций из `.ctx.md` (включая includes);
   - merge adaptive‑модели по детерминированному порядку;
   - проверка правила единственного интеграционного набора.
4) `lg/template/frontmatter.py`
   - парсинг YAML frontmatter для `.ctx.md`.

### 7.2. Устаревшие модули
- `lg/config/modes.py`, `lg/config/tags.py`, `lg/config/adaptive_loader.py` — признать устаревшими и удалить/заменить.
- `lg/config/adaptive_model.py` — заменить на новую модель.

---

## 8. Интеграция с существующим кодом

### 8.1. TemplateContext и условия
- `TemplateContext` должен получать **контекстную** adaptive‑модель.
- `ConditionContext.tagsets` формируется из tag‑sets текущего контекста.
- Неизвестные теги разрешены (как глобальные), но `TAGSET`/`TAGONLY` работают только для известных tag‑sets.

### 8.2. `{% mode %}`
- При входе в `{% mode %}` валидировать, что режим входит в доступные наборы контекста.
- Несовместимый режим → ошибка.

### 8.3. Render / Report
- Для `render/report` используется adaptive‑модель, рассчитанная для target'а:
  - `ctx:<name>` → полный расчёт по шаблону и frontmatter;
  - `sec:<name>` → адаптивная модель **только этой секции** (и её `extends`).
- `--provider` (опциональный) передаётся в `RunOptions` и доступен:
  - в `ConditionContext` для оценки условий `provider:<base-id>`;
  - нормализованный base‑id вычисляется при инициализации и кешируется.
- Если `--provider` не указан, условие `provider:*` всегда False.

### 8.4. Условие `provider:`

Новый условный оператор для шаблонов:

```
provider:<base-id>
```

**Семантика**: True, если текущий `--provider` (после нормализации) совпадает с `<base-id>`.

**Нормализация**: от полного provider‑id отсекается последний суффикс, обозначающий техническое средство:
- `.cli` — CLI‑инструмент
- `.ext` — IDE‑расширение
- `.api` — прямой API‑вызов

Если суффикс отсутствует (например, `clipboard`), id используется как есть.

**Примеры**:
- `--provider com.anthropic.claude.cli` → `provider:com.anthropic.claude` = True
- `--provider com.github.copilot.ext` → `provider:com.github.copilot` = True
- `--provider com.openai.api` → `provider:com.openai` = True
- `--provider clipboard` → `provider:clipboard` = True
- Если `--provider` не указан → любое условие `provider:*` = False

**Использование в шаблонах**:

```markdown
{% if provider:com.anthropic.claude %}
<!-- Инструкции, специфичные для Claude -->
{% endif %}

{% if provider:clipboard %}
<!-- Облегчённый контекст для ручного копирования -->
{% endif %}
```

### 8.5. `clipboard` — универсальный провайдер

Провайдер `clipboard` является особым: он неявно совместим со **всеми** режимами,
так как через буфер обмена данные могут быть переданы в любой AI‑инструмент.

Правила:
- `Mode.has_provider("clipboard")` → всегда True (ключ `runs["clipboard"]` подразумевается неявно);
- фильтрация `filter_by_provider("clipboard")` не отсеивает ни одного режима;
- валидация `validate_provider_support("clipboard")` — всегда проходит;
- `list contexts --provider clipboard` — возвращает все контексты.

---

## 9. CLI‑интерфейс и схемы

### 9.1. Новые list‑команды

```
listing-generator list mode-sets --context <ctx-name> --provider <provider-id>
listing-generator list tag-sets  --context <ctx-name>
```

Требования:
- `--context` обязателен для обоих;
- `--provider` обязателен для `mode-sets`.

### 9.1a. `--provider` для list contexts

```
listing-generator list contexts [--provider <provider-id>]
```

При указании `--provider` из списка исключаются контексты, несовместимые с данным провайдером.
Контекст считается несовместимым, если его адаптивная модель не содержит интеграционного набора режимов
с хотя бы одним режимом, поддерживающим данный провайдер.

Без `--provider` возвращаются все контексты (обратная совместимость).

### 9.2. Фильтрация mode‑sets
- Контентные наборы возвращаются **полностью**.
- Интеграционный набор фильтруется по `provider-id`: режимы без `runs[provider-id]` не возвращаются.
- Если после фильтрации интеграционный набор пуст — ошибка (провайдер не поддержан этим контекстом).

### 9.2a. `--provider` для render/report

```
listing-generator render <target> --lib ... --encoder ... --ctx-limit ... [--provider <provider-id>]
listing-generator report <target> --lib ... --encoder ... --ctx-limit ... [--provider <provider-id>]
```

Аргумент `--provider` — опциональный. При указании:
- provider‑id сохраняется в `RunOptions.provider`;
- нормализованный base‑id доступен для условий `provider:` в шаблонах;
- не влияет на фильтрацию файлов (это задача тегов и `vcs_mode`).

### 9.3. JSON‑схемы
- Обновить `lg/config/mode_sets_list.schema.json`:
  - добавить `runs` в Mode;
  - добавить `integration` (bool) на уровне ModeSet.
- Обновить `mode_sets_list_schema.py` (pydantic).

---

## 10. Ошибки и диагностика

Обязательные ошибки:
- цикл в `extends`;
- неизвестная секция в `extends` или frontmatter;
- попытка рендера мета‑секции (нет `filters`);
- 0 или >1 интеграционный mode‑set для контекста;
- интеграционный mode‑set после фильтрации по provider пуст;
- `{% mode %}` с несовместимым режимом;
- условие `provider:` при отсутствии `--provider` — не ошибка (просто False).

---

## 11. Тесты (минимум)

1) Наследование `extends`:
   - объединение set’ов;
   - переопределение mode/tag (child wins).
2) Мета‑секции:
   - ошибка при рендере без `filters`.
3) Frontmatter:
   - корректный `include` + удаление из рендера.
4) Сбор секций из шаблона:
   - транзитивные includes;
   - секции в `{% if %}` учитываются.
5) Правило единственного интеграционного набора.
6) Фильтрация по провайдеру + ошибка при пустом интеграционном наборе.
7) Валидность `{% mode %}`.
8) Условие `provider:` — нормализация суффиксов и сравнение base‑id.

---

## 12. Рефакторинг/чистка

- удалить использование `AdaptiveConfigLoader` и глобальных `modes.yaml`/`tags.yaml`;
- убрать Enum `AiInteractionMode` из CLI‑контекста (остаётся только в UI);
- разделить адаптивную логику на отдельные модули (см. 7.1) для снижения связности.

---

## 13. Выходные артефакты

- Обновлённые команды `list mode-sets/tag-sets`.
- Новые схемы JSON.
- Новые/обновлённые модули adaptive‑подсистемы.
- Полностью функциональная работа новых режимов/тегов в render/report.
