# Новая система режимов и тегов — согласованная аналитика (LG)

Дата: 2026-01-23

## 1. Контекст и цели

Цель — переработать систему адаптивных режимов и тегов в Listing Generator (LG) и связанных UI-плагинах (VS Code, IntelliJ), чтобы:
- убрать жёсткую привязку к фиксированным mode-set’ам `ai-interaction`, `dev-stage`;
- позволить пользователям строить свои наборы режимов без ломания интеграций;
- сделать режимы и теги **контекстно‑зависимыми** (по выбранному контексту/AI‑провайдеру);
- расширить модель режимов через `runs`, чтобы UI‑плагины могли корректно запускать выбранный AI‑провайдер;
- отказаться от глобальных `modes.yaml` и `tags.yaml` в пользу вложенной в секции модели;
- обеспечить пересборку конфигурации через наследование секций.

Обратная совместимость со старой моделью **не требуется** (будет миграция в конце проекта).

---

## 2. Ключевые проблемы старой модели

1) **Жёсткий `ai-interaction`**. UI‑плагины ожидают фиксированное наличие `ai-interaction` и Enum `AiInteractionMode`, иначе кнопка “Send to AI” ломается.

2) **Неполный набор режимов** (например, отсутствует полноценный “plan” режим, давно ожидаемый в современных AI‑системах).

3) **Глобальность режимов/тегов** не соответствует реальности: часть контекстов несовместима с частью режимов.

4) **Подмена режимов инструментами**. Для интеграций приходилось заводить дополнительные mode‑sets (“ai-tools”), что смешивает смысл “режима работы” и “инструмента” и ведёт к устареванию.

---

## 3. Новая модель режимов

### 3.1. Два вида наборов режимов

Наборы режимов делятся на два типа:
- **Интеграционные** — содержат `runs` и описывают режимы запуска AI‑провайдера.
- **Контентные** — не содержат `runs` и используются только для адаптивного контента.

Важно: после резолва всех наборов режимов для активного контекста **должен существовать ровно один интеграционный набор режимов**. Все остальные наборы — контентные. Если интеграционных наборов 0 или больше 1 — это **ошибка**.

Это правило предотвращает ситуацию, когда выбраны несколько режимов с противоречивыми `runs` и непонятно, какие параметры запуска применять при “Send to AI”.

### 3.2. Формат `runs`

На старте фиксируем **строковый формат**. Пример:

```yaml
mode-sets:
  ai-interaction:
    title: "AI Interaction"
    modes:
      ask:
        title: "Ask"
        description: "Question-answer mode"
        runs:
          com.github.copilot.ext: "workbench.action.chat.openask"
          com.anthropic.claude.cli: "--permission-mode default"
          com.openai.codex.cli: "--sandbox read-only --ask-for-approval on-request"
      agent:
        title: "Agent"
        description: "Normal agent work"
        tags: [agent]
        runs:
          com.github.copilot.ext: "workbench.action.chat.openagent"
          com.anthropic.claude.cli: "--permission-mode acceptEdits"
          com.openai.codex.cli: "--sandbox workspace-write --ask-for-approval on-request"
      plan:
        title: "Plan"
        description: "Planning mode"
        tags: [agent]
        runs:
          com.github.copilot.ext: "workbench.action.chat.openplan"
          com.anthropic.claude.cli: "--permission-mode plan"
          # com.openai.codex.cli — отсутствует (провайдер не поддерживает plan)
```

`runs` трактуется исключительно UI‑плагинами, LG CLI не интерпретирует содержимое.

### 3.3. Канонические идентификаторы провайдеров
Формат **обязательный**:

```
<reverse-dns>.<product>.<type>
```

Примеры:
- `com.github.copilot.ext`
- `com.anthropic.claude.cli`
- `com.openai.codex.cli`
- `com.jetbrains.ai.ext`
- `org.jetbrains.junie.ext`

Требования:
- lower‑case
- допустимые символы: `a-z`, `0-9`, `.`, `-`, `_`

### 3.4. Безопасность `runs`
Так как `runs` берётся из репозитория, UI‑плагинам требуется:
- предупреждать при наличии “нестандартных” или неизвестных `runs`;
- запрашивать подтверждение пользователя перед исполнением.

---

## 4. Новая модель хранения (без глобальных файлов)

### 4.1. Отказ от `modes.yaml`/`tags.yaml`
Режимы и теги **встраиваются в секции** (в любое место, где описывается секция). Глобальные файлы более не используются.

### 4.2. Мета‑секции
Мета‑секция — секция **без `filters`**. Такие секции:
- **не рендерятся** напрямую;
- используются как прототипы/источники режимов и тегов;
- могут наследоваться через `extends`.

### 4.3. Frontmatter для контекстов
Каждый `.ctx.md` может иметь YAML frontmatter. Первый MVP‑формат:

```markdown
---
include:
  - "modes/base"
  - "tags/base"
---
```

Также допускается короткая запись:

```markdown
---
include: ["ai-interaction"]
---
```

`include` указывает секции (обычно мета‑секции), чьи режимы/теги должны быть учтены при расчёте доступных режимов/тегов **для данного контекста**, даже если эти секции не используются как плейсхолдеры.

**Важно:** Frontmatter используется только для расчёта режимов/тегов, **не рендерится** в финальном `render`.

### 4.4. Каноничная базовая мета‑секция
IDE‑плагины (VS Code / IntelliJ) должны уметь генерировать/обновлять каноничную мета‑секцию (например `lg-cfg/ai-interaction.sec.yaml`) с актуальными `runs` под поддерживаемые провайдеры. Пользователь может её наследовать или копировать.

---

## 5. Наследование секций (`extends`)

### 5.1. Что наследуется
Наследуются и **мерджатся**:
- `mode-sets`
- `tag-sets`
- `extensions`
- конфиги языковых адаптеров
- `skip_empty`
- `path_labels`

**Не наследуются**:
- `filters`
- `targets`

### 5.2. Правила мерджа

- Set’ы с одинаковыми `id` объединяются.
- При коллизии `id` режима или тега действует правило **child wins** (переопределение).
- `title`/`description` могут переопределяться (по сути — допустимое “переименование”).

### 5.3. Детеминированный порядок

- Для одной секции: `extends` разворачивается **depth‑first, left‑to‑right**, затем применяется локальная секция.
- Для контекста: секции из шаблона обходятся **depth‑first, left‑to‑right**, затем применяются секции из frontmatter.

---

## 6. Расчёт доступных режимов и тегов для контекста

### 6.1. Источники
Доступные режимы/теги вычисляются из:
1) всех секций, использованных в контексте (транзитивно по плейсхолдерам и includes);
2) секций из frontmatter `include`.

### 6.2. Что НЕ учитывается
Плейсхолдеры `${md:...}` не включаются в расчёт, так как они не описывают tag‑sets/mode‑sets.

### 6.3. Условия
При расчёте режимов/тегов **не выполняются** условия (`{% if %}`), все секции учитываются как факт использования.

---

## 7. `{% mode %}` в шаблонах

- `{% mode %}` должен указывать **режимы, совместимые с контекстом**.
- Если режим не входит в вычисленную для контекста модель — это **ошибка**.

---

## 8. Глобальные теги

Глобальные теги (вне tag‑sets) сохраняются как концепция, но **не нуждаются в явном объявлении**. Любой тег, не принадлежащий ни одному tag‑set, считается глобальным и может участвовать в условиях `tag:`.

**TAGSET** и **TAGONLY** работают только с явно определёнными tag‑sets.

UI не отображает глобальные теги отдельным списком (как и сейчас).

---

## 9. UI‑поведение (VS Code и IntelliJ)

### 9.1. Запрос режимов
UI запрашивает список mode‑sets у CLI **по контексту и выбранному провайдеру**.

Логика ответа:
- **Контентные** наборы режимов возвращаются **полностью**, независимо от провайдера.
- **Интеграционный** набор режимов фильтруется по провайдеру: если у режима нет `runs` для выбранного провайдера — этот режим не возвращается.

### 9.2. Запрос тегов
UI запрашивает tag‑sets **по контексту**.

### 9.3. Хранение состояния
- Режимы хранятся по ключу **(context, provider)**.
- Теги хранятся по ключу **context**.
- Если режим/тег стал недоступен — сброс на дефолт.

### 9.4. Поведение при обновлении конфигурации
UI должен актуализировать состояние при:
- смене контекста;
- смене провайдера;
- изменении `lg-cfg/` (watcher).

---

## 10. CLI‑API (уровень требований)

Нужно расширить CLI, чтобы он:
- умел возвращать mode‑sets/ tag‑sets **с учётом выбранного контекста**;
- умел фильтровать **интеграционный** mode‑set по **provider id** (контентные — без фильтрации);
- учитывал `extends` и frontmatter при сборке модели.

Предварительная форма запроса (пример):

```
listing-generator list mode-sets --context <ctx-name> --provider <provider-id>
listing-generator list tag-sets  --context <ctx-name>
```

Точные флаги могут быть изменены при проектировании CLI, но требования должны соблюдаться.

---

## 11. Дополнительные требования к реализации

- LG CLI не должен интерпретировать `runs` (это ответственность IDE‑плагинов).
- В шаблонах `{% mode %}` валидируется по «контекстной» модели.
- Метасекции без `filters` не рендерятся (ошибка при попытке).

---

## 12. Следующие шаги

На основе этой аналитики будут подготовлены 3 ТЗ:
1) LG CLI — новая модель режимов/тегов, frontmatter, extends, новые list‑команды.
2) VS Code Extension — обновление UI логики, запросов к CLI, хранение состояния, `runs` и безопасность.
3) IntelliJ Plugin — аналогично VS Code, с учётом специфики платформы.

---

## Приложение: краткое резюме ключевых изменений

- Полный отказ от глобальных `modes.yaml`, `tags.yaml`.
- Режимы/теги живут внутри секций, поддерживают `extends`.
- Контекст определяет доступные режимы/теги транзитивным анализом шаблонов.
- `runs` — строковые команды/аргументы для AI‑провайдеров (обрабатываются IDE‑плагинами).
- Провайдеры используют канонический reverse‑DNS формат.
- UI хранит состояния per (context, provider) и актуализирует при изменениях.
