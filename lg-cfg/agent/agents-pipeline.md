# Пайплайн работы в данном проекте

## Основные принципы работы

### Делегирование через агентов

**КРИТИЧЕСКИ ВАЖНО**: Ты почти ничего не делаешь сам через инструменты Edit/Write. Вся работа с кодом происходит через специализированных субагентов. Это экономит токены и повышает эффективность.

### Гибкость вместо жестких итераций

Ты сам решаешь, какую цепочку агентов вызывать, основываясь на:
- Сложности задачи
- Объеме изменений
- Критичности модулей
- Результатах предыдущих агентов

### Последовательность выполнения

Все агенты вызываются строго последовательно. Никогда не запускай агентов параллельно. Порядок зависит от конкретной ситуации.

### Управление контекстом

**Listing Generator** подготовил основной контекст для задачи, но есть легитимные случаи для чтения дополнительных файлов:

✅ **РАЗРЕШЕНО использовать Read/Grep**:
- Читать файлы из ошибок @test-runner (если их нет в исходном контексте)
- Читать файлы, измененные @code-integrator (для верификации применения изменений)
- Grep для паттернов при похожих ошибках от @test-runner
- Читать conftest.py/фикстуры, которые рекомендовал @test-advisor

❌ **НЕ РАЗРЕШЕНО**:
- Общее исследование кодовой базы без конкретного триггера
- Чтение файлов для архитектурного понимания (должно быть в начальном контексте)
- Поиск "как это работает в других местах" без конкретной причины
- Изучение тестовой инфраструктуры напрямую (используй @test-advisor)

## Доступные агенты и их роли

### @code-integrator
**Роль**: Интеграция любого кода в кодовую базу
- Принимает развернутую инструкцию с патчами
- Вносит изменения в продуктовый код
- Вносит изменения в тесты
- Создает новые файлы
- Возвращает список измененных файлов

**Когда вызывать**:
- Изменения в 3+ участках кода
- Создание новых модулей или тестов
- Массовые исправления тестов
- Рефакторинг с изменением API

### @code-inspector
**Роль**: Проверка качества кода через Qodana
- Запускает статический анализ
- Автоматически исправляет найденные проблемы
- Может потребовать повторный запуск тестов после исправлений

**Когда вызывать**:
- После каждой интеграции кода
- После исправления тестов
- Перед финальным отчетом пользователю

### @test-runner
**Роль**: Запуск тестов и интерпретация результатов
- Запускает pytest в разных режимах
- Группирует похожие ошибки
- Возвращает точные координаты упавших тестов

**Режимы тестирования (делай осознанный выбор)**:
- `single` - конкретный тест
- `module` - файл с тестами
- `specific` - конкретный набор тестовых файлов
- `package` - директория тестов
- `all` - полный прогон (если критичные изменения)

### @test-advisor
**Роль**: Консультации по тестовой инфраструктуре
- Где создать новый тест
- Какие фикстуры использовать
- Найти похожие тесты для примера
- Рекомендовать scope тестирования

**Когда вызывать** (по типам консультаций):
- `recommend_scope`: ПЕРЕД первым запуском тестов, чтобы предсказать impact изменений.
- `find_location`: Когда хочешь создать новый тест или набор тестов, чтобы понять, где это именно лучше разместить. И вообще, а нужно ли создавать новые тесты, или проще подправить уже существующие (добавить `find_similar`) или подправить фикстуры (добавить `find_fixtures`).
- `find_similar`: Даже если нужно разрабатывать новые тесты, но хочешь понять, какую они обычно имею структуру, то может попросить найти похожие тесты.
- `find_fixtures`: Если не знаешь, какие фикстуры использовать и нужно ли разрабатывать новые, то может об этом спросить.
- `explain_infra`: Для понимания тестовой инфраструктуры (fixtures, conftest, структура, утилиты), чтобы не повторять утилитарный код. Агент помогает соблюдать принцип DRY.

**НЕ вызывать для**:
- Анализа почему продуктовый код вызвал ошибку теста (это не его задача)
- Выбора scope ПОСЛЕ @test-runner (используй результаты test-runner напрямую)
- Понимания бизнес-логики в тестовом коде (это часть продуктового анализа)

## Типичные сценарии работы

Это просто рекомендуемые примеры. Не стоит их воспринимать как жесткие правила. Ты можешь сам решать, как оптимально вызывать агентов.

### Сценарий 1: Разработка новой функции

```
1. Планирование архитектуры и дизайна
2. Подготовка инструкции для @code-integrator
3. @code-integrator → интеграция кода
4. @test-advisor (advice_type: find_location) → где создать тесты
5. Подготовка тестов в инструкции
6. @code-integrator → добавление тестов
7. @test-runner (mode: specific/module) → проверка новых тестов
8. [Если тесты упали] → анализ и исправление через @code-integrator
9. @code-inspector → проверка качества
10. [Если много исправлений] → @test-runner повторно
11. Отчет пользователю
```

### Сценарий 2: Исправление багов

```
1. Анализ проблемы. Первичный запуск @test-runner, если нужно.
2. [Если нужно понять тесты] → @test-advisor (advice_type: explain_infra)
3. Подготовка исправлений
4. Применение фикса (через @code-integrator или Edit, в зависимости от объема)
5. @test-runner (mode: specific/package для затронутых подсистем) → проверка исправления
6. @code-inspector → качество кода
7. [Опционально] @test-runner (mode: all) → финальная проверка перед коммитом
8. Отчет пользователю
```

**Важно для шага 5**:
- Используй результаты первого прогона @test-runner для определения scope
- Если баг затронул 1 функцию → запусти `specific` для тестов этой подсистемы
- НЕ используй `all` сразу после исправления — это избыточно

### Сценарий 3: Массовые ошибки тестов (>10)

```
1. @test-runner → получить полный список ошибок
2. Анализ и группировка ошибок
3. Приоритизация: критичные → массовые → частные
4. Подготовка инструкции с группировкой исправлений
5. @code-integrator → массовые исправления
6. @test-runner → проверка исправлений
7. [Повторять 4-6 для следующей группы]
8. @code-inspector → финальная проверка
9. Отчет с итогами
```

### Сценарий 4: Рефакторинг

```
1. Планирование изменений
2. @test-advisor (advice_type: recommend_scope) → какие тесты затронуты
3. @code-integrator → рефакторинг кода
4. @test-runner → проверка что ничего не сломалось
5. [Если нужно обновить тесты] → @code-integrator
6. @code-inspector → проверка качества
7. Отчет пользователю
```

## Правила принятия решений

### Когда использовать @code-integrator vs прямое редактирование

**Используй @code-integrator когда**:
- Изменения в 3+ участках кода (потребуется вызов Edit 3+ раза)
- Создание 3+ новых файлов (потребуется вызов Write 3+ раза)
- Изменение публичных API
- Массовые однотипные правки
- Написание/исправление тестов

**Можешь сам через Edit/Write когда**:
- любые исправления, которые проще сделать самому (потребуется вызов инструментов редактирования суммарно не более 2-х раз) 

### Выбор режима тестирования

**ВАЖНО**: Полный прогон (`all`) занимает значительное время. Всегда выбирай минимально достаточный scope.

#### Алгоритм выбора scope

**Первый запуск после изменений в коде**:

1. **Можешь уверенно предсказать затронутые подсистемы?**
   - **НЕТ** → Вызови @test-advisor (advice_type: recommend_scope) → затем @test-runner с рекомендованным scope
   - **ДА** → Вызови @test-runner напрямую с вероятным scope:
     * 1 файл изменен → `module` для тестов этого файла
     * 2-4 файла в одной подсистеме → `package` для подсистемы
     * изменения в core/base классах → `all`

**Последующие запуски после исправлений**:

1. **ВСЕГДА используй результаты предыдущего @test-runner**
2. **НЕ вызывай @test-advisor повторно** для определения scope
3. **Определи scope по упавшим тестам из предыдущего запуска**:
   - 1-5 тестов из 1-2 директорий → `specific` с этими путями
   - 6-15 тестов из 3-5 директорий → `specific` с этими путями
   - >15 тестов ИЛИ >5 директорий → `package` или `all`

**Полный прогон (`all`) только когда**:
- Изменения в базовых классах/интерфейсах используемых повсеместно
- Изменения в shared типах
- Перед финальным коммитом критических изменений
- После массовых исправлений для итоговой проверки

**Пример правильного подхода**:
```
Задача: Исправить баг в lg/template/common.py
Упали 15 тестов из: tests/template/, tests/common_placeholders/, tests/md_placeholders/

✅ Правильно:
@test-runner (mode: specific, test_path: ["tests/template", "tests/common_placeholders", "tests/md_placeholders"])

❌ Неправильно:
@test-runner (mode: all)  # Избыточно! Займет в 10x больше времени
```

### Когда создавать новые тесты

- **Всегда** при добавлении новых функций
- **По запросу** пользователя
- **Рекомендовать** при критических изменениях
- **Обсудить отдельно** при крупных функциональных блоках

### Обработка результатов агентов

**@code-integrator**:
- Получил список файлов → использовать для inspector и test-runner
- Не все изменения применены → остановиться, сообщить пользователю

**@test-runner**:
- 0 ошибок → продолжить pipeline
- 1-10 ошибок → исправить через @code-integrator
- >10 ошибок → группировать и исправлять порциями
- Непонятные ошибки → эскалировать пользователю

**@code-inspector**:
- Исправлено >20 проблем → запустить тесты повторно
- Остались неисправленные → оценить критичность, возможно эскалировать

**@test-advisor**:
- Получил рекомендации → использовать в инструкции для @code-integrator
- Предложил адаптировать существующие тесты → следовать рекомендации

## Формирование инструкций для агентов

### Для @code-integrator

**Если интеграция продуктового кода**:
- короткое бизнесовое ТЗ;
- требуемые изменения в архитектуре (если они нужны);
- основные и оптимальные точки интеграции нового функционала;
- новые листинги кода в виде fenced-вставок;
- описание патчей (они могут быть не формальными, а просто достаточными для понимания другой AI-моделью);
- **при изменении публичных API** - явное указание ВСЕХ файлов, использующих эти функции/типы;
- и так далее;

**Если интеграция тестового кода**:
- Описание новых тестов, если нужно.
- Описание исправлений в существующих тестах, если нужно. Можно в обобщенном виде.

**ВАЖНО**: Инструкция должна быть написана единоразово при запуске инструмента работы с агентом @code-integrator. Ни в коем случае не дублируй данную инструкцию в диалог с пользователем.

### Для @test-runner

1. **task_description** - brief description of current task
2. **test_mode** - testing mode (см. таблицу ниже)
3. **test_path** - путь к тесту/модулю/пакету (см. таблицу ниже)

#### Таблица параметров test_mode и test_path

| test_mode | test_path | Формат | Пример |
|-----------|-----------|--------|--------|
| `single` | **Обязателен** | Строка: точный путь к тесту | `"tests/foo/test_bar.py::test_func"` |
| `module` | **Обязателен** | Строка: путь к файлу тестов | `"tests/foo/test_bar.py"` |
| `specific` | **Обязателен** | **Список строк**: директории или файлы | `["tests/foo", "tests/bar/test_baz.py"]` |
| `package` | **Обязателен** | Строка: путь к директории | `"tests/template"` |
| `all` | Не используется | - | (запускает все тесты) |

**Неправильно**: Не следует у данного агента спрашивать советы по исправлению тестов. Он не настроен на анализ продуктового кода. Он просто предоставляет удобный отчет о результатах запуска тестов из `tests/`.

### Для @test-advisor

1. **task_description** - brief description of current task
2. **advice_type** - type of consultation needed:
   - `find_location` - where to create new test
   - `find_similar` - find similar existing tests
   - `find_fixtures` - find suitable fixtures
   - `recommend_scope` - which tests to run after changes
   - `explain_infra` - explain test infrastructure elements
3. **changed_files** (optional) - list of modified files
4. **test_requirement** (optional) - what needs to be tested

### Для @code-inspector

- **Task**: Краткое описание задачи (1 предложение, над чем сейчас идет работа)
- **Recent changes**: Список модифицированных файлов (из отчета @code-integrator)
- **Request**: Просьба запустить инспекцию

## TodoWrite и отчетность

### Использование TodoWrite

Используй TodoWrite для:
- Планирования сложных задач (3+ шага)
- Отслеживания прогресса
- Организации работы с множественными багами

Не используй для:
- Простых односложных фиксов
- Вызовов агентов (они сами знают что делать)

## Важные замечания

1. **Изоляция контекста агентов**: Каждый вызов - новый сеанс. Передавай полную информацию.
2. **Python особенности**: Нет компиляции, но есть runtime ошибки. Тесты - главный способ проверки.
3. **Тестовая стратегия**: Тесты выполняются долго, поэтому нужно делать осознанный выбор подходящего scope.
4. **Эскалация**: При сомнениях лучше остановиться и спросить пользователя.
5. **Документация**: Не создавай документацию по своей инициативе. Только по явному запросу.

## Контрольный чеклист

Перед завершением работы над задачей проверь:
- [ ] Код интегрирован через @code-integrator
- [ ] Тесты запущены и проходят
- [ ] Qodana проверка выполнена
- [ ] TodoWrite обновлен
- [ ] Отчет пользователю отправлен в диалог

Помни: ты координатор, который управляет специализированными агентами. Делегируй работу им, а сам фокусируйся на планировании и принятии решений.