# Разделение BlockInitProcessor на два компонента

## Проблема

Компонент `BlockInitProcessor` (450 строк) обрабатывает два различных паттерна императивной инициализации:

1. **Block-based**: Java double-brace initialization `new HashMap() {{ put(...); put(...); }}`
2. **Let-group-based**: Rust HashMap initialization `let mut m = HashMap::new(); m.insert(...); m.insert(...);`

Методы `_process_block` и `_process_let_group` имеют схожую структуру (~40% дублирования), но различаются деталями. Маршрутизация между ними происходит внутри компонента через проверку типа узла, что усложняет понимание кода.

Текущая оценка модуля: **6/10** — смешение двух различных паттернов в одном компоненте.

## Целевые файлы

- `lg/adapters/optimizations/literals/components/block_init.py` (разделить)
- `lg/adapters/optimizations/literals/components/java_double_brace.py` (создать)
- `lg/adapters/optimizations/literals/components/rust_let_group.py` (создать)
- `lg/adapters/optimizations/literals/components/__init__.py` (обновить экспорты)

## План рефакторинга

### Шаг 1: Выделить базовый класс с общей логикой

Создать базовый класс `BlockInitProcessorBase` в `block_init.py`:

```python
"""
Base class for imperative block initialization processors.

Provides common functionality for different initialization patterns.
"""

from abc import ABC, abstractmethod
from typing import List, Optional, Tuple

from lg.adapters.tree_sitter_support import Node, TreeSitterDocument
from ..patterns import TrimResult, BlockInitProfile, LiteralProfile


class BlockInitProcessorBase(ABC):
    """
    Base class for block initialization processors.

    Subclasses implement specific patterns (Java double-brace, Rust let-group).
    """

    def __init__(
        self,
        tokenizer,
        all_profiles: List[LiteralProfile],
        process_literal_callback,
        comment_style: tuple[str, tuple[str, str]],
    ):
        """Initialize base processor."""
        self.tokenizer = tokenizer
        self.all_profiles = all_profiles
        self.process_literal_callback = process_literal_callback
        self.single_comment = comment_style[0]
        self.block_comment = comment_style[1]
        self.source_text = None
        self.doc = None

    @abstractmethod
    def can_handle(self, profile: LiteralProfile, node, doc) -> bool:
        """Check if this component can handle the pattern."""
        pass

    @abstractmethod
    def process(
        self,
        node,
        doc,
        source_text: str,
        profile: BlockInitProfile,
        token_budget: int,
    ) -> Optional[TrimResult]:
        """Process the block initialization pattern."""
        pass

    def _optimize_statement_recursive(
        self,
        stmt_node: Node,
        doc: TreeSitterDocument,
        token_budget: int,
    ) -> str:
        """
        Recursively optimize nested literals within a statement (DFS).

        Common implementation used by all subclasses.
        """
        # ... (existing implementation from BlockInitProcessor)
        pass

    def _matches_pattern(self, node: Node, pattern: str, doc: TreeSitterDocument) -> bool:
        """Check if node matches a pattern."""
        # ... (existing implementation)
        pass

    def _matches_in_subtree(self, node: Node, pattern: str, doc: TreeSitterDocument) -> bool:
        """Check if pattern matches anywhere in subtree."""
        # ... (existing implementation)
        pass
```

### Шаг 2: Создать JavaDoubleBraceProcessor

Создать файл `java_double_brace.py`:

```python
"""
Java double-brace initialization processor.

Handles patterns like:
    new HashMap<>() {{
        put("key1", "value1");
        put("key2", "value2");
    }}
"""

from __future__ import annotations

from typing import Optional

from .block_init import BlockInitProcessorBase
from ..patterns import BlockInitProfile, TrimResult


class JavaDoubleBraceProcessor(BlockInitProcessorBase):
    """
    Processes Java double-brace initialization patterns.
    """

    def can_handle(self, profile, node, doc) -> bool:
        """
        Check applicability.

        Applicable to BlockInitProfile with object_creation_expression.
        """
        if not isinstance(profile, BlockInitProfile):
            return False

        # Java double-brace uses object_creation_expression or block nodes
        return node.type in ("object_creation_expression", "block", "class_body")

    def process(
        self,
        node,
        doc,
        source_text: str,
        profile: BlockInitProfile,
        token_budget: int,
    ) -> Optional[TrimResult]:
        """Process Java double-brace initialization."""
        self.source_text = source_text
        self.doc = doc

        from ..utils.indentation import detect_base_indent
        base_indent = detect_base_indent(source_text, node.start_byte)

        # Process as single block
        result = self._process_block(profile, node, doc, token_budget, base_indent)
        if result:
            result.nodes_to_replace = [node]
        return result

    def _process_block(self, profile, node, doc, token_budget, base_indent):
        """
        Process a block-based initialization.

        Implementation extracted from original BlockInitProcessor._process_block
        """
        # ... (existing implementation from BlockInitProcessor._process_block)
        pass

    def _find_statements_block(self, node, profile, doc):
        """Find the block containing statements to process."""
        # ... (existing implementation)
        pass

    def _get_child_statements(self, block_node):
        """Get child statements from block."""
        # ... (existing implementation)
        pass

    def _select_statements(self, statements, doc, token_budget):
        """Select which statements to keep and remove."""
        # ... (existing implementation)
        pass

    def _reconstruct_block(self, original_node, keep_stmts, remove_stmts, profile, doc, base_indent, token_budget):
        """Reconstruct block with kept statements and placeholder."""
        # ... (existing implementation)
        pass
```

### Шаг 3: Создать RustLetGroupProcessor

Создать файл `rust_let_group.py`:

```python
"""
Rust let-group initialization processor.

Handles patterns like:
    let mut m = HashMap::new();
    m.insert("key1", "value1");
    m.insert("key2", "value2");
"""

from __future__ import annotations

from typing import Optional, List

from .block_init import BlockInitProcessorBase
from ..patterns import BlockInitProfile, TrimResult


class RustLetGroupProcessor(BlockInitProcessorBase):
    """
    Processes Rust let-group initialization patterns.
    """

    def can_handle(self, profile, node, doc) -> bool:
        """
        Check applicability.

        Applicable to BlockInitProfile with let_declaration.
        """
        if not isinstance(profile, BlockInitProfile):
            return False

        return node.type == "let_declaration"

    def process(
        self,
        node,
        doc,
        source_text: str,
        profile: BlockInitProfile,
        token_budget: int,
    ) -> Optional[TrimResult]:
        """Process Rust let-group initialization."""
        self.source_text = source_text
        self.doc = doc

        from ..utils.indentation import detect_base_indent
        base_indent = detect_base_indent(source_text, node.start_byte)

        # Process as let-group (expands to multiple nodes)
        return self._process_let_group(profile, node, doc, token_budget, base_indent)

    def _process_let_group(self, profile, node, doc, token_budget, base_indent):
        """
        Process a let-declaration group.

        Implementation extracted from original BlockInitProcessor._process_let_group
        """
        # ... (existing implementation from BlockInitProcessor._process_let_group)
        pass

    def _is_collection_init(self, node, doc) -> bool:
        """Check if let_declaration initializes HashMap::new() or Vec::new()."""
        # ... (existing implementation)
        pass

    def _extract_var_name(self, node, doc) -> Optional[str]:
        """Extract variable name from let_declaration."""
        # ... (existing implementation)
        pass

    def _collect_insert_statements(self, let_node, var_name, profile, doc) -> List:
        """Collect following statements that call methods on var_name."""
        # ... (existing implementation)
        pass

    def _statement_calls_var(self, stmt, var_name, doc) -> bool:
        """Check if statement calls a method on var_name."""
        # ... (existing implementation)
        pass

    def _get_group_text(self, let_node, insert_stmts, doc) -> str:
        """Get combined text for entire group."""
        # ... (existing implementation)
        pass

    def _reconstruct_let_group(self, let_node, keep_inserts, remove_inserts, profile, doc, base_indent, token_budget):
        """Reconstruct let group with trimmed inserts."""
        # ... (existing implementation)
        pass
```

### Шаг 4: Обновить регистрацию в Pipeline

Обновить `LiteralPipeline.__init__` в `pipeline.py`:

```python
# Special components (ordered by priority)
self.special_components = [
    StringLiteralProcessor(...),
    ASTSequenceProcessor(...),
    JavaDoubleBraceProcessor(  # Вместо BlockInitProcessor
        self.adapter.tokenizer,
        self.descriptor.profiles,
        self._process_literal,
        comment_style
    ),
    RustLetGroupProcessor(     # Новый компонент
        self.adapter.tokenizer,
        self.descriptor.profiles,
        self._process_literal,
        comment_style
    ),
]
```

### Шаг 5: Обновить экспорты

Обновить `components/__init__.py`:

```python
from .ast_sequence import ASTSequenceProcessor
from .block_init import BlockInitProcessorBase
from .java_double_brace import JavaDoubleBraceProcessor
from .rust_let_group import RustLetGroupProcessor
from .string_processor import StringLiteralProcessor

__all__ = [
    'ASTSequenceProcessor',
    'BlockInitProcessorBase',
    'JavaDoubleBraceProcessor',
    'RustLetGroupProcessor',
    'StringLiteralProcessor',
]
```

## Критерии успешности

После рефакторинга:

1. **Четкое разделение паттернов**:
   - Java double-brace в отдельном компоненте
   - Rust let-group в отдельном компоненте
   - Общая логика в базовом классе

2. **Размер модулей**:
   - `block_init.py` (base): ~150 строк
   - `java_double_brace.py`: ~200 строк
   - `rust_let_group.py`: ~150 строк

3. **Расширяемость**:
   - Легко добавить новые паттерны (наследоваться от base)
   - Каждый паттерн изолирован и тестируется независимо

## Проверка результата

1. Запустить golden tests для Java и Rust:
   ```bash
   ./scripts/test_adapters.sh literals java,rust
   ```

## Ожидаемый результат

- ✅ Все golden tests проходят без изменений
- ✅ Каждый паттерн в отдельном компоненте
- ✅ Код более maintainable и testable
- ✅ Оценка модулей повышается с 6/10 до 8/10
