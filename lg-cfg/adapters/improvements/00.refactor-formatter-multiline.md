# Рефакторинг ResultFormatter._format_multiline_impl

## Проблема

Метод `ResultFormatter._format_multiline_impl` (строки 277-391 в `formatter.py`) содержит 114 строк и нарушает Single Responsibility Principle. Метод одновременно выполняет минимум 5 различных задач:

1. Сбор форматированных текстов элементов
2. Группировку элементов по `tuple_size`
3. Рекурсивную обработку вложенных структур
4. Вставку placeholder комментариев
5. Построение финального многострочного текста

Текущая оценка модуля: **5/10** — требует серьезного рефакторинга.

## Целевые файлы

- `lg/adapters/optimizations/literals/processing/formatter.py`

## План рефакторинга

### Шаг 1: Выделить метод для построения строк элементов

Создать приватный метод `_build_element_lines`:

```python
def _build_element_lines(
    self,
    elements: List[Element],
    selection: DFSSelection,
    parser: ElementParser,
    profile: LiteralProfile,
    elem_indent: str,
    separator: str,
    tuple_size: int,
    allow_trailing: bool,
    is_last_line: bool
) -> List[str]:
    """
    Build formatted lines for elements with proper indentation and separators.

    Args:
        elements: Elements to format
        selection: DFSSelection with nested selections
        parser: ElementParser for nested content
        profile: Profile with configuration
        elem_indent: Indentation for elements
        separator: Element separator (e.g., ",")
        tuple_size: Elements per group
        allow_trailing: Whether to allow trailing separator
        is_last_line: Whether this is the last line before closing

    Returns:
        List of formatted lines with indentation
    """
    lines = []

    for i in range(0, len(elements), tuple_size):
        group = elements[i:i + tuple_size]
        group_texts = []

        for elem_idx, elem in enumerate(group):
            global_idx = i + elem_idx
            if global_idx in selection.nested_selections:
                elem_text = self._reconstruct_element_with_nested(
                    elem, selection.nested_selections[global_idx], parser,
                    profile.placeholder_template,
                    is_multiline=True,
                    base_indent=elem_indent,
                    elem_indent=elem_indent + "    ",
                    inline_threshold=profile.inline_threshold
                )
            else:
                elem_text = elem.text
            group_texts.append(elem_text)

        group_text = f"{separator} ".join(group_texts)

        is_last_group = (i + tuple_size >= len(elements)) and is_last_line
        trailing_sep = separator if (allow_trailing or not is_last_group) else ""
        lines.append(f"{elem_indent}{group_text}{trailing_sep}")

    return lines
```

### Шаг 2: Выделить метод для вставки placeholder

Создать приватный метод `_add_placeholder_line`:

```python
def _add_placeholder_line(
    self,
    selection: DFSSelection,
    profile: LiteralProfile,
    elem_indent: str
) -> Optional[str]:
    """
    Generate placeholder comment line if elements were removed.

    Args:
        selection: DFSSelection with removal info
        profile: Profile with placeholder configuration
        elem_indent: Indentation for placeholder

    Returns:
        Formatted placeholder line or None
    """
    if selection.removed_count == 0:
        return None

    placeholder_position = profile.placeholder_position

    if placeholder_position == PlaceholderPosition.END:
        return f"{elem_indent}{profile.placeholder_template}"

    elif placeholder_position == PlaceholderPosition.MIDDLE_COMMENT:
        removed_count = selection.removed_count
        tokens_saved = selection.total_tokens_saved
        comment_text = f"… ({removed_count} more, −{tokens_saved} tokens)"
        return f"{elem_indent}{self.single_comment} {comment_text}"

    return None
```

### Шаг 3: Упростить основной метод через делегирование

Переписать `_format_multiline_impl`:

```python
def _format_multiline_impl(
    self,
    parsed: ParsedLiteral[LiteralProfile],
    selection: SelectionBase,
    placeholder: str,
    parser: Optional[ElementParser] = None,
) -> str:
    """
    Unified multiline formatting implementation.

    Handles both flat Selection and DFS selection with nested structures.
    """
    profile = parsed.profile
    elements = selection.kept_elements

    # Handle string literals
    if isinstance(profile, StringProfile):
        if isinstance(selection, DFSSelection):
            query = profile.query
            raise ValueError(
                f"String literals cannot use DFS selection. "
                f"Check language descriptor pattern: {query}"
            )
        return self._format_string(parsed, cast(Selection, selection))

    base_indent = parsed.base_indent
    elem_indent = parsed.element_indent or (base_indent + "    ")

    # Get configuration from profile
    separator = profile.separator if isinstance(profile, CollectionProfile) else ','
    tuple_size = profile.tuple_size if isinstance(profile, FactoryProfile) else 1
    placeholder_position = profile.placeholder_position
    allow_trailing = not isinstance(profile, FactoryProfile)

    # Build lines
    lines = []

    # Opening
    if parsed.wrapper:
        lines.append(f"{parsed.wrapper}{parsed.opening}")
    else:
        lines.append(parsed.opening)

    # Elements
    is_last_line = not selection.has_removals or placeholder_position != PlaceholderPosition.END

    element_lines = self._build_element_lines(
        elements, selection, parser, profile,
        elem_indent, separator, tuple_size,
        allow_trailing, is_last_line
    )
    lines.extend(element_lines)

    # Placeholder
    placeholder_line = self._add_placeholder_line(selection, profile, elem_indent)
    if placeholder_line:
        lines.append(placeholder_line)

    # Closing
    lines.append(f"{base_indent}{parsed.closing}")

    return "\n".join(lines)
```

### Шаг 4: Аналогично упростить single-line форматирование

Применить аналогичное разделение к `_format_single_line_impl` при необходимости.

## Критерии успешности

После рефакторинга:

1. **Размер методов**:
   - `_format_multiline_impl`: не более 60 строк
   - `_build_element_lines`: не более 40 строк
   - `_add_placeholder_line`: не более 20 строк

2. **SRP соблюдается**:
   - Каждый метод выполняет одну задачу
   - Логика построения строк отделена от вставки placeholder
   - Логика группировки отделена от форматирования

3. **Читаемость**:
   - Понятная структура без глубокой вложенности
   - Понятные имена методов
   - Четкая последовательность операций в основном методе

## Проверка результата

1. Запустить golden tests для всех языков:
   ```bash
   ./scripts/test_adapters.sh literals all
   ```

2. Проверить, что все тесты проходят без изменений в голденах

## Ожидаемый результат

- ✅ Все golden tests проходят без изменений
- ✅ Код более читаемый и поддерживаемый
- ✅ Каждый метод имеет одну четкую ответственность
- ✅ Оценка модуля повышается с 5/10 до 8/10
