# Устранение дублирования в BudgetSelector

## Проблема

Методы `BudgetSelector.select_dfs` (строки 128-226) и `BudgetSelector._select_dfs_tuples` (строки 228-291) содержат значительное дублирование (~60% кода):

**Что дублируется**:
- Логика подсчета токенов для элементов
- Проверки `can_afford`, `must_keep`, `must_preserve`
- Обработка nested selections с рекурсивными вызовами
- Вычисление оптимизированных размеров элементов
- Проверка exhausted бюджета

Текущая оценка модуля: **6/10** — дублирование усложняет поддержку и добавление новых стратегий.

## Целевые файлы

- `lg/adapters/optimizations/literals/processing/selector.py`

## План рефакторинга

### Шаг 1: Выделить метод для оценки элемента

Создать приватный метод `_evaluate_element`:

```python
def _evaluate_element(
    self,
    elem: Element,
    remaining_budget: int,
    kept_count: int,
    min_keep: int,
    preserve_all: bool,
    parser: ElementParser,
) -> tuple[int, Optional[DFSSelection], bool]:
    """
    Evaluate if element fits in budget and process nested structures.

    Args:
        elem: Element to evaluate
        remaining_budget: Available token budget
        kept_count: Number of elements already kept
        min_keep: Minimum elements to keep
        preserve_all: Whether to preserve all elements
        parser: ElementParser for nested content

    Returns:
        Tuple of (optimized_tokens, nested_selection, budget_exhausted)
        - optimized_tokens: Token count after nested optimization
        - nested_selection: DFSSelection for nested content (if any)
        - budget_exhausted: Whether budget was exhausted in nested level
    """
    elem_original_tokens = self.tokenizer.count_text_cached(elem.text)

    # Check if we can afford this element or must keep it
    can_afford = elem_original_tokens <= remaining_budget
    must_keep = kept_count < min_keep
    must_preserve = preserve_all

    # Decide whether to keep
    if not (can_afford or must_keep or must_preserve):
        # Cannot keep this element
        return 0, None, True

    # Process nested structures if present
    nested_selection = None
    elem_optimized_tokens = elem_original_tokens

    if elem.is_multiline_nested:
        # Recursively optimize nested structure
        nested_elements = parser.parse(elem.nested_content)
        nested_sel = self.select_dfs(
            nested_elements,
            remaining_budget,
            parser,
            min_keep=min_keep,
            preserve_top_level_keys=False,
        )
        nested_selection = nested_sel

        # Calculate optimized size
        elem_optimized_tokens = elem_original_tokens - nested_sel.total_tokens_removed

        # Check if budget exhausted in nested level
        if nested_sel.budget_exhausted and not preserve_all:
            return elem_optimized_tokens, nested_selection, True

    return elem_optimized_tokens, nested_selection, False
```

### Шаг 2: Упростить select_dfs через делегирование

Переписать основной метод:

```python
def select_dfs(
    self,
    elements: List[Element],
    budget: int,
    parser: ElementParser,
    min_keep: int = 1,
    tuple_size: int = 1,
    preserve_top_level_keys: bool = False,
) -> DFSSelection:
    """
    Select elements using depth-first strategy for nested structures.

    Handles both flat elements and tuple-grouped elements.
    """
    # Route to tuple handler if needed
    if tuple_size > 1:
        return self._select_dfs_tuples(
            elements, budget, parser, min_keep, tuple_size, preserve_top_level_keys
        )

    if not elements:
        return DFSSelection(
            kept_elements=[],
            removed_elements=[],
            total_count=0,
            tokens_kept=0,
            tokens_removed=0,
            remaining_budget=budget,
            budget_exhausted=False,
        )

    kept: List[Element] = []
    removed: List[Element] = []
    tokens_used = 0
    remaining_budget = budget
    budget_exhausted = False
    nested_selections: Dict[int, DFSSelection] = {}

    for i, elem in enumerate(elements):
        # Evaluate element with nested processing
        elem_tokens, nested_sel, exhausted = self._evaluate_element(
            elem, remaining_budget, len(kept), min_keep,
            preserve_top_level_keys, parser
        )

        if elem_tokens > 0:
            # Keep element
            kept.append(elem)
            tokens_used += elem_tokens
            remaining_budget -= elem_tokens

            if nested_sel:
                nested_selections[i] = nested_sel

            if exhausted:
                budget_exhausted = True
                removed.extend(elements[i + 1:])
                break
        else:
            # Budget exhausted
            budget_exhausted = True
            removed.extend(elements[i:])
            break

    # Calculate tokens removed
    tokens_removed = sum(
        self.tokenizer.count_text_cached(e.text) for e in removed
    )

    return DFSSelection(
        kept_elements=kept,
        removed_elements=removed,
        total_count=len(elements),
        tokens_kept=tokens_used,
        tokens_removed=tokens_removed,
        nested_selections=nested_selections,
        remaining_budget=remaining_budget,
        budget_exhausted=budget_exhausted,
    )
```

### Шаг 3: Упростить _select_dfs_tuples аналогично

Переписать метод для tuple-based обработки, используя `_evaluate_element`:

```python
def _select_dfs_tuples(
    self,
    elements: List[Element],
    budget: int,
    parser: ElementParser,
    min_keep: int,
    tuple_size: int,
    preserve_top_level_keys: bool = False,
) -> DFSSelection:
    """
    DFS selection with tuple grouping (for Map.of style patterns).

    Groups elements into tuples and applies DFS recursively.
    """
    if not elements:
        return DFSSelection(
            kept_elements=[],
            removed_elements=[],
            total_count=0,
            tokens_kept=0,
            tokens_removed=0,
            remaining_budget=budget,
            budget_exhausted=False,
        )

    # Group elements into tuples
    tuples = self._group_into_tuples(elements, tuple_size)

    kept: List[Element] = []
    removed: List[Element] = []
    tokens_used = 0
    remaining_budget = budget
    budget_exhausted = False
    tuples_kept = 0
    nested_selections: Dict[int, DFSSelection] = {}

    for tuple_idx, tpl in enumerate(tuples):
        # Process each element in tuple
        tuple_optimized_tokens = 0
        tuple_nested_selections = {}

        for elem_offset, elem in enumerate(tpl):
            elem_idx = tuple_idx * tuple_size + elem_offset

            # Evaluate element
            elem_tokens, nested_sel, _ = self._evaluate_element(
                elem, remaining_budget, tuples_kept, min_keep,
                preserve_top_level_keys, parser
            )

            tuple_optimized_tokens += elem_tokens

            if nested_sel:
                tuple_nested_selections[elem_idx] = nested_sel

        # Check if tuple fits in budget
        can_afford = tokens_used + tuple_optimized_tokens <= remaining_budget
        must_keep = tuples_kept < min_keep
        must_preserve = preserve_top_level_keys

        if can_afford or must_keep or must_preserve:
            kept.extend(tpl)
            tokens_used += tuple_optimized_tokens
            remaining_budget -= tuple_optimized_tokens
            tuples_kept += 1
            nested_selections.update(tuple_nested_selections)
        else:
            budget_exhausted = True
            removed.extend(tpl)

    # Calculate tokens removed
    tokens_removed = sum(
        self.tokenizer.count_text_cached(e.text) for e in removed
    )

    return DFSSelection(
        kept_elements=kept,
        removed_elements=removed,
        total_count=len(tuples),
        tokens_kept=tokens_used,
        tokens_removed=tokens_removed,
        nested_selections=nested_selections,
        remaining_budget=remaining_budget,
        budget_exhausted=budget_exhausted,
    )
```

## Критерии успешности

После рефакторинга:

1. **Устранение дублирования**:
   - Общая логика оценки элементов вынесена в `_evaluate_element`
   - Обработка nested structures централизована
   - Дублирование сокращено с ~60% до <10%

2. **Размер методов**:
   - `select_dfs`: не более 70 строк
   - `_select_dfs_tuples`: не более 60 строк
   - `_evaluate_element`: не более 40 строк

3. **Расширяемость**:
   - Легко добавить новые стратегии selection
   - Изменения в логике оценки применяются ко всем методам

## Проверка результата

1. Запустить golden tests для всех языков:
   ```bash
   ./scripts/test_adapters.sh literals all
   ```

2. Особое внимание к языкам с tuple-based patterns:
   - Java (Map.of с парами)
   - Kotlin (mapOf)
   - Scala (Map)

## Ожидаемый результат

- ✅ Все golden tests проходят без изменений
- ✅ Дублирование устранено
- ✅ Код более maintainable
- ✅ Оценка модуля повышается с 6/10 до 8/10
