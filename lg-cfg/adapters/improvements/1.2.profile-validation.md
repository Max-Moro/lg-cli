# Отсутствие валидации профилей

## Проблема

Профили создаются декларативно, но нет валидации их корректности на этапе создания дескриптора. Это приводит к ошибкам в runtime вместо fail-fast на этапе инициализации адаптера.

## Примеры потенциальных багов

### Пустой wrapper_match в FactoryProfile

```python
# Забыли указать wrapper_match для FactoryProfile
BROKEN_FACTORY = FactoryProfile(
    query="...",
    opening="(",
    closing=")",
    separator=",",
    wrapper_match="",  # ПУСТАЯ СТРОКА! Будет падать в runtime при regex match
)
```

**Последствия**: Падение при попытке использовать `wrapper_match` в `ElementParser` или компонентах.

### Несовместимые placeholder_position и profile type

```python
# INLINE placeholder для SequenceProfile
BROKEN_SEQUENCE = SequenceProfile(
    query="...",
    opening="[",
    closing="]",
    separator=",",
    placeholder_position=PlaceholderPosition.INLINE,  # INLINE только для StringProfile!
)
```

**Последствия**: Некорректное форматирование placeholder, нарушение синтаксиса в результате.

### Невалидные interpolation markers

```python
# Неправильная структура marker
BROKEN_INTERPOLATION = StringProfile(
    query="...",
    opening='"',
    closing='"',
    interpolation_markers=[
        ("$", "{", "}"),  # OK
        ("$",),           # ОШИБКА: всего 1 элемент вместо 3!
    ],
)
```

**Последствия**: `ValueError: not enough values to unpack` в `InterpolationHandler.get_active_markers()`.

## Решение: __post_init__ валидация в профилях

### Валидация для FactoryProfile

```python
# patterns.py
@dataclass
class FactoryProfile(CollectionProfile):
    """
    Profile for factory method/macro patterns.

    Describes factory calls like List.of(...), vec![...], mapOf(...).
    """

    wrapper_match: str = ""
    # ... другие поля

    def __post_init__(self):
        """Validate FactoryProfile configuration."""
        # Валидация wrapper_match (обязательное поле)
        if not self.wrapper_match or self.wrapper_match.strip() == "":
            raise ValueError(
                f"{self.__class__.__name__}: wrapper_match must be non-empty. "
                f"This is required to distinguish factory method patterns. "
                f"Got: {self.wrapper_match!r}"
            )

        # Валидация placeholder_position
        if self.placeholder_position == PlaceholderPosition.INLINE:
            raise ValueError(
                f"{self.__class__.__name__}: INLINE placeholder not supported for factory patterns. "
                f"Use END or MIDDLE_COMMENT instead. "
                f"Got: {self.placeholder_position}"
            )

        # Валидация tuple_size
        if self.tuple_size < 1:
            raise ValueError(
                f"{self.__class__.__name__}: tuple_size must be >= 1. "
                f"Got: {self.tuple_size}"
            )

        # Вызвать родительскую валидацию если есть
        if hasattr(super(), '__post_init__'):
            super().__post_init__()
```

### Валидация для StringProfile

```python
@dataclass
class StringProfile(LiteralProfile):
    """Profile for string literal patterns."""

    placeholder_position: PlaceholderPosition = PlaceholderPosition.INLINE
    preserve_whitespace: bool = False
    interpolation_markers: List[tuple] = field(default_factory=list)
    interpolation_active: Optional[Callable[[str, str], bool]] = None

    def __post_init__(self):
        """Validate StringProfile configuration."""
        # Валидация placeholder_position
        if self.placeholder_position not in (
            PlaceholderPosition.INLINE,
            PlaceholderPosition.NONE
        ):
            raise ValueError(
                f"{self.__class__.__name__}: only INLINE or NONE placeholder supported for strings. "
                f"Strings cannot have END or MIDDLE_COMMENT placeholders. "
                f"Got: {self.placeholder_position}"
            )

        # Валидация interpolation_markers
        if self.interpolation_markers:
            for i, marker in enumerate(self.interpolation_markers):
                if not isinstance(marker, tuple):
                    raise ValueError(
                        f"{self.__class__.__name__}: interpolation_markers[{i}] must be a tuple. "
                        f"Expected (prefix, opening, closing). "
                        f"Got: {type(marker).__name__} = {marker!r}"
                    )
                if len(marker) != 3:
                    raise ValueError(
                        f"{self.__class__.__name__}: interpolation_markers[{i}] must have 3 elements. "
                        f"Expected (prefix, opening, closing). "
                        f"Got {len(marker)} elements: {marker!r}"
                    )
                # Проверка что все элементы строки
                if not all(isinstance(x, str) for x in marker):
                    raise ValueError(
                        f"{self.__class__.__name__}: interpolation_markers[{i}] must contain only strings. "
                        f"Got: {marker!r}"
                    )

        # Валидация interpolation_active callback
        if self.interpolation_active is not None and not callable(self.interpolation_active):
            raise ValueError(
                f"{self.__class__.__name__}: interpolation_active must be callable or None. "
                f"Got: {type(self.interpolation_active).__name__}"
            )

        if hasattr(super(), '__post_init__'):
            super().__post_init__()
```

### Валидация для SequenceProfile

```python
@dataclass
class SequenceProfile(CollectionProfile):
    """Profile for sequence literal patterns."""

    placeholder_position: PlaceholderPosition = PlaceholderPosition.END
    placeholder_template: str = '"…"'
    requires_ast_extraction: bool = False

    def __post_init__(self):
        """Validate SequenceProfile configuration."""
        # Валидация placeholder_position
        if self.placeholder_position == PlaceholderPosition.INLINE:
            raise ValueError(
                f"{self.__class__.__name__}: INLINE placeholder not supported for sequences. "
                f"Use END or MIDDLE_COMMENT instead. "
                f"Got: {self.placeholder_position}"
            )

        # Валидация min_elements
        if self.min_elements < 0:
            raise ValueError(
                f"{self.__class__.__name__}: min_elements must be >= 0. "
                f"Got: {self.min_elements}"
            )

        if hasattr(super(), '__post_init__'):
            super().__post_init__()
```

### Валидация для MappingProfile

```python
@dataclass
class MappingProfile(CollectionProfile):
    """Profile for mapping literal patterns."""

    kv_separator: str = ":"
    placeholder_position: PlaceholderPosition = PlaceholderPosition.MIDDLE_COMMENT
    placeholder_template: str = '"…": "…"'
    preserve_all_keys: bool = False
    wrapper_match: Optional[str] = None

    def __post_init__(self):
        """Validate MappingProfile configuration."""
        # Валидация kv_separator
        if not self.kv_separator:
            raise ValueError(
                f"{self.__class__.__name__}: kv_separator must be non-empty. "
                f"Got: {self.kv_separator!r}"
            )

        # Валидация placeholder_position
        if self.placeholder_position == PlaceholderPosition.INLINE:
            raise ValueError(
                f"{self.__class__.__name__}: INLINE placeholder not supported for mappings. "
                f"Use END or MIDDLE_COMMENT instead. "
                f"Got: {self.placeholder_position}"
            )

        if hasattr(super(), '__post_init__'):
            super().__post_init__()
```

### Валидация для BlockInitProfile

```python
@dataclass
class BlockInitProfile(LiteralProfile):
    """Profile for imperative block initialization patterns."""

    block_selector: Optional[str] = None
    statement_pattern: Optional[str] = None
    placeholder_position: PlaceholderPosition = PlaceholderPosition.MIDDLE_COMMENT
    min_elements: int = 1

    def __post_init__(self):
        """Validate BlockInitProfile configuration."""
        # Валидация placeholder_position
        if self.placeholder_position not in (
            PlaceholderPosition.MIDDLE_COMMENT,
            PlaceholderPosition.NONE
        ):
            raise ValueError(
                f"{self.__class__.__name__}: only MIDDLE_COMMENT or NONE placeholder supported for block init. "
                f"INLINE and END don't make sense for statement blocks. "
                f"Got: {self.placeholder_position}"
            )

        # Валидация min_elements
        if self.min_elements < 1:
            raise ValueError(
                f"{self.__class__.__name__}: min_elements must be >= 1 for block init patterns. "
                f"At least one statement must be kept. "
                f"Got: {self.min_elements}"
            )

        # Валидация block_selector format
        if self.block_selector is not None:
            if not isinstance(self.block_selector, str) or not self.block_selector.strip():
                raise ValueError(
                    f"{self.__class__.__name__}: block_selector must be non-empty string or None. "
                    f"Expected format: 'parent_type/child_type/...'. "
                    f"Got: {self.block_selector!r}"
                )
            # Проверить что нет пустых сегментов
            segments = self.block_selector.split('/')
            if any(not seg.strip() for seg in segments):
                raise ValueError(
                    f"{self.__class__.__name__}: block_selector contains empty segments. "
                    f"Expected format: 'parent_type/child_type/...'. "
                    f"Got: {self.block_selector!r}"
                )

        if hasattr(super(), '__post_init__'):
            super().__post_init__()
```

### Базовая валидация в LiteralProfile

```python
@dataclass
class LiteralProfile:
    """Base profile class for all literal pattern types."""

    query: str
    opening: Union[str, Callable[[str], str], None] = None
    closing: Union[str, Callable[[str], str], None] = None
    placeholder_position: PlaceholderPosition = PlaceholderPosition.END
    placeholder_template: str = "…"
    inline_threshold: int = 60
    comment_name: Optional[str] = None

    def __post_init__(self):
        """Validate base profile configuration."""
        # Валидация query
        if not self.query or not self.query.strip():
            raise ValueError(
                f"{self.__class__.__name__}: query must be non-empty tree-sitter S-expression. "
                f"Got: {self.query!r}"
            )

        # Валидация inline_threshold
        if self.inline_threshold < 0:
            raise ValueError(
                f"{self.__class__.__name__}: inline_threshold must be >= 0. "
                f"Got: {self.inline_threshold}"
            )

        # Валидация placeholder_position
        if not isinstance(self.placeholder_position, PlaceholderPosition):
            raise ValueError(
                f"{self.__class__.__name__}: placeholder_position must be PlaceholderPosition enum. "
                f"Got: {type(self.placeholder_position).__name__} = {self.placeholder_position!r}"
            )
```

## Тестирование валидации

```python
# tests/adapters/test_profile_validation.py
import pytest
from lg.adapters.optimizations.literals import (
    FactoryProfile,
    StringProfile,
    SequenceProfile,
    MappingProfile,
    BlockInitProfile,
    PlaceholderPosition,
)


class TestFactoryProfileValidation:
    def test_empty_wrapper_match_raises(self):
        with pytest.raises(ValueError, match="wrapper_match must be non-empty"):
            FactoryProfile(
                query="(call) @lit",
                wrapper_match="",  # Пустая строка
                opening="(",
                closing=")",
                separator=",",
            )

    def test_inline_placeholder_raises(self):
        with pytest.raises(ValueError, match="INLINE placeholder not supported"):
            FactoryProfile(
                query="(call) @lit",
                wrapper_match="List.of",
                opening="(",
                closing=")",
                separator=",",
                placeholder_position=PlaceholderPosition.INLINE,
            )

    def test_negative_tuple_size_raises(self):
        with pytest.raises(ValueError, match="tuple_size must be >= 1"):
            FactoryProfile(
                query="(call) @lit",
                wrapper_match="List.of",
                opening="(",
                closing=")",
                separator=",",
                tuple_size=0,
            )


class TestStringProfileValidation:
    def test_end_placeholder_raises(self):
        with pytest.raises(ValueError, match="only INLINE or NONE placeholder supported"):
            StringProfile(
                query="(string) @lit",
                opening='"',
                closing='"',
                placeholder_position=PlaceholderPosition.END,
            )

    def test_invalid_interpolation_marker_type_raises(self):
        with pytest.raises(ValueError, match="must be a tuple"):
            StringProfile(
                query="(string) @lit",
                opening='"',
                closing='"',
                interpolation_markers=[
                    ("$", "{", "}"),  # OK
                    ["$", "{", "}"],  # ОШИБКА: список вместо tuple
                ],
            )

    def test_invalid_interpolation_marker_length_raises(self):
        with pytest.raises(ValueError, match="must have 3 elements"):
            StringProfile(
                query="(string) @lit",
                opening='"',
                closing='"',
                interpolation_markers=[
                    ("$", "{", "}"),  # OK
                    ("$",),           # ОШИБКА: только 1 элемент
                ],
            )

    def test_non_callable_interpolation_active_raises(self):
        with pytest.raises(ValueError, match="must be callable or None"):
            StringProfile(
                query="(string) @lit",
                opening='"',
                closing='"',
                interpolation_active="not_callable",  # ОШИБКА: строка вместо функции
            )


class TestBlockInitProfileValidation:
    def test_inline_placeholder_raises(self):
        with pytest.raises(ValueError, match="only MIDDLE_COMMENT or NONE placeholder supported"):
            BlockInitProfile(
                query="(block) @lit",
                placeholder_position=PlaceholderPosition.INLINE,
            )

    def test_zero_min_elements_raises(self):
        with pytest.raises(ValueError, match="min_elements must be >= 1"):
            BlockInitProfile(
                query="(block) @lit",
                min_elements=0,
            )

    def test_empty_block_selector_segment_raises(self):
        with pytest.raises(ValueError, match="contains empty segments"):
            BlockInitProfile(
                query="(block) @lit",
                block_selector="class_body//block",  # Двойной слэш = пустой сегмент
            )
```

## Ожидаемые выгоды

- Раннее обнаружение ошибок конфигурации (fail-fast на этапе создания адаптера)
- Понятные сообщения об ошибках вместо cryptic runtime exceptions
- Явная документация ограничений для каждого типа профиля
- Снижение риска случайных ошибок при создании дескрипторов
- Упрощение отладки при добавлении новых языков
