# Missing validation для interpolation_markers

## Проблема

В `InterpolationHandler.get_active_markers()` нет валидации структуры `interpolation_markers` из профиля. Если в дескрипторе допущена ошибка при определении markers, это приведет к runtime crash вместо понятного сообщения об ошибке.

## Примеры потенциальных багов

### Неправильная структура marker

```python
# Если в дескрипторе ошибка:
BROKEN_STRING_PROFILE = StringProfile(
    query="(string) @lit",
    opening='"',
    closing='"',
    interpolation_markers=[
        ("$", "{", "}"),  # OK - tuple из 3 элементов
        ("$",),           # ОШИБКА - tuple из 1 элемента
    ],
)

# В runtime при обработке:
def get_active_markers(self, profile: StringProfile, opening: str, content: str) -> List[Tuple[str, str, str]]:
    markers = profile.interpolation_markers
    for marker in markers:
        prefix, opening_delim, closing_delim = marker  # ValueError: not enough values to unpack!
```

### Неправильные типы элементов

```python
# Элементы markers не строки
BROKEN_STRING_PROFILE = StringProfile(
    query="(string) @lit",
    opening='"',
    closing='"',
    interpolation_markers=[
        ("$", "{", "}"),  # OK
        (123, "{", "}"),  # ОШИБКА - prefix не строка
    ],
)

# В runtime:
def find_interpolation_regions(self, content: str, markers: List[Tuple[str, str, str]]) -> List[Tuple[int, int]]:
    for prefix, opening_delim, closing_delim in markers:
        if content[i:].startswith(prefix):  # TypeError: startswith() argument must be str, not int
```

## Решение 1: Валидация в StringProfile.__post_init__

Уже частично реализовано в задаче 1.2, но нужно усилить:

```python
# patterns.py
@dataclass
class StringProfile(LiteralProfile):
    """Profile for string literal patterns."""

    placeholder_position: PlaceholderPosition = PlaceholderPosition.INLINE
    preserve_whitespace: bool = False
    interpolation_markers: List[tuple] = field(default_factory=list)
    interpolation_active: Optional[Callable[[str, str], bool]] = None

    def __post_init__(self):
        """Validate StringProfile configuration."""
        # ... (другие валидации)

        # Усиленная валидация interpolation_markers
        if self.interpolation_markers:
            for i, marker in enumerate(self.interpolation_markers):
                # Проверка типа
                if not isinstance(marker, tuple):
                    raise ValueError(
                        f"{self.__class__.__name__}: interpolation_markers[{i}] must be a tuple. "
                        f"Expected (prefix, opening, closing). "
                        f"Got: {type(marker).__name__} = {marker!r}"
                    )

                # Проверка длины
                if len(marker) != 3:
                    raise ValueError(
                        f"{self.__class__.__name__}: interpolation_markers[{i}] must have 3 elements. "
                        f"Expected (prefix, opening, closing). "
                        f"Got {len(marker)} elements: {marker!r}"
                    )

                # Проверка типов элементов
                if not all(isinstance(x, str) for x in marker):
                    non_str_types = [type(x).__name__ for x in marker if not isinstance(x, str)]
                    raise ValueError(
                        f"{self.__class__.__name__}: interpolation_markers[{i}] must contain only strings. "
                        f"Found non-string types: {non_str_types}. "
                        f"Got: {marker!r}"
                    )

                # Проверка логической корректности
                prefix, opening_delim, closing_delim = marker

                # Если есть opening, должен быть и closing (и наоборот)
                if (opening_delim and not closing_delim) or (closing_delim and not opening_delim):
                    raise ValueError(
                        f"{self.__class__.__name__}: interpolation_markers[{i}] has unbalanced delimiters. "
                        f"If opening_delim is set, closing_delim must also be set (and vice versa). "
                        f"Got: prefix={prefix!r}, opening={opening_delim!r}, closing={closing_delim!r}"
                    )

                # Prefix не может быть таким же как opening (бессмысленно)
                if prefix and prefix == opening_delim:
                    import logging
                    logging.warning(
                        f"{self.__class__.__name__}: interpolation_markers[{i}] has prefix equal to opening_delim. "
                        f"This may cause unexpected behavior. "
                        f"Got: prefix={prefix!r}, opening={opening_delim!r}"
                    )
```

## Решение 2: Defensive programming в InterpolationHandler

Добавить fallback на случай невалидных markers (defense in depth):

```python
# utils/interpolation.py
class InterpolationHandler:
    def get_active_markers(
        self,
        profile: StringProfile,
        opening: str,
        content: str,
    ) -> List[Tuple[str, str, str]]:
        """
        Determine which interpolation markers are active for this string.

        Args:
            profile: StringProfile with interpolation marker definitions
            opening: String opening delimiter
            content: String content

        Returns:
            List of active markers as (prefix, opening, closing) tuples

        Note:
            Skips invalid markers with warning instead of crashing.
        """
        markers = profile.interpolation_markers
        if not markers:
            return []

        activation_callback = profile.interpolation_active
        active_markers = []

        for i, marker in enumerate(markers):
            # Defensive validation
            if not isinstance(marker, tuple):
                import logging
                logging.warning(
                    f"Invalid interpolation marker in {profile.__class__.__name__} at index {i}: "
                    f"expected tuple, got {type(marker).__name__}. Skipping."
                )
                continue

            if len(marker) != 3:
                import logging
                logging.warning(
                    f"Invalid interpolation marker in {profile.__class__.__name__} at index {i}: "
                    f"expected 3 elements, got {len(marker)}. Skipping."
                )
                continue

            # Безопасная распаковка
            try:
                prefix, opening_delim, closing_delim = marker
            except (ValueError, TypeError) as e:
                import logging
                logging.warning(
                    f"Failed to unpack interpolation marker in {profile.__class__.__name__} at index {i}: "
                    f"{e}. Skipping."
                )
                continue

            # Проверка типов элементов
            if not all(isinstance(x, str) for x in marker):
                import logging
                logging.warning(
                    f"Invalid interpolation marker in {profile.__class__.__name__} at index {i}: "
                    f"all elements must be strings. Got: {marker!r}. Skipping."
                )
                continue

            # Marker валиден, обрабатываем
            if prefix:
                # Self-verifying marker (has prefix)
                active_markers.append(marker)
            else:
                # Empty prefix - use callback if available
                if activation_callback is not None:
                    if activation_callback(opening, content):
                        active_markers.append(marker)
                else:
                    # No callback - assume active
                    active_markers.append(marker)

        return active_markers


    def find_interpolation_regions(
        self,
        content: str,
        markers: List[Tuple[str, str, str]],
    ) -> List[Tuple[int, int]]:
        """
        Find all string interpolation regions in content.

        Args:
            content: String content to search
            markers: List of (prefix, opening, closing) tuples

        Returns:
            List of (start, end) tuples for interpolation regions
        """
        regions = []
        i = 0

        while i < len(content):
            found = False

            for marker in markers:
                # Defensive unpacking (уже проверено в get_active_markers, но на всякий случай)
                try:
                    prefix, opening_delim, closing_delim = marker
                except (ValueError, TypeError):
                    continue  # Skip invalid marker

                # Проверка типов (defensive)
                if not all(isinstance(x, str) for x in (prefix, opening_delim, closing_delim)):
                    continue  # Skip invalid marker

                # Case 1: Bracketed interpolation
                if opening_delim and closing_delim:
                    full_opener = prefix + opening_delim
                    if content[i:].startswith(full_opener):
                        brace_pos = i + len(prefix)
                        end = self._find_matching_brace(content, brace_pos)
                        if end != -1:
                            regions.append((i, end + 1))
                            i = end + 1
                            found = True
                            break

                # Case 2: Simple identifier
                elif prefix and not opening_delim:
                    if content[i:].startswith(prefix):
                        end = self._find_identifier_end(content, i + len(prefix))
                        if end > i + len(prefix):
                            regions.append((i, end))
                            i = end
                            found = True
                            break

            if not found:
                i += 1

        return regions
```

## Тестирование

```python
# tests/adapters/test_interpolation_validation.py
import pytest
from lg.adapters.optimizations.literals import StringProfile, PlaceholderPosition


class TestInterpolationMarkersValidation:
    def test_invalid_marker_type_raises(self):
        """Non-tuple marker should raise ValueError."""
        with pytest.raises(ValueError, match="must be a tuple"):
            StringProfile(
                query="(string) @lit",
                opening='"',
                closing='"',
                interpolation_markers=[
                    ("$", "{", "}"),  # OK
                    ["$", "{", "}"],  # ERROR: list instead of tuple
                ],
            )

    def test_invalid_marker_length_raises(self):
        """Marker with wrong number of elements should raise ValueError."""
        with pytest.raises(ValueError, match="must have 3 elements"):
            StringProfile(
                query="(string) @lit",
                opening='"',
                closing='"',
                interpolation_markers=[
                    ("$", "{", "}"),  # OK - 3 elements
                    ("$",),           # ERROR - 1 element
                ],
            )

    def test_non_string_elements_raise(self):
        """Marker with non-string elements should raise ValueError."""
        with pytest.raises(ValueError, match="must contain only strings"):
            StringProfile(
                query="(string) @lit",
                opening='"',
                closing='"',
                interpolation_markers=[
                    ("$", "{", "}"),  # OK
                    (123, "{", "}"),  # ERROR - prefix is int
                ],
            )

    def test_unbalanced_delimiters_raise(self):
        """Marker with unbalanced delimiters should raise ValueError."""
        with pytest.raises(ValueError, match="unbalanced delimiters"):
            StringProfile(
                query="(string) @lit",
                opening='"',
                closing='"',
                interpolation_markers=[
                    ("$", "{", ""),  # ERROR - opening without closing
                ],
            )

    def test_valid_markers_accepted(self):
        """Valid markers should be accepted without errors."""
        # Should not raise
        profile = StringProfile(
            query="(string) @lit",
            opening='"',
            closing='"',
            interpolation_markers=[
                ("$", "{", "}"),     # Bracketed
                ("$", "", ""),       # Simple identifier
                ("", "{", "}"),      # No prefix (template strings)
            ],
        )

        assert len(profile.interpolation_markers) == 3


class TestInterpolationHandlerDefensive:
    def test_skips_invalid_markers_gracefully(self):
        """Handler should skip invalid markers instead of crashing."""
        from lg.adapters.optimizations.literals.utils import InterpolationHandler

        handler = InterpolationHandler()

        # Create profile with mixed valid/invalid markers
        # (Bypassing __post_init__ validation for testing defensive code)
        profile = StringProfile.__new__(StringProfile)
        profile.query = "(string) @lit"
        profile.opening = '"'
        profile.closing = '"'
        profile.interpolation_markers = [
            ("$", "{", "}"),  # Valid
            ("$",),           # Invalid - too few elements
            (123, "{", "}"),  # Invalid - non-string
            ("#", "{", "}"),  # Valid
        ]
        profile.interpolation_active = None

        # Should not crash, should return only valid markers
        markers = handler.get_active_markers(profile, '"', "content")

        # Should have skipped invalid markers
        assert len(markers) == 2
        assert markers[0] == ("$", "{", "}")
        assert markers[1] == ("#", "{", "}")
```

## Ожидаемые выгоды

- Раннее обнаружение ошибок конфигурации (fail-fast в `__post_init__`)
- Graceful degradation вместо crash (defensive code в handler)
- Понятные сообщения об ошибках
- Упрощение отладки при создании дескрипторов
- Предотвращение runtime crashes из-за невалидных markers
