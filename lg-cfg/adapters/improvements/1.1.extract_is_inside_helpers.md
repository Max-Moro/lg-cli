# Extract `is_inside_*` Helper Functions

## Problem

Functions `_is_inside_class`, `_is_inside_function`, `_is_inside_impl` are duplicated across 9 language profiles with nearly identical logic.

## Affected Files

- `lg/adapters/langs/python/code_profiles.py`: `_is_inside_class`
- `lg/adapters/langs/typescript/code_profiles.py`: `_is_inside_class`, `_is_inside_namespace`
- `lg/adapters/langs/javascript/code_profiles.py`: `_is_inside_class`, `_is_inside_function`
- `lg/adapters/langs/kotlin/code_profiles.py`: `_is_inside_class`
- `lg/adapters/langs/java/code_profiles.py`: `_is_inside_class`, `_is_inside_method_or_constructor`
- `lg/adapters/langs/scala/code_profiles.py`: `_is_inside_class`
- `lg/adapters/langs/cpp/code_profiles.py`: `_is_inside_class_or_struct`
- `lg/adapters/langs/go/code_profiles.py`: `_is_inside_function_or_method`
- `lg/adapters/langs/rust/code_profiles.py`: `_is_inside_impl`

## Solution

Create `lg/adapters/shared/utils.py` with generic helper:

```python
"""Shared utilities for code profiles."""

from typing import Set
from lg.adapters.tree_sitter_support import Node


def is_inside_container(
    node: Node,
    container_types: Set[str],
    boundary_types: Set[str] | None = None
) -> bool:
    """
    Check if node is inside any of the specified container types.

    Args:
        node: Tree-sitter node to check
        container_types: Node types that count as "inside" (e.g., {"class_definition", "class_body"})
        boundary_types: Node types that stop the search (e.g., {"module", "program"}).
                        If None, uses {"module", "program", "source_file", "translation_unit"}

    Returns:
        True if node is inside any container type
    """
    if boundary_types is None:
        boundary_types = {"module", "program", "source_file", "translation_unit"}

    current = node.parent
    while current:
        if current.type in container_types:
            return True
        if current.type in boundary_types:
            return False
        current = current.parent
    return False
```

## Migration Pattern

Replace in each language:

```python
# Before
def _is_inside_class(node: Node) -> bool:
    current = node.parent
    while current:
        if current.type in ("class_definition", "class_body"):
            return True
        if current.type in ("module", "program"):
            return False
        current = current.parent
    return False

# After
from lg.adapters.shared.utils import is_inside_container

# In profile additional_check:
additional_check=lambda node, doc: not is_inside_container(
    node,
    container_types={"class_definition", "class_body"}
)
```

## Language-Specific Container Types

| Language | Container Types |
|----------|-----------------|
| Python | `{"class_definition"}` |
| TypeScript | `{"class_declaration", "class_body"}` |
| JavaScript | `{"class_declaration", "class_body"}` |
| Kotlin | `{"class_declaration", "class_body", "object_declaration"}` |
| Java | `{"class_declaration", "interface_declaration", "enum_declaration", "class_body", "interface_body", "enum_body"}` |
| Scala | `{"class_definition", "object_definition", "trait_definition", "template_body"}` |
| C++ | `{"class_specifier", "struct_specifier", "union_specifier"}` |
| Go | `{"function_declaration", "method_declaration", "func_literal", "block"}` |
| Rust | `{"impl_item", "declaration_list"}` |

## Export from shared/__init__.py

Add to `lg/adapters/shared/__init__.py`:

```python
from .utils import is_inside_container
```
