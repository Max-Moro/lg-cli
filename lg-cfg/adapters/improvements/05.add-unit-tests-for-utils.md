# Добавление unit tests для утилит

## Проблема

Утилитарные модули в `lg/adapters/optimizations/literals/utils/` критичны для корректной работы оптимизации литералов, но не имеют dedicated unit tests:

- `InterpolationHandler` — обрабатывает интерполяцию в f-strings, template strings, и т.д.
- `ElementParser` — парсит элементы внутри коллекций с edge cases
- `CommentPlacementAnalyzer` — анализирует синтаксис для позиционирования комментариев (после улучшения 04)

Текущее покрытие: ✅ Golden tests (интеграционное тестирование), ⚠️ Нет unit tests для edge cases.

## Целевые файлы

Создать новые тестовые файлы:
- `tests/adapters/test_interpolation_handler.py` (новый)
- `tests/adapters/test_element_parser.py` (новый)
- `tests/adapters/test_comment_placement.py` (новый, если улучшение 04 выполнено)

## План реализации

### Шаг 1: Unit tests для InterpolationHandler

Создать `tests/adapters/test_interpolation_handler.py`:

```python
"""
Unit tests for InterpolationHandler.

Tests interpolation detection, boundary adjustment, and marker handling.
"""

import pytest

from lg.adapters.optimizations.literals.utils.interpolation import InterpolationHandler
from lg.adapters.optimizations.literals.patterns import StringProfile


class TestInterpolationHandler:
    """Test suite for InterpolationHandler."""

    @pytest.fixture
    def handler(self):
        """Create InterpolationHandler instance."""
        return InterpolationHandler()

    # ===== Test: get_active_markers =====

    def test_get_active_markers_python_fstring(self, handler):
        """Python f-strings activate {} interpolation."""
        profile = StringProfile(
            query="(string) @lit",
            opening='f"',
            closing='"',
            interpolation_markers=[("", "{", "}")],
            interpolation_active=lambda opening, _: 'f' in opening.lower()
        )

        markers = handler.get_active_markers(profile, 'f"', "hello {name}")
        assert markers == [("", "{", "}")]

    def test_get_active_markers_python_regular_string(self, handler):
        """Regular Python strings don't activate {} interpolation."""
        profile = StringProfile(
            query="(string) @lit",
            opening='"',
            closing='"',
            interpolation_markers=[("", "{", "}")],
            interpolation_active=lambda opening, _: 'f' in opening.lower()
        )

        markers = handler.get_active_markers(profile, '"', "hello {name}")
        assert markers == []

    def test_get_active_markers_js_template_string(self, handler):
        """JavaScript template strings always activate ${} interpolation."""
        profile = StringProfile(
            query="(template_string) @lit",
            opening='`',
            closing='`',
            interpolation_markers=[("$", "{", "}")],
        )

        markers = handler.get_active_markers(profile, '`', "hello ${name}")
        assert markers == [("$", "{", "}")]

    def test_get_active_markers_kotlin_dollar_identifier(self, handler):
        """Kotlin strings support both ${} and $ interpolation."""
        profile = StringProfile(
            query="(string_literal) @lit",
            opening='"',
            closing='"',
            interpolation_markers=[
                ("$", "{", "}"),
                ("$", "", ""),
            ],
        )

        markers = handler.get_active_markers(profile, '"', "hello $name")
        assert len(markers) == 2

    # ===== Test: find_interpolation_regions =====

    def test_find_interpolation_regions_simple_bracketed(self, handler):
        """Find simple bracketed interpolation like ${name}."""
        content = "Hello ${name}, welcome!"
        markers = [("$", "{", "}")]

        regions = handler.find_interpolation_regions(content, markers)
        assert regions == [(6, 13)]  # ${name}

    def test_find_interpolation_regions_multiple(self, handler):
        """Find multiple interpolation regions."""
        content = "Hello ${first} ${last}"
        markers = [("$", "{", "}")]

        regions = handler.find_interpolation_regions(content, markers)
        assert regions == [(6, 14), (15, 22)]

    def test_find_interpolation_regions_nested_braces(self, handler):
        """Handle nested braces inside interpolation."""
        content = 'Hello ${obj.get("key")}'
        markers = [("$", "{", "}")]

        regions = handler.find_interpolation_regions(content, markers)
        assert regions == [(6, 23)]  # Should include entire expression

    def test_find_interpolation_regions_simple_identifier(self, handler):
        """Find simple identifier interpolation like $name."""
        content = "Hello $name, welcome $user_id"
        markers = [("$", "", "")]

        regions = handler.find_interpolation_regions(content, markers)
        assert regions == [(6, 11), (21, 29)]  # $name, $user_id

    def test_find_interpolation_regions_mixed(self, handler):
        """Find mixed bracketed and identifier interpolation."""
        content = "Hello ${first} and $last"
        markers = [("$", "{", "}"), ("$", "", "")]

        regions = handler.find_interpolation_regions(content, markers)
        # Should find both ${first} and $last
        assert len(regions) == 2

    # ===== Test: adjust_truncation =====

    def test_adjust_truncation_no_interpolation(self, handler):
        """Truncation unchanged if no interpolation."""
        original = "Hello world, this is a test"
        truncated = "Hello world"
        markers = [("$", "{", "}")]

        result = handler.adjust_truncation(truncated, original, markers)
        assert result == truncated

    def test_adjust_truncation_before_interpolation(self, handler):
        """Truncation unchanged if before interpolation."""
        original = "Hello ${name} world"
        truncated = "Hello"
        markers = [("$", "{", "}")]

        result = handler.adjust_truncation(truncated, original, markers)
        assert result == truncated

    def test_adjust_truncation_inside_interpolation(self, handler):
        """Extend truncation to complete interpolation."""
        original = "Hello ${name} world"
        truncated = "Hello $"  # Cut inside ${name}
        markers = [("$", "{", "}")]

        result = handler.adjust_truncation(truncated, original, markers)
        assert result == "Hello ${name}"  # Extended to complete interpolator

    def test_adjust_truncation_partial_identifier(self, handler):
        """Extend truncation to complete identifier."""
        original = "Hello $name world"
        truncated = "Hello $na"  # Partial identifier
        markers = [("$", "", "")]

        result = handler.adjust_truncation(truncated, original, markers)
        assert result == "Hello $name"  # Extended to complete identifier

    def test_adjust_truncation_multiple_interpolations(self, handler):
        """Handle truncation with multiple interpolation regions."""
        original = "Hello ${first} and ${last}"
        truncated = "Hello ${first} and $"  # Cut inside second interpolation
        markers = [("$", "{", "}")]

        result = handler.adjust_truncation(truncated, original, markers)
        assert result == "Hello ${first} and ${last}"

    # ===== Test: Edge cases =====

    def test_find_identifier_end_empty_string(self, handler):
        """Handle empty string after prefix."""
        end = handler._find_identifier_end("$", 1)
        assert end == 1  # No identifier

    def test_find_identifier_end_non_identifier_char(self, handler):
        """Handle non-identifier character after prefix."""
        end = handler._find_identifier_end("$123", 1)
        assert end == 1  # Starts with digit, not valid

    def test_find_identifier_end_valid(self, handler):
        """Find end of valid identifier."""
        end = handler._find_identifier_end("$name_123", 1)
        assert end == 9  # Full identifier

    def test_find_matching_brace_nested(self, handler):
        """Find matching brace with nested structures."""
        content = "{a: {b: {c: 1}}}"
        pos = handler._find_matching_brace(content, 0)
        assert pos == 15  # Final }

    def test_find_matching_brace_with_strings(self, handler):
        """Find matching brace ignoring braces in strings."""
        content = '{key: "value with } inside"}'
        pos = handler._find_matching_brace(content, 0)
        assert pos == 27  # Final }, not the one in string
```

### Шаг 2: Unit tests для ElementParser

Создать `tests/adapters/test_element_parser.py`:

```python
"""
Unit tests for ElementParser.

Tests parsing of collection elements with nested structures and edge cases.
"""

import pytest

from lg.adapters.optimizations.literals.utils.element_parser import ElementParser, ParseConfig


class TestElementParser:
    """Test suite for ElementParser."""

    # ===== Test: Simple parsing =====

    def test_parse_simple_list(self):
        """Parse simple comma-separated list."""
        config = ParseConfig(separator=",")
        parser = ElementParser(config)

        elements = parser.parse("1, 2, 3")

        assert len(elements) == 3
        assert [e.text for e in elements] == ["1", "2", "3"]

    def test_parse_empty_content(self):
        """Parse empty content."""
        config = ParseConfig(separator=",")
        parser = ElementParser(config)

        elements = parser.parse("")
        assert elements == []

    def test_parse_trailing_comma(self):
        """Parse list with trailing comma."""
        config = ParseConfig(separator=",")
        parser = ElementParser(config)

        elements = parser.parse("1, 2, 3,")

        assert len(elements) == 3

    # ===== Test: Nested structures =====

    def test_parse_nested_brackets(self):
        """Parse nested bracket structures."""
        config = ParseConfig(separator=",")
        parser = ElementParser(config)

        elements = parser.parse("[1, 2], [3, 4]")

        assert len(elements) == 2
        assert elements[0].text == "[1, 2]"
        assert elements[1].text == "[3, 4]"

    def test_parse_nested_braces(self):
        """Parse nested brace structures."""
        config = ParseConfig(separator=",")
        parser = ElementParser(config)

        elements = parser.parse('{"a": 1}, {"b": 2}')

        assert len(elements) == 2
        assert elements[0].is_nested
        assert elements[0].nested_content == '"a": 1'

    def test_parse_deeply_nested(self):
        """Parse deeply nested structures."""
        config = ParseConfig(separator=",")
        parser = ElementParser(config)

        elements = parser.parse('[[1, 2], [3, 4]], [[5, 6]]')

        assert len(elements) == 2
        assert elements[0].has_nested_structure

    # ===== Test: String handling =====

    def test_parse_strings_with_commas(self):
        """Parse strings containing separator."""
        config = ParseConfig(separator=",")
        parser = ElementParser(config)

        elements = parser.parse('"Hello, world", "Goodbye, world"')

        assert len(elements) == 2
        assert elements[0].text == '"Hello, world"'

    def test_parse_escaped_quotes(self):
        """Parse strings with escaped quotes."""
        config = ParseConfig(separator=",")
        parser = ElementParser(config)

        elements = parser.parse(r'"\"quoted\"", "normal"')

        assert len(elements) == 2

    # ===== Test: Key-value pairs =====

    def test_parse_key_value_colon(self):
        """Parse key-value pairs with colon separator."""
        config = ParseConfig(separator=",", kv_separator=":")
        parser = ElementParser(config)

        elements = parser.parse('"key1": "value1", "key2": "value2"')

        assert len(elements) == 2
        assert elements[0].is_kv_pair
        assert elements[0].key == '"key1"'
        assert elements[0].value == '"value1"'

    def test_parse_key_value_arrow(self):
        """Parse key-value pairs with arrow separator (Scala)."""
        config = ParseConfig(separator=",", kv_separator=" -> ")
        parser = ElementParser(config)

        elements = parser.parse('"key1" -> "value1", "key2" -> "value2"')

        assert len(elements) == 2
        assert elements[0].key == '"key1"'
        assert elements[0].value == '"value1"'

    def test_parse_key_value_to(self):
        """Parse key-value pairs with 'to' operator (Kotlin)."""
        config = ParseConfig(separator=",", kv_separator=" to ")
        parser = ElementParser(config)

        elements = parser.parse('"key1" to "value1", "key2" to "value2"')

        assert len(elements) == 2
        assert elements[0].is_kv_pair

    # ===== Test: Factory wrappers =====

    def test_parse_factory_wrapper(self):
        """Parse factory method calls."""
        config = ParseConfig(
            separator=",",
            factory_wrappers=["Map.entry", "List.of"]
        )
        parser = ElementParser(config)

        elements = parser.parse('Map.entry("k1", "v1"), Map.entry("k2", "v2")')

        assert len(elements) == 2
        assert elements[0].is_nested
        assert elements[0].nested_wrapper == "Map.entry"

    # ===== Test: Edge cases =====

    def test_parse_whitespace_only(self):
        """Parse whitespace-only content."""
        config = ParseConfig(separator=",")
        parser = ElementParser(config)

        elements = parser.parse("   \n  \t  ")
        assert elements == []

    def test_parse_single_element(self):
        """Parse single element without separator."""
        config = ParseConfig(separator=",")
        parser = ElementParser(config)

        elements = parser.parse("42")

        assert len(elements) == 1
        assert elements[0].text == "42"

    def test_parse_multiline_content(self):
        """Parse multiline content with indentation."""
        config = ParseConfig(separator=",")
        parser = ElementParser(config)

        content = """
        "item1",
        "item2",
        "item3"
        """

        elements = parser.parse(content)

        assert len(elements) == 3
```

### Шаг 3: Unit tests для CommentPlacementAnalyzer (опционально)

Создать `tests/adapters/test_comment_placement.py` (если улучшение 04 выполнено):

```python
"""
Unit tests for CommentPlacementAnalyzer.

Tests comment positioning and formatting in various contexts.
"""

import pytest

from lg.adapters.optimizations.literals.utils.comment_placement import CommentPlacementAnalyzer


class TestCommentPlacementAnalyzer:
    """Test suite for CommentPlacementAnalyzer."""

    @pytest.fixture
    def analyzer(self):
        """Create CommentPlacementAnalyzer instance."""
        comment_style = ("//", ("/*", "*/"))
        return CommentPlacementAnalyzer(comment_style)

    # ===== Test: Empty line =====

    def test_analyze_empty_line(self, analyzer):
        """Comment at end of line with no following code."""
        comment, offset = analyzer.analyze("", "saved 42 tokens")

        assert comment == " // saved 42 tokens"
        assert offset == 0

    # ===== Test: Semicolons =====

    def test_analyze_after_semicolon_end(self, analyzer):
        """Comment after semicolon at end of line."""
        comment, offset = analyzer.analyze(";", "saved 42 tokens")

        assert comment == " // saved 42 tokens"
        assert offset == 1  # After semicolon

    def test_analyze_after_semicolon_with_code(self, analyzer):
        """Block comment needed when code follows semicolon."""
        comment, offset = analyzer.analyze("; x = 1", "saved 42 tokens")

        assert comment == " /* saved 42 tokens */"
        assert offset == 1

    # ===== Test: Commas =====

    def test_analyze_after_comma_end(self, analyzer):
        """Comment after comma at end of element list."""
        comment, offset = analyzer.analyze(",", "saved 42 tokens")

        assert comment == " // saved 42 tokens"
        assert offset == 1

    def test_analyze_after_comma_with_elements(self, analyzer):
        """Block comment needed when more elements follow."""
        comment, offset = analyzer.analyze(", x", "saved 42 tokens")

        assert comment == " /* saved 42 tokens */"
        assert offset == 1

    def test_analyze_after_comma_before_closing(self, analyzer):
        """Single-line OK when closing bracket follows."""
        comment, offset = analyzer.analyze(", ]", "saved 42 tokens")

        assert comment == " // saved 42 tokens"
        assert offset == 1

    # ===== Test: Closing brackets =====

    def test_analyze_with_closing_brackets(self, analyzer):
        """Skip closing brackets before inserting comment."""
        comment, offset = analyzer.analyze(")", "saved 42 tokens")

        assert offset == 1  # After )

    def test_analyze_multiple_closing_brackets(self, analyzer):
        """Skip multiple closing brackets."""
        comment, offset = analyzer.analyze(")]}", "saved 42 tokens")

        assert offset == 3  # After all brackets

    def test_analyze_brackets_then_semicolon(self, analyzer):
        """Handle brackets followed by semicolon."""
        comment, offset = analyzer.analyze(");", "saved 42 tokens")

        assert offset == 2  # After );

    # ===== Test: Complex cases =====

    def test_analyze_with_following_code(self, analyzer):
        """Block comment when code follows on same line."""
        comment, offset = analyzer.analyze(" + 1", "saved 42 tokens")

        assert comment == " /* saved 42 tokens */"

    def test_analyze_method_chain(self, analyzer):
        """Block comment in method chain."""
        comment, offset = analyzer.analyze(").map(...)", "saved 42 tokens")

        assert comment == " /* saved 42 tokens */"
```

## Критерии успешности

После добавления тестов:

1. **Покрытие edge cases**:
   - Интерполяция: вложенные скобки, escape sequences, mixed markers
   - ElementParser: nested structures, strings с separators, factory wrappers
   - CommentPlacement: различные синтаксические контексты

2. **Количество тестов**:
   - `test_interpolation_handler.py`: минимум 15 тестов
   - `test_element_parser.py`: минимум 15 тестов
   - `test_comment_placement.py`: минимум 10 тестов (если применимо)

3. **Прохождение тестов**:
   - Все новые unit tests проходят
   - Golden tests продолжают проходить без изменений

## Проверка результата

1. Запустить новые unit tests:
   ```bash
   pytest tests/adapters/test_interpolation_handler.py -v
   pytest tests/adapters/test_element_parser.py -v
   pytest tests/adapters/test_comment_placement.py -v
   ```

2. Убедиться, что все unit tests проходят

3. Запустить golden tests для проверки регрессий:
   ```bash
   ./scripts/test_adapters.sh literals all
   ```

## Ожидаемый результат

- ✅ Unit tests для всех критичных утилит
- ✅ Лучшее понимание edge cases
- ✅ Защита от регрессий при рефакторинге
- ✅ Документация поведения через тесты
