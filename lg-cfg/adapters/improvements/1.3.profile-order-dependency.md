# Неявная зависимость от порядка профилей

## Проблема

Порядок профилей в `LanguageLiteralDescriptor.profiles` критичен для корректной работы, но эта зависимость неявна и не документирована. При рефакторинге легко нарушить порядок, что приведет к некорректному матчингу литералов.

## Пример проблемы

```python
# javascript/literals.py
def create_javascript_descriptor() -> LanguageLiteralDescriptor:
    return LanguageLiteralDescriptor(
        profiles=[
            JS_TEMPLATE_STRING_PROFILE,  # ДОЛЖЕН быть ПЕРВЫМ!
            JS_STRING_PROFILE,            # Иначе `` будут матчиться как обычные строки
            JS_REGEX_PROFILE,
            JS_ARRAY_PROFILE,
            JS_OBJECT_PROFILE,
        ],
    )
```

**Почему порядок важен**:
- Tree-sitter query для `JS_TEMPLATE_STRING_PROFILE`: `(template_string) @lit`
- Tree-sitter query для `JS_STRING_PROFILE`: `(string) @lit`
- Если `JS_STRING_PROFILE` идет первым, все строки (включая template strings) могут некорректно обрабатываться

**Риски**:
- При добавлении нового профиля легко вставить его в неправильное место
- Неочевидно для новых разработчиков, почему порядок важен
- Нет runtime-проверки на конфликтующие query
- При рефакторинге (например, алфавитной сортировке) легко сломать

## Решение: явная приоритезация

### Добавление поля priority в LiteralProfile

```python
# patterns.py
@dataclass
class LiteralProfile:
    """
    Base profile class for all literal pattern types.

    Profiles with lower priority value are checked first (higher priority).
    Default priority is 100. Use lower values for more specific patterns.
    """

    query: str
    opening: Union[str, Callable[[str], str], None] = None
    closing: Union[str, Callable[[str], str], None] = None
    placeholder_position: PlaceholderPosition = PlaceholderPosition.END
    placeholder_template: str = "…"
    inline_threshold: int = 60
    comment_name: Optional[str] = None

    # Priority for profile ordering (lower = higher priority, checked first)
    priority: int = 100

    # ...
```

### Автоматическая сортировка в LanguageLiteralDescriptor

```python
# descriptor.py
from typing import List
from dataclasses import dataclass, field

from .patterns import LiteralProfile


@dataclass
class LanguageLiteralDescriptor:
    """
    Declarative description of literal patterns in a language.

    Profiles are automatically sorted by priority on initialization.
    Lower priority value = higher priority (checked first).
    """

    profiles: List[LiteralProfile] = field(default_factory=list)
    nested_factory_wrappers: List[str] = field(default_factory=list)

    def __post_init__(self):
        """Validate and sort profiles by priority."""
        # Автоматическая сортировка по приоритету (меньше = выше)
        self.profiles = sorted(self.profiles, key=lambda p: (p.priority, p.__class__.__name__))

        # Опциональная валидация конфликтов (может быть добавлена позже)
        self._validate_profile_conflicts()

    def _validate_profile_conflicts(self):
        """
        Check for potentially conflicting profiles.

        Warning: This is a heuristic check, not exhaustive.
        Tree-sitter queries can overlap in complex ways.
        """
        from collections import defaultdict

        # Группировка по типу профиля
        by_type = defaultdict(list)
        for p in self.profiles:
            by_type[type(p).__name__].append(p)

        # Для каждого типа проверяем дубликаты query
        for profile_type, profiles in by_type.items():
            queries = [p.query.strip() for p in profiles]
            if len(queries) != len(set(queries)):
                # Есть дубликаты query - может быть проблема
                import logging
                logging.warning(
                    f"LanguageLiteralDescriptor: found duplicate queries in {profile_type}. "
                    f"This may cause unexpected behavior. Check priority values."
                )
```

### Использование priority в дескрипторах

```python
# javascript/literals.py
from ..optimizations.literals import (
    PlaceholderPosition,
    LanguageLiteralDescriptor,
    StringProfile,
    SequenceProfile,
    MappingProfile,
)


# String profiles with explicit priority
JS_TEMPLATE_STRING_PROFILE = StringProfile(
    query="(template_string) @lit",
    opening="`",
    closing="`",
    placeholder_position=PlaceholderPosition.INLINE,
    placeholder_template="…",
    preserve_whitespace=True,
    interpolation_markers=[("$", "{", "}")],
    priority=10,  # Высокий приоритет - проверяется первым
)

JS_STRING_PROFILE = StringProfile(
    query="(string) @lit",
    opening=_detect_string_opening,
    closing=_detect_string_closing,
    placeholder_position=PlaceholderPosition.INLINE,
    placeholder_template="…",
    priority=20,  # Ниже приоритет - проверяется после template strings
)

JS_REGEX_PROFILE = StringProfile(
    query="(regex) @lit",
    opening="/",
    closing="/",
    placeholder_position=PlaceholderPosition.INLINE,
    placeholder_template="…",
    priority=15,  # Средний приоритет
)

# Sequence profiles (default priority 100)
JS_ARRAY_PROFILE = SequenceProfile(
    query="(array) @lit",
    opening="[",
    closing="]",
    separator=",",
    placeholder_position=PlaceholderPosition.END,
    placeholder_template='"…"',
    min_elements=1,
    comment_name="array",
    # priority=100 (default)
)

# Mapping profiles (default priority 100)
JS_OBJECT_PROFILE = MappingProfile(
    query="(object) @lit",
    opening="{",
    closing="}",
    separator=",",
    kv_separator=":",
    placeholder_position=PlaceholderPosition.MIDDLE_COMMENT,
    placeholder_template='"…": "…"',
    min_elements=1,
    comment_name="object",
    # priority=100 (default)
)


def create_javascript_descriptor() -> LanguageLiteralDescriptor:
    """
    Create JavaScript language descriptor for literal optimization.

    Note: Profiles are automatically sorted by priority.
    Lower priority value = higher priority (checked first).
    """
    return LanguageLiteralDescriptor(
        profiles=[
            # Порядок здесь не важен - автосортировка по priority!
            JS_STRING_PROFILE,            # priority=20
            JS_TEMPLATE_STRING_PROFILE,   # priority=10 (будет первым после сортировки)
            JS_REGEX_PROFILE,             # priority=15
            JS_ARRAY_PROFILE,             # priority=100
            JS_OBJECT_PROFILE,            # priority=100
        ],
    )
```

### Документация priority guidelines

```python
# patterns.py - добавить в module docstring

"""
Literal optimization patterns.

Priority Guidelines:
===================

When defining profiles with overlapping tree-sitter queries,
use priority to control matching order:

- 10-30: Highly specific string patterns (template strings, raw strings)
- 40-60: Standard string literals
- 70-90: Special literals (regex, char literals)
- 100: Default priority for collections (sequences, mappings, factories)
- 110-200: Block initialization patterns (less common)

Example:
    # JavaScript template strings must be checked before regular strings
    JS_TEMPLATE_STRING = StringProfile(
        query="(template_string) @lit",
        priority=10,  # High priority
    )

    JS_STRING = StringProfile(
        query="(string) @lit",
        priority=20,  # Lower priority
    )

Within the same priority level, profiles are sorted by class name
(alphabetically) for deterministic ordering.
"""
```

## Примеры для других языков

### Python

```python
# python/literals.py
PYTHON_STRING_PROFILE = StringProfile(
    query="(string) @lit",
    opening=_detect_string_opening,
    closing=_detect_string_closing,
    placeholder_position=PlaceholderPosition.INLINE,
    placeholder_template="…",
    interpolation_markers=[("", "{", "}")],
    interpolation_active=_is_f_string,
    preserve_whitespace=False,
    priority=50,  # Standard string priority
)

# Collections - default priority 100
PYTHON_LIST_PROFILE = SequenceProfile(...)
PYTHON_TUPLE_PROFILE = SequenceProfile(...)
PYTHON_SET_PROFILE = SequenceProfile(...)
PYTHON_DICT_PROFILE = MappingProfile(...)
```

### Rust

```python
# rust/literals.py
RUST_STRING_PROFILE = StringProfile(
    query="""
    [
      (string_literal) @lit
      (raw_string_literal) @lit
    ]
    """,
    opening=_detect_raw_string_opening,
    closing=_detect_raw_string_closing,
    placeholder_position=PlaceholderPosition.INLINE,
    placeholder_template="…",
    interpolation_markers=[],
    priority=50,
)

RUST_ARRAY_PROFILE = SequenceProfile(...)  # priority=100 (default)
RUST_VEC_PROFILE = FactoryProfile(...)     # priority=100 (default)

# Block init - lower priority than collections
RUST_HASHMAP_INIT_PROFILE = BlockInitProfile(
    query="""...""",
    priority=110,  # Checked after collections
)
```

## Тестирование автосортировки

```python
# tests/adapters/test_descriptor_sorting.py
import pytest
from lg.adapters.optimizations.literals import (
    LanguageLiteralDescriptor,
    StringProfile,
    SequenceProfile,
    PlaceholderPosition,
)


def test_profiles_sorted_by_priority():
    """Profiles should be automatically sorted by priority."""
    # Создаем в обратном порядке
    profile_low = StringProfile(
        query="(string) @lit",
        opening='"',
        closing='"',
        priority=50,
    )
    profile_high = StringProfile(
        query="(template) @lit",
        opening="`",
        closing="`",
        priority=10,
    )
    profile_default = SequenceProfile(
        query="(array) @lit",
        opening="[",
        closing="]",
        separator=",",
        # priority=100 (default)
    )

    descriptor = LanguageLiteralDescriptor(
        profiles=[profile_low, profile_high, profile_default]
    )

    # Должны быть отсортированы: high (10), low (50), default (100)
    assert descriptor.profiles[0] == profile_high
    assert descriptor.profiles[1] == profile_low
    assert descriptor.profiles[2] == profile_default


def test_same_priority_sorted_by_class_name():
    """Profiles with same priority sorted alphabetically by class name."""
    mapping = MappingProfile(
        query="(object) @lit",
        opening="{",
        closing="}",
        separator=",",
        kv_separator=":",
        priority=100,
    )
    sequence = SequenceProfile(
        query="(array) @lit",
        opening="[",
        closing="]",
        separator=",",
        priority=100,
    )

    descriptor = LanguageLiteralDescriptor(
        profiles=[sequence, mapping]  # sequence last
    )

    # MappingProfile < SequenceProfile (alphabetically)
    assert descriptor.profiles[0] == mapping
    assert descriptor.profiles[1] == sequence
```

## Ожидаемые выгоды

- Явная документация важности порядка через `priority` поле
- Автоматическая сортировка предотвращает ошибки при рефакторинге
- Защита от случайного нарушения порядка
- Упрощение добавления новых профилей (просто установить подходящий priority)
- Детерминированный порядок (внутри одного priority - сортировка по имени класса)
- Возможность валидации конфликтов (опционально)
