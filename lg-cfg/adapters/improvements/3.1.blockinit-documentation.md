# Отсутствие документации для BlockInitProfile

## Проблема

`BlockInitProfile` — самый сложный паттерн для описания императивных блоков инициализации (Java double-brace, Rust HashMap let-groups). Его параметры (`block_selector`, `statement_pattern`) используют специальный синтаксис, но этот синтаксис нигде не документирован.

## Примеры неочевидного использования

```python
# java/literals.py
JAVA_DOUBLE_BRACE_PROFILE = BlockInitProfile(
    query="""
    (object_creation_expression
      (class_body
        (block))) @lit
    """,
    block_selector="class_body/block",  # ??? Что это значит?
    statement_pattern="*/method_invocation",  # ??? Синтаксис?
    placeholder_position=PlaceholderPosition.MIDDLE_COMMENT,
    min_elements=1,
    comment_name="double-brace init",
)
```

```python
# rust/literals.py
RUST_HASHMAP_INIT_PROFILE = BlockInitProfile(
    query="""
    (let_declaration
      value: (call_expression
        function: (scoped_identifier
          name: (identifier) @method_name)
        (#eq? @method_name "new"))) @lit
    """,
    block_selector=None,  # ??? Почему None?
    statement_pattern="*/call_expression",  # ??? Как это работает?
    placeholder_position=PlaceholderPosition.MIDDLE_COMMENT,
    min_elements=1,
    comment_name="hashmap init",
)
```

## Решение: comprehensive docstring

```python
# patterns.py
@dataclass
class BlockInitProfile(LiteralProfile):
    """
    Profile for imperative block initialization patterns.

    Describes imperative initialization blocks like Java double-brace
    initialization and Rust HashMap initialization chains.
    These are sequences of statements that initialize data structures.

    Parameters:
    -----------
    block_selector : Optional[str]
        Path to statements block within matched node.

        Format: "parent_type/child_type/..." (slash-separated path).

        Navigation starts from the node matched by `query` and descends
        into children following the path segments.

        - Each segment must be a valid tree-sitter node type.
        - Empty segments (e.g., "class_body//block") are invalid.
        - None means the matched node itself contains the statements.

        Examples:
            "class_body/block"
                Navigates from object_creation_expression to class_body child,
                then to its block child.

            "body"
                Navigates from function_definition to body child.

            None
                The matched node (e.g., let_declaration) itself contains statements.

    statement_pattern : Optional[str]
        Pattern to match repetitive statements for optimization.

        Format: [*/]node_type[field_name=value]

        Syntax:
            - "node_type": Match direct children with this type
            - "*/node_type": Match anywhere in subtree (recursive)
            - "node_type[field=value]": Match with specific field value

        Examples:
            "*/method_invocation"
                Matches all put(), insert(), add() calls in Java/Kotlin blocks.

            "expression_statement"
                Matches direct expression_statement children.

            "identifier[name=insert]"
                Matches identifier nodes where name field equals "insert".

        Special case:
            None: Process all statement-like children (experimental).

    placeholder_position : PlaceholderPosition
        Where to place the trimming placeholder.

        Supported values:
            - MIDDLE_COMMENT: Insert comment between kept and removed statements
                              (recommended for statement blocks)
            - NONE: Silent removal without placeholder

        Not supported:
            - INLINE: Doesn't make sense for statement blocks
            - END: Syntactically problematic for blocks

    min_elements : int
        Minimum statements to keep, even if over budget.

        Default: 1 (always keep at least one statement).

        This ensures:
            - The block is never completely empty
            - The initialization pattern remains recognizable
            - At least one example of the initialization is preserved

    Examples:
    ---------
    Java double-brace initialization:
        >>> profile = BlockInitProfile(
        ...     query='''
        ...     (object_creation_expression
        ...       (class_body
        ...         (block))) @lit
        ...     ''',
        ...     block_selector="class_body/block",
        ...     statement_pattern="*/method_invocation",
        ...     placeholder_position=PlaceholderPosition.MIDDLE_COMMENT,
        ...     min_elements=1,
        ...     comment_name="double-brace init",
        ... )

        Matches:
            new HashMap<String, String>() {{
                put("key1", "value1");
                put("key2", "value2");
                put("key3", "value3");
            }}

        Optimized to:
            new HashMap<String, String>() {{
                put("key1", "value1");
                // ... (2 more, −45 tokens)
            }}

    Rust HashMap let-group initialization:
        >>> profile = BlockInitProfile(
        ...     query='''
        ...     (let_declaration
        ...       value: (call_expression
        ...         function: (scoped_identifier
        ...           name: (identifier) @method_name)
        ...         (#eq? @method_name "new"))) @lit
        ...     ''',
        ...     block_selector=None,  # let_declaration itself is the start
        ...     statement_pattern="*/call_expression",
        ...     placeholder_position=PlaceholderPosition.MIDDLE_COMMENT,
        ...     min_elements=1,
        ...     comment_name="hashmap init",
        ... )

        Matches:
            let mut m = HashMap::new();
            m.insert("key1", "value1");
            m.insert("key2", "value2");
            m.insert("key3", "value3");

        Optimized to:
            let mut m = HashMap::new();
            m.insert("key1", "value1");
            // ... (2 more, −38 tokens)

    Notes:
    ------
    - BlockInitProfile is the most complex profile type due to:
        * AST navigation (block_selector)
        * Pattern matching (statement_pattern)
        * Statement grouping logic (composing replacement)

    - Use specialized processors (JavaDoubleBraceProcessor, RustLetGroupProcessor)
      for language-specific handling.

    - Tree-sitter query must match the outer construct (e.g., object_creation_expression,
      let_declaration), not individual statements.

    - For debugging, enable tree-sitter query visualization to verify the query
      matches the intended nodes.

    See Also:
    ---------
    - JavaDoubleBraceProcessor: Handles Java {{ ... }} initialization
    - RustLetGroupProcessor: Handles Rust let + insert() chains
    - BlockInitProcessorBase: Base class with common logic
    """

    block_selector: Optional[str] = None
    statement_pattern: Optional[str] = None
    placeholder_position: PlaceholderPosition = PlaceholderPosition.MIDDLE_COMMENT
    min_elements: int = 1

    # ... (validation in __post_init__ as per 1.2)
```

## Документация в модуле patterns.py

Добавить module-level docstring с примерами:

```python
# patterns.py

"""
Profile classes for literal optimization patterns.

This module defines base profile classes for different literal types.
Each profile describes a pattern that should be recognized and optimized
in source code.

Profile Types:
--------------
1. StringProfile: String literals
   - Regular strings: "hello"
   - Template strings: `hello ${name}`
   - Raw strings: r#"..."#

2. SequenceProfile: Sequences (lists, arrays, vectors, tuples)
   - Python lists: [1, 2, 3]
   - Rust arrays: [1, 2, 3]
   - Java arrays: {1, 2, 3}

3. MappingProfile: Mappings (dicts, maps, objects)
   - Python dicts: {"key": "value"}
   - JavaScript objects: {key: "value"}
   - Go structs: Config{Host: "localhost"}

4. FactoryProfile: Factory methods/macros
   - Java: List.of(1, 2, 3)
   - Rust: vec![1, 2, 3]
   - Kotlin: mapOf("k" to "v")

5. BlockInitProfile: Imperative block initialization
   - Java double-brace: new HashMap() {{ put(...); }}
   - Rust HashMap: let mut m = HashMap::new(); m.insert(...);

Block Selector Syntax:
----------------------
Used in BlockInitProfile to navigate AST from matched node to statements block.

Format: "parent_type/child_type/..."

Examples:
    "class_body/block"       Navigate: node → class_body → block
    "body/block_statement"   Navigate: node → body → block_statement
    None                     Matched node itself contains statements

Statement Pattern Syntax:
--------------------------
Used in BlockInitProfile to match repetitive statements.

Format: [*/]node_type[field_name=value]

Patterns:
    "method_invocation"              Direct children only
    "*/method_invocation"            Anywhere in subtree (recursive)
    "identifier[name=insert]"        Specific field value
    "*/call_expression"              All function calls in subtree

Examples:
    Java double-brace:
        statement_pattern="*/method_invocation"
        Matches: put(), add(), set() calls

    Rust let-group:
        statement_pattern="*/call_expression"
        Matches: m.insert(), v.push() calls

See individual profile docstrings for detailed examples and usage.
"""
```

## Улучшенная документация для компонентов

```python
# components/block_init.py
class BlockInitProcessorBase(LiteralProcessor):
    """
    Base class for block initialization processors.

    Handles imperative block initialization patterns where data structures
    are initialized through a sequence of statements rather than literal syntax.

    Common patterns:
        - Java double-brace initialization: new HashMap() {{ put(...); }}
        - Rust HashMap initialization: let mut m = HashMap::new(); m.insert(...);
        - Python dict updates: d = {}; d["k1"] = v1; d["k2"] = v2

    Architecture:
        1. Match outer construct via BlockInitProfile.query
        2. Navigate to statements block via BlockInitProfile.block_selector
        3. Filter statements via BlockInitProfile.statement_pattern
        4. Keep N statements within token budget, remove rest
        5. Insert placeholder comment indicating removed count

    Subclasses must implement:
        - can_handle(): Check if profile is applicable
        - process(): Process matched block initialization

    Subclasses can override:
        - _find_statements_block(): Custom navigation logic
        - _get_child_statements(): Custom statement extraction
        - _select_statements(): Custom budget-aware selection
        - _reconstruct_block(): Custom reconstruction with placeholder

    Example subclass:
        >>> class JavaDoubleBraceProcessor(BlockInitProcessorBase):
        ...     def can_handle(self, profile, node, doc):
        ...         return isinstance(profile, BlockInitProfile) and \\
        ...                node.type == "object_creation_expression"
        ...
        ...     def process(self, node, doc, source_text, profile, budget):
        ...         # Navigate: object_creation_expression → class_body → block
        ...         # Extract: expression_statement nodes
        ...         # Filter: method_invocation patterns
        ...         # Keep: First N that fit in budget
        ...         # Reconstruct: with placeholder comment
        ...         pass
    """
    # ...
```

## Ожидаемые выгоды

- Явная документация сложных параметров (`block_selector`, `statement_pattern`)
- Примеры использования для каждого языкового паттерна
- Упрощение добавления новых языков (понятно как описывать block init patterns)
- Снижение барьера входа для разработчиков
- Уменьшение вероятности ошибок при создании профилей
