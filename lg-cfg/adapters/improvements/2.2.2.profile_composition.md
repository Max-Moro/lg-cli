# Profile Composition (Alternative Approach)

## Idea

Replace inheritance via `parent_profile` with explicit composition functions.

## Current Inheritance Mechanism

```python
# In profiles.py
@dataclass
class ElementProfile:
    parent_profile: Optional[str] = None  # Name of parent for inheritance

# In descriptor.py
def _resolve_inheritance(self) -> List[ElementProfile]:
    # Walks profiles, merges parent fields into child
```

## Proposed Composition Approach

```python
# lg/adapters/shared/profile_builders.py

from typing import Callable, Optional
from .profiles import ElementProfile


def with_body(
    profile: ElementProfile,
    docstring_extractor: Optional[Callable] = None,
    body_resolver: Optional[Callable] = None,
    body_range_computer: Optional[Callable] = None,
) -> ElementProfile:
    """Add body support to a profile."""
    return ElementProfile(
        name=profile.name,
        query=profile.query,
        is_public=profile.is_public,
        additional_check=profile.additional_check,
        has_body=True,
        docstring_extractor=docstring_extractor or profile.docstring_extractor,
        body_resolver=body_resolver,
        body_range_computer=body_range_computer,
        parent_profile=None,
    )


def with_additional_check(
    profile: ElementProfile,
    check: Callable,
    combine: bool = True,
) -> ElementProfile:
    """Add or replace additional_check."""
    if combine and profile.additional_check:
        combined = lambda n, d: profile.additional_check(n, d) and check(n, d)
    else:
        combined = check

    return ElementProfile(
        name=profile.name,
        query=profile.query,
        is_public=profile.is_public,
        additional_check=combined,
        has_body=profile.has_body,
        docstring_extractor=profile.docstring_extractor,
        body_resolver=profile.body_resolver,
        body_range_computer=profile.body_range_computer,
        parent_profile=None,
    )


def rename_profile(profile: ElementProfile, new_name: str) -> ElementProfile:
    """Create copy of profile with different name."""
    return ElementProfile(
        name=new_name,
        query=profile.query,
        is_public=profile.is_public,
        additional_check=profile.additional_check,
        has_body=profile.has_body,
        docstring_extractor=profile.docstring_extractor,
        body_resolver=profile.body_resolver,
        body_range_computer=profile.body_range_computer,
        parent_profile=None,
    )


def with_query(profile: ElementProfile, query: str) -> ElementProfile:
    """Create copy of profile with different query."""
    return ElementProfile(
        name=profile.name,
        query=query,
        is_public=profile.is_public,
        additional_check=profile.additional_check,
        has_body=profile.has_body,
        docstring_extractor=profile.docstring_extractor,
        body_resolver=profile.body_resolver,
        body_range_computer=profile.body_range_computer,
        parent_profile=None,
    )
```

## Usage Example

```python
# Base profile definition
_base_function = ElementProfile(
    name="function",
    query="(function_definition) @element",
    is_public=_is_public_python,
)

# Compose variations
function_profile = with_body(
    with_additional_check(_base_function, lambda n, d: not _is_inside_class(n)),
    docstring_extractor=_find_python_docstring,
)

method_profile = with_body(
    rename_profile(
        with_additional_check(_base_function, _is_inside_class),
        "method"
    ),
    docstring_extractor=_find_python_docstring,
)
```

## Comparison

| Aspect | parent_profile | Composition |
|--------|---------------|-------------|
| Explicitness | Implicit (resolved at runtime) | Explicit (visible in code) |
| Debugging | Need to trace _resolve_inheritance | Direct function calls |
| Flexibility | Limited to parent-child | Any transformation |
| Verbosity | Less code | More code but clearer |
| Runtime cost | Resolution on first access | No runtime cost |

## Trade-offs

**Pros:**
- More explicit â€” no hidden inheritance resolution
- Easier to understand data flow
- No need for `_resolve_inheritance` in descriptor
- Can compose in any way, not just parent-child

**Cons:**
- More verbose for simple cases
- Creates new profile objects (memory, though negligible)
- Different pattern from existing code

## Recommendation

This is a **significant architectural change**. Consider only if:
1. `parent_profile` mechanism causes bugs
2. Need complex multi-level inheritance
3. Starting fresh implementation

For current codebase: `parent_profile` works fine, keep it.
