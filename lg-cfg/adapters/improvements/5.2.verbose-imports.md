# Verbose imports в language descriptors

## Проблема

Каждый языковой дескриптор дублирует длинный список imports из `lg.adapters.optimizations.literals`. Это создает визуальный шум и усложняет поддержку при добавлении новых типов профилей.

## Примеры дублирования

### Java literals.py

```python
# java/literals.py
from ..optimizations.literals import (
    PlaceholderPosition,
    LanguageLiteralDescriptor,
    StringProfile,
    SequenceProfile,
    FactoryProfile,
    BlockInitProfile,
)

# 50+ строк профилей...

def create_java_descriptor() -> LanguageLiteralDescriptor:
    return LanguageLiteralDescriptor(profiles=[...])
```

### Kotlin literals.py

```python
# kotlin/literals.py
from ..optimizations.literals import (
    PlaceholderPosition,
    LanguageLiteralDescriptor,
    StringProfile,
    MappingProfile,
    FactoryProfile,
)

# 40+ строк профилей...

def create_kotlin_descriptor() -> LanguageLiteralDescriptor:
    return LanguageLiteralDescriptor(profiles=[...])
```

### Масштаб проблемы

- 10 языков × 5-6 imports = ~60 дублированных import строк
- При добавлении нового типа профиля нужно обновлять 10 файлов
- Визуальный шум в начале каждого дескриптора

## Решение: convenience re-exports

### Создать удобный публичный API в __init__.py

```python
# optimizations/literals/__init__.py
"""
Literal Optimization.

This package provides a unified, extensible system for optimizing
literal data in source code across multiple programming languages.

Public API for language descriptor authors.
"""

# ===== Core descriptor =====
from .descriptor import LanguageLiteralDescriptor

# ===== Enums and constants =====
from .patterns import PlaceholderPosition

# ===== Profile classes =====
from .patterns import (
    StringProfile,
    SequenceProfile,
    MappingProfile,
    FactoryProfile,
    BlockInitProfile,
)

# ===== Processing pipeline (for advanced usage) =====
from .processing import LiteralPipeline

# Define public API
__all__ = [
    # Descriptor
    "LanguageLiteralDescriptor",

    # Enums
    "PlaceholderPosition",

    # Profiles
    "StringProfile",
    "SequenceProfile",
    "MappingProfile",
    "FactoryProfile",
    "BlockInitProfile",

    # Processing
    "LiteralPipeline",
]

# Module-level documentation for descriptor authors
__doc__ += """

Quick Start for Language Descriptor Authors
============================================

To create a literal descriptor for a new language:

1. Import the module:
    >>> from lg.adapters.optimizations import literals

2. Define profiles using the classes:
    >>> profile = literals.StringProfile(
    ...     query="(string) @lit",
    ...     opening='"',
    ...     closing='"',
    ...     placeholder_position=literals.PlaceholderPosition.INLINE,
    ... )

3. Create descriptor:
    >>> descriptor = literals.LanguageLiteralDescriptor(
    ...     profiles=[profile],
    ... )

See individual profile docstrings for detailed examples.
"""
```

### Обновление language descriptors

Теперь все дескрипторы используют единый namespace:

```python
# java/literals.py (после рефакторинга)
"""Java language descriptor for literal optimization."""

from __future__ import annotations

# ЕДИНЫЙ import вместо множества отдельных
from ..optimizations import literals


def _detect_string_opening(text: str) -> str:
    """Detect Java string opening delimiter (regular or text block)."""
    stripped = text.strip()
    if stripped.startswith('"""'):
        return '"""'
    return '"'


def _detect_string_closing(text: str) -> str:
    """Detect Java string closing delimiter."""
    stripped = text.strip()
    if stripped.endswith('"""'):
        return '"""'
    return '"'


# Java literal profiles

JAVA_STRING_PROFILE = literals.StringProfile(
    query="(string_literal) @lit",
    opening=_detect_string_opening,
    closing=_detect_string_closing,
    placeholder_position=literals.PlaceholderPosition.INLINE,
    placeholder_template="…",
    interpolation_markers=[],
)

JAVA_ARRAY_PROFILE = literals.SequenceProfile(
    query="(array_initializer) @lit",
    opening="{",
    closing="}",
    separator=",",
    placeholder_position=literals.PlaceholderPosition.END,
    placeholder_template='"…"',
    min_elements=1,
    comment_name="array",
)

JAVA_MAP_OF_PROFILE = literals.FactoryProfile(
    query="""
    (method_invocation
      object: (identifier) @class_name
      (#eq? @class_name "Map")
      name: (identifier) @method_name
      (#eq? @method_name "of")
      arguments: (argument_list)) @lit
    """,
    wrapper_match=r"Map\.of$",
    opening="(",
    closing=")",
    separator=",",
    placeholder_position=literals.PlaceholderPosition.MIDDLE_COMMENT,
    placeholder_template='"…", "…"',
    min_elements=1,
    comment_name="map",
    tuple_size=2,
)

# ... (другие профили)

JAVA_DOUBLE_BRACE_PROFILE = literals.BlockInitProfile(
    query="""
    (object_creation_expression
      (class_body
        (block))) @lit
    """,
    block_selector="class_body/block",
    statement_pattern="*/method_invocation",
    placeholder_position=literals.PlaceholderPosition.MIDDLE_COMMENT,
    min_elements=1,
    comment_name="double-brace init",
)


def create_java_descriptor() -> literals.LanguageLiteralDescriptor:
    """Create Java language descriptor for literal optimization."""
    return literals.LanguageLiteralDescriptor(
        profiles=[
            # String profiles
            JAVA_STRING_PROFILE,

            # Sequence profiles
            JAVA_ARRAY_PROFILE,

            # Factory profiles
            JAVA_MAP_OF_PROFILE,
            JAVA_MAP_OF_ENTRIES_PROFILE,
            JAVA_LIST_SET_OF_PROFILE,
            JAVA_ARRAYS_ASLIST_PROFILE,
            JAVA_STREAM_OF_PROFILE,

            # Block init profiles
            JAVA_DOUBLE_BRACE_PROFILE,
        ],

        nested_factory_wrappers=["Map.entry"],
    )
```

### Преимущества namespace подхода

**До**:
```python
from ..optimizations.literals import (
    PlaceholderPosition,
    LanguageLiteralDescriptor,
    StringProfile,
    SequenceProfile,
    MappingProfile,
    FactoryProfile,
    BlockInitProfile,
)

# Использование
profile = StringProfile(
    placeholder_position=PlaceholderPosition.INLINE,
)
```

**После**:
```python
from ..optimizations import literals

# Использование - явный namespace
profile = literals.StringProfile(
    placeholder_position=literals.PlaceholderPosition.INLINE,
)
```

**Выгоды**:
1. **Один import вместо многих** — визуально чище
2. **Явный namespace** — `literals.StringProfile` читается как "literal optimization string profile"
3. **Упрощение добавления профилей** — не нужно обновлять imports в 10 файлах
4. **Группировка по смыслу** — все literal-related классы под одним namespace
5. **IDE autocomplete** — `literals.` показывает все доступные классы

## Сравнение подходов

### Подход 1: Explicit imports (текущий)

```python
from ..optimizations.literals import StringProfile, SequenceProfile

profile = StringProfile(...)
```

**Плюсы**:
- Короткие имена в коде
- Традиционный Python стиль

**Минусы**:
- Длинные import блоки
- Нужно обновлять imports при добавлении профилей
- Возможны name conflicts

### Подход 2: Namespace import (рекомендуемый)

```python
from ..optimizations import literals

profile = literals.StringProfile(...)
```

**Плюсы**:
- Один import
- Явный контекст (literals.*)
- Нет name conflicts
- Упрощение maintenance

**Минусы**:
- Немного длиннее имена (но более читаемо)

### Подход 3: Hybrid (для частых классов)

```python
from ..optimizations import literals
from ..optimizations.literals import PlaceholderPosition  # Частое использование

profile = literals.StringProfile(
    placeholder_position=PlaceholderPosition.INLINE,  # Короткое имя
)
```

**Рекомендация**: Использовать **Подход 2** (namespace import) как стандарт, разрешая **Подход 3** для исключительных случаев.

## Миграция

### Шаг 1: Обновить __init__.py

Создать публичный API в `lg/adapters/optimizations/literals/__init__.py` с re-exports.

### Шаг 2: Мигрировать дескрипторы

Обновить imports в каждом дескрипторе:

```bash
# Автоматизация через sed (Linux/Mac)
find lg/adapters/*/literals.py -type f -exec sed -i 's/from \.\.optimizations\.literals import.*/from ..optimizations import literals/' {} \;

# Или вручную для каждого файла
```

### Шаг 3: Обновить использование

Заменить прямые имена на namespace:

```bash
# StringProfile -> literals.StringProfile
# PlaceholderPosition -> literals.PlaceholderPosition
# и т.д.
```

### Шаг 4: Запустить тесты

```bash
./scripts/test_adapters.sh all all
```

## Тестирование

```python
# tests/adapters/test_literals_public_api.py
"""Test public API of literals optimization module."""

import pytest


def test_literals_module_exports():
    """literals module should export all public classes."""
    from lg.adapters.optimizations import literals

    # Check main classes are accessible
    assert hasattr(literals, 'LanguageLiteralDescriptor')
    assert hasattr(literals, 'PlaceholderPosition')
    assert hasattr(literals, 'StringProfile')
    assert hasattr(literals, 'SequenceProfile')
    assert hasattr(literals, 'MappingProfile')
    assert hasattr(literals, 'FactoryProfile')
    assert hasattr(literals, 'BlockInitProfile')
    assert hasattr(literals, 'LiteralPipeline')


def test_can_create_profiles_via_namespace():
    """Should be able to create profiles using namespace."""
    from lg.adapters.optimizations import literals

    # Create profile via namespace
    profile = literals.StringProfile(
        query="(string) @lit",
        opening='"',
        closing='"',
        placeholder_position=literals.PlaceholderPosition.INLINE,
    )

    assert isinstance(profile, literals.StringProfile)
    assert profile.placeholder_position == literals.PlaceholderPosition.INLINE


def test_descriptor_creation_via_namespace():
    """Should be able to create descriptor using namespace."""
    from lg.adapters.optimizations import literals

    descriptor = literals.LanguageLiteralDescriptor(
        profiles=[
            literals.StringProfile(
                query="(string) @lit",
                opening='"',
                closing='"',
            ),
        ],
    )

    assert isinstance(descriptor, literals.LanguageLiteralDescriptor)
    assert len(descriptor.profiles) == 1
```

## Ожидаемые выгоды

- Сокращение import блоков с ~7 строк до 1 строки
- Явный контекст для всех literal-related классов
- Упрощение добавления новых типов профилей
- Снижение вероятности name conflicts
- Улучшение IDE autocomplete опыта
- Упрощение maintenance (единая точка публичного API)
