# Base Profiles Factory (Alternative Approach)

## Idea

Create factory functions for common profile patterns to reduce boilerplate in language-specific code.

## Proposed Module

`lg/adapters/shared/base_profiles.py`:

```python
"""Factory functions for common element profiles."""

from typing import Callable, Optional, Set
from .profiles import ElementProfile
from lg.adapters.tree_sitter_support import Node, TreeSitterDocument


def class_profile(
    is_public: Callable[[Node, TreeSitterDocument], bool],
    query: str = "(class_declaration) @element",
    additional_check: Optional[Callable] = None,
) -> ElementProfile:
    """Create standard class profile."""
    return ElementProfile(
        name="class",
        query=query,
        is_public=is_public,
        additional_check=additional_check,
    )


def function_profile(
    is_public: Callable[[Node, TreeSitterDocument], bool],
    query: str = "(function_definition) @element",
    additional_check: Optional[Callable] = None,
    docstring_extractor: Optional[Callable] = None,
) -> ElementProfile:
    """Create standard function profile with body support."""
    return ElementProfile(
        name="function",
        query=query,
        is_public=is_public,
        additional_check=additional_check,
        has_body=True,
        docstring_extractor=docstring_extractor,
    )


def method_profile(
    is_public: Callable[[Node, TreeSitterDocument], bool],
    query: str = "(function_definition) @element",
    is_inside_class: Callable[[Node], bool] = None,
    docstring_extractor: Optional[Callable] = None,
) -> ElementProfile:
    """Create standard method profile (function inside class)."""
    return ElementProfile(
        name="method",
        query=query,
        is_public=is_public,
        additional_check=lambda node, doc: is_inside_class(node) if is_inside_class else True,
        has_body=True,
        docstring_extractor=docstring_extractor,
    )


def field_profile(
    is_public: Callable[[Node, TreeSitterDocument], bool],
    query: str,
    additional_check: Optional[Callable] = None,
) -> ElementProfile:
    """Create standard field/member variable profile."""
    return ElementProfile(
        name="field",
        query=query,
        is_public=is_public,
        additional_check=additional_check,
    )


def interface_profile(
    is_public: Callable[[Node, TreeSitterDocument], bool],
    query: str = "(interface_declaration) @element",
) -> ElementProfile:
    """Create standard interface profile."""
    return ElementProfile(
        name="interface",
        query=query,
        is_public=is_public,
    )


def enum_profile(
    is_public: Callable[[Node, TreeSitterDocument], bool],
    query: str = "(enum_declaration) @element",
) -> ElementProfile:
    """Create standard enum profile."""
    return ElementProfile(
        name="enum",
        query=query,
        is_public=is_public,
    )
```

## Usage Example

```python
# In typescript/code_profiles.py

from lg.adapters.shared.base_profiles import (
    class_profile, function_profile, method_profile, interface_profile
)

TYPESCRIPT_CODE_DESCRIPTOR = LanguageCodeDescriptor(
    language="typescript",
    profiles=[
        class_profile(
            is_public=_is_public_top_level,
            query="(class_declaration) @element",
        ),
        interface_profile(
            is_public=_is_public_top_level,
        ),
        function_profile(
            is_public=_is_public_top_level,
            additional_check=lambda n, d: not _is_inside_class(n),
            docstring_extractor=_find_typescript_docstring,
        ),
        method_profile(
            is_public=_is_public_class_member,
            query="(method_definition) @element",
            is_inside_class=_is_inside_class,
            docstring_extractor=_find_typescript_docstring,
        ),
        # ... etc
    ],
    # ...
)
```

## Trade-offs

**Pros:**
- Less boilerplate in language profiles
- Standardizes common patterns
- Easier to add new profiles with correct defaults

**Cons:**
- Another abstraction layer
- Factory signatures may not cover all language variations
- May need many optional parameters to be flexible enough

## Recommendation

Consider implementing only if:
1. Adding 3+ new languages
2. Finding yourself copying profile definitions frequently
3. Need to enforce consistent defaults across languages

Current 10 languages are already implemented â€” retrofitting may not be worth the effort.
