# Unsafe string slicing в delimiter detection

## Проблема

Множество функций в модуле literals optimization выполняют string slicing без проверки границ. Особенно опасны операции с отрицательными индексами вида `text[:-len(closing)]`, где `closing` может быть пустой строкой.

## Примеры уязвимых мест

### В LiteralParser._extract_content()

```python
# processing/parser.py (текущая версия)
class LiteralParser:
    def _extract_content(
        self,
        text: str,
        opening: str,
        closing: str,
        wrapper: Optional[str] = None
    ) -> Optional[str]:
        """Extract content between opening and closing delimiters."""
        stripped = text.strip()

        # ... (wrapper handling)

        if not stripped.startswith(opening) or not stripped.endswith(closing):
            return None

        # ОПАСНО! Если closing == "", то -len(closing) == -0 == 0
        # stripped[len(opening):-0] вернет ПУСТУЮ СТРОКУ вместо stripped[len(opening):]
        return stripped[len(opening):-len(closing)]
```

**Проблема**: В Python `text[:-0]` эквивалентно `text[:0]`, то есть возвращает пустую строку.

**Edge case**: Некоторые профили теоретически могут иметь пустой `closing` delimiter (например, для специальных синтаксисов).

### В delimiter detection функциях

```python
# rust/literals.py
def _detect_raw_string_closing(text: str) -> str:
    stripped = text.strip()
    match = re.match(r'^(r#+)"', stripped)
    if match:
        hash_count = len(match.group(1)) - 1
        return '"' + '#' * hash_count

    return '"'

# cpp/literals.py
def _detect_cpp_string_closing(text: str) -> str:
    stripped = text.strip()
    match = re.match(r'^R"([^(]*)\(', stripped)
    if match:
        delimiter = match.group(1)
        return f'){delimiter}"'  # БЕЗОПАСНО - всегда непустой

    if stripped.endswith("'"):
        return "'"
    return '"'
```

Большинство delimiter detection функций корректны, но отсутствие явной защиты делает код хрупким.

## Решение: безопасный slicing с явными проверками

### Исправление _extract_content()

```python
# processing/parser.py (исправленная версия)
class LiteralParser:
    def _extract_content(
        self,
        text: str,
        opening: str,
        closing: str,
        wrapper: Optional[str] = None
    ) -> Optional[str]:
        """
        Extract content between opening and closing delimiters.

        Args:
            text: Full literal text
            opening: Opening delimiter
            closing: Closing delimiter (can be empty for some patterns)
            wrapper: Optional wrapper prefix to skip

        Returns:
            Content string or None if delimiters not found

        Note:
            Handles edge case where closing is empty string.
        """
        stripped = text.strip()

        # Handle wrapper prefix (e.g., "vec!" in "vec![...]", type prefixes)
        if not stripped.startswith(opening):
            # If wrapper is known, start search AFTER wrapper
            if wrapper:
                search_from = len(wrapper)
            else:
                search_from = 0

            # Find opening position
            open_pos = stripped.find(opening, search_from)
            if open_pos == -1:
                return None
            stripped = stripped[open_pos:]

        # Validate opening
        if not stripped.startswith(opening):
            return None

        # Validate closing (handle empty closing)
        if closing and not stripped.endswith(closing):
            return None

        # Safe slicing with explicit boundary calculation
        start_pos = len(opening)
        end_pos = len(stripped) - len(closing) if closing else len(stripped)

        # Validate boundaries
        if start_pos > end_pos:
            # Invalid: opening longer than content
            return None

        if start_pos == end_pos:
            # Edge case: empty content (e.g., "", [], {})
            return ""

        return stripped[start_pos:end_pos]
```

### Добавление defensive assertions

Для delimiter detection функций добавить assertions:

```python
# Пример для python/literals.py
def _detect_string_closing(text: str) -> str:
    """
    Detect Python string closing delimiter.

    Returns:
        Closing delimiter (guaranteed non-empty)
    """
    stripped = text.strip()

    # Check for triple quotes at end
    if stripped.endswith('"""'):
        return '"""'
    if stripped.endswith("'''"):
        return "'''"

    # Single quotes
    if stripped.endswith('"'):
        return '"'
    if stripped.endswith("'"):
        return "'"

    # Fallback - always non-empty
    result = '"'

    # Defensive assertion
    assert result, "Closing delimiter must be non-empty"
    return result
```

### Валидация в LiteralProfile

Добавить валидацию delimiters при создании профиля:

```python
# patterns.py
@dataclass
class LiteralProfile:
    """Base profile class for all literal pattern types."""

    query: str
    opening: Union[str, Callable[[str], str], None] = None
    closing: Union[str, Callable[[str], str], None] = None
    # ...

    def __post_init__(self):
        """Validate base profile configuration."""
        # Validate query
        if not self.query or not self.query.strip():
            raise ValueError(
                f"{self.__class__.__name__}: query must be non-empty tree-sitter S-expression. "
                f"Got: {self.query!r}"
            )

        # Validate delimiters (только для профилей с delimiters)
        # BlockInitProfile может иметь None для opening/closing
        if not isinstance(self, BlockInitProfile):
            # Для остальных профилей delimiters обязательны
            if self.opening is None:
                raise ValueError(
                    f"{self.__class__.__name__}: opening delimiter must be specified. "
                    f"Use string or callable returning string."
                )

            if self.closing is None:
                raise ValueError(
                    f"{self.__class__.__name__}: closing delimiter must be specified. "
                    f"Use string or callable returning string."
                )

            # Если delimiters статичные (строки), проверить что не пустые
            if isinstance(self.opening, str) and not self.opening:
                raise ValueError(
                    f"{self.__class__.__name__}: static opening delimiter cannot be empty. "
                    f"Got: {self.opening!r}"
                )

            if isinstance(self.closing, str) and not self.closing:
                raise ValueError(
                    f"{self.__class__.__name__}: static closing delimiter cannot be empty. "
                    f"Got: {self.closing!r}"
                )

        # ...
```

## Тестирование edge cases

```python
# tests/adapters/test_parser_edge_cases.py
import pytest
from lg.adapters.optimizations.literals.processing import LiteralParser


class TestParserEdgeCases:
    def test_extract_content_empty_closing(self):
        """Should handle empty closing delimiter gracefully."""
        parser = LiteralParser(tokenizer=Mock())

        # Simulate profile with empty closing (edge case)
        content = parser._extract_content(
            text='"hello world',  # No closing delimiter
            opening='"',
            closing='',  # Empty closing
        )

        # Should extract everything after opening
        assert content == "hello world"

    def test_extract_content_empty_content(self):
        """Should handle empty content between delimiters."""
        parser = LiteralParser(tokenizer=Mock())

        content = parser._extract_content(
            text='""',  # Empty string
            opening='"',
            closing='"',
        )

        # Should return empty string, not None
        assert content == ""

    def test_extract_content_opening_longer_than_text(self):
        """Should return None if opening is longer than text."""
        parser = LiteralParser(tokenizer=Mock())

        content = parser._extract_content(
            text='"""',  # Only 3 chars
            opening='"""',  # 3 chars
            closing='"""',  # 3 chars - nothing left for content
        )

        # Should handle gracefully
        assert content is None or content == ""

    def test_extract_content_invalid_boundaries(self):
        """Should return None for invalid delimiter positions."""
        parser = LiteralParser(tokenizer=Mock())

        # Opening longer than available space
        content = parser._extract_content(
            text='"',  # Only 1 char
            opening='"""',  # Needs 3 chars
            closing='"',
        )

        assert content is None

    def test_extract_content_unicode_delimiters(self):
        """Should handle unicode delimiters correctly."""
        parser = LiteralParser(tokenizer=Mock())

        content = parser._extract_content(
            text='«hello world»',  # Unicode quotes
            opening='«',
            closing='»',
        )

        assert content == "hello world"

    def test_extract_content_multichar_delimiters(self):
        """Should handle multi-character delimiters."""
        parser = LiteralParser(tokenizer=Mock())

        # Python triple quotes
        content = parser._extract_content(
            text='"""hello\nworld"""',
            opening='"""',
            closing='"""',
        )

        assert content == "hello\nworld"

    def test_extract_content_asymmetric_delimiters(self):
        """Should handle asymmetric opening/closing delimiters."""
        parser = LiteralParser(tokenizer=Mock())

        # Rust raw string: r#"..."#
        content = parser._extract_content(
            text='r#"hello world"#',
            opening='r#"',
            closing='"#',
            wrapper=None,
        )

        assert content == "hello world"
```

## Дополнительная защита: runtime assertions

Для критичных путей добавить runtime assertions:

```python
# processing/parser.py
def _extract_content(self, text: str, opening: str, closing: str, wrapper: Optional[str] = None) -> Optional[str]:
    """Extract content between delimiters."""
    # ...

    start_pos = len(opening)
    end_pos = len(stripped) - len(closing) if closing else len(stripped)

    # Defensive assertions
    assert start_pos >= 0, f"Invalid start_pos: {start_pos}"
    assert end_pos >= 0, f"Invalid end_pos: {end_pos}"
    assert start_pos <= len(stripped), f"start_pos {start_pos} exceeds text length {len(stripped)}"
    assert end_pos <= len(stripped), f"end_pos {end_pos} exceeds text length {len(stripped)}"

    if start_pos > end_pos:
        return None

    if start_pos == end_pos:
        return ""

    return stripped[start_pos:end_pos]
```

## Ожидаемые выгоды

- Защита от edge cases с пустыми delimiters
- Явная обработка граничных условий
- Понятные сообщения об ошибках вместо silent failures
- Предотвращение некорректного извлечения content
- Упрощение отладки через assertions
