# Дублирование логики детекции делимитеров

## Проблема

Каждый языковой дескриптор дублирует схожую логику для `_detect_string_opening()` и `_detect_string_closing()`.

## Анализ дублирования

```python
# python/literals.py
def _detect_string_opening(text: str) -> str:
    stripped = text.strip()
    prefix_match = re.match(r'^([fFrRbBuU]{0,2})', stripped)
    prefix = prefix_match.group(1) if prefix_match else ""
    rest = stripped[len(prefix):]
    if rest.startswith('"""'):
        return f'{prefix}"""'
    if rest.startswith("'''"):
        return f"{prefix}'''"
    # ...

# kotlin/literals.py
def _detect_string_opening(text: str) -> str:
    stripped = text.strip()
    if stripped.startswith('"""'):
        return '"""'
    if stripped.startswith('"'):
        return '"'
    if stripped.startswith("'"):
        return "'"
    return '"'

# scala/literals.py
def _detect_string_opening(text: str) -> str:
    stripped = text.strip()
    if stripped.startswith('s"""') or stripped.startswith('f"""') or stripped.startswith('raw"""'):
        return stripped[:4]
    if stripped.startswith('"""'):
        return '"""'
    # ...
```

**Масштаб дублирования**: 10 языков × 2 функции = 20 дублированных реализаций

**Общий паттерн**:
1. `strip()` входного текста
2. Проверка префиксов (f, r, s, raw и т.д.)
3. Проверка triple quotes (`"""`, `'''`)
4. Проверка single quotes (`"`, `'`)
5. Fallback на дефолтный delimiter

**Различия**: только в конкретных префиксах и порядке проверок

## Решение: DelimiterDetector с конфигурацией

### Новый модуль utils/delimiter_detection.py

```python
"""Universal delimiter detection for string literals."""

from __future__ import annotations

import re
from dataclasses import dataclass, field
from typing import List, Tuple, Optional


@dataclass
class DelimiterConfig:
    """Configuration for delimiter detection."""

    # String prefixes (e.g., ["f", "r", "b"] for Python)
    string_prefixes: List[str] = field(default_factory=list)

    # Triple quote styles
    triple_quote_styles: List[str] = field(default_factory=lambda: ['"""', "'''"])

    # Single quote styles
    single_quote_styles: List[str] = field(default_factory=lambda: ['"', "'"])

    # Raw string patterns: [(regex_pattern, extraction_template)]
    # For complex cases like Rust r#"..."#, C++ R"delimiter(...)delimiter"
    raw_string_patterns: List[Tuple[str, str]] = field(default_factory=list)

    # Default delimiter if detection fails
    default_delimiter: str = '"'


class DelimiterDetector:
    """Universal delimiter detector for string literals."""

    def __init__(self, config: DelimiterConfig):
        self.config = config

    def detect_opening(self, text: str) -> str:
        """
        Detect opening delimiter from string text.

        Args:
            text: Full string literal text

        Returns:
            Opening delimiter (e.g., '"', 'f"""', 'r#"')
        """
        stripped = text.strip()

        # 1. Check raw string patterns (highest priority)
        for pattern, _ in self.config.raw_string_patterns:
            match = re.match(pattern, stripped)
            if match:
                return match.group(0)

        # 2. Extract prefix if present
        prefix = ""
        if self.config.string_prefixes:
            # Build regex for all allowed prefixes
            prefix_chars = ''.join(set(''.join(self.config.string_prefixes)))
            prefix_pattern = f"^([{prefix_chars}]{{0,2}})"
            match = re.match(prefix_pattern, stripped, re.IGNORECASE)
            if match:
                prefix = match.group(1)

        rest = stripped[len(prefix):]

        # 3. Check triple quotes (before single quotes)
        for triple in self.config.triple_quote_styles:
            if rest.startswith(triple):
                return f"{prefix}{triple}"

        # 4. Check single quotes
        for single in self.config.single_quote_styles:
            if rest.startswith(single):
                return f"{prefix}{single}"

        # 5. Fallback
        return self.config.default_delimiter

    def detect_closing(self, text: str) -> str:
        """
        Detect closing delimiter from string text.

        Args:
            text: Full string literal text

        Returns:
            Closing delimiter (e.g., '"', '"""', '#"')
        """
        stripped = text.strip()

        # 1. Check raw string patterns
        for pattern, template in self.config.raw_string_patterns:
            match = re.match(pattern, stripped)
            if match:
                # Extract closing from template or pattern
                # For Rust r#"..."#: closing is #"
                # For C++ R"delimiter(...)delimiter": closing is )delimiter"
                return self._extract_closing_from_pattern(stripped, pattern)

        # 2. Check triple quotes
        for triple in self.config.triple_quote_styles:
            if stripped.endswith(triple):
                return triple

        # 3. Check single quotes
        for single in self.config.single_quote_styles:
            if stripped.endswith(single):
                return single

        # 4. Fallback
        return self.config.default_delimiter

    def _extract_closing_from_pattern(self, text: str, pattern: str) -> str:
        """
        Extract closing delimiter for raw string patterns.

        For Rust r#"..."# style: count hashes and mirror them
        For C++ R"delimiter(...)delimiter" style: extract delimiter name
        """
        # Rust-style: r#", r##", etc.
        if pattern.startswith(r'^\(r#+\)'):
            match = re.match(r'^(r#+)"', text)
            if match:
                hash_count = len(match.group(1)) - 1  # subtract 'r'
                return '"' + '#' * hash_count

        # C++-style: R"delimiter(...)delimiter"
        if pattern.startswith(r'^\R"'):
            match = re.match(r'^R"([^(]*)\(', text)
            if match:
                delimiter = match.group(1)
                return f'){delimiter}"'

        # Fallback: use default
        return self.config.default_delimiter
```

### Конфигурации для каждого языка

```python
# python/literals.py
from ..optimizations.literals.utils.delimiter_detection import (
    DelimiterConfig,
    DelimiterDetector,
)

PYTHON_DELIMITER_CONFIG = DelimiterConfig(
    string_prefixes=["f", "F", "r", "R", "b", "B", "u", "U"],
    triple_quote_styles=['"""', "'''"],
    single_quote_styles=['"', "'"],
    default_delimiter='"',
)

_python_detector = DelimiterDetector(PYTHON_DELIMITER_CONFIG)

PYTHON_STRING_PROFILE = StringProfile(
    query="(string) @lit",
    opening=_python_detector.detect_opening,
    closing=_python_detector.detect_closing,
    # ...
)
```

```python
# kotlin/literals.py
KOTLIN_DELIMITER_CONFIG = DelimiterConfig(
    string_prefixes=[],  # No prefixes in Kotlin
    triple_quote_styles=['"""'],  # Only """ for multiline
    single_quote_styles=['"', "'"],
    default_delimiter='"',
)

_kotlin_detector = DelimiterDetector(KOTLIN_DELIMITER_CONFIG)

KOTLIN_STRING_PROFILE = StringProfile(
    query="""
    [
      (string_literal) @lit
      (multiline_string_literal) @lit
    ]
    """,
    opening=_kotlin_detector.detect_opening,
    closing=_kotlin_detector.detect_closing,
    # ...
)
```

```python
# scala/literals.py
SCALA_DELIMITER_CONFIG = DelimiterConfig(
    string_prefixes=["s", "f", "raw"],  # Interpolation prefixes
    triple_quote_styles=['"""'],
    single_quote_styles=['"', "'"],
    default_delimiter='"',
)

_scala_detector = DelimiterDetector(SCALA_DELIMITER_CONFIG)

SCALA_STRING_PROFILE = StringProfile(
    query="""
    [
      (string) @lit
      (interpolated_string) @lit
      (interpolated_string_expression) @lit
    ]
    """,
    opening=_scala_detector.detect_opening,
    closing=_scala_detector.detect_closing,
    # ...
)
```

```python
# rust/literals.py
RUST_DELIMITER_CONFIG = DelimiterConfig(
    string_prefixes=[],
    triple_quote_styles=[],  # Rust has no triple quotes
    single_quote_styles=['"'],
    raw_string_patterns=[
        (r'^(r#+)"', 'raw'),  # r#"..."#, r##"..."##
    ],
    default_delimiter='"',
)

_rust_detector = DelimiterDetector(RUST_DELIMITER_CONFIG)

RUST_STRING_PROFILE = StringProfile(
    query="""
    [
      (string_literal) @lit
      (raw_string_literal) @lit
    ]
    """,
    opening=_rust_detector.detect_opening,
    closing=_rust_detector.detect_closing,
    # ...
)
```

```python
# cpp/literals.py
CPP_DELIMITER_CONFIG = DelimiterConfig(
    string_prefixes=[],
    triple_quote_styles=[],
    single_quote_styles=['"', "'"],
    raw_string_patterns=[
        (r'^R"([^(]*)\(', 'cpp_raw'),  # R"delimiter(...)delimiter"
    ],
    default_delimiter='"',
)

_cpp_detector = DelimiterDetector(CPP_DELIMITER_CONFIG)

CPP_STRING_PROFILE = StringProfile(
    query="""
    [
      (string_literal) @lit
      (char_literal) @lit
      (raw_string_literal) @lit
    ]
    """,
    opening=_cpp_detector.detect_opening,
    closing=_cpp_detector.detect_closing,
    # ...
)
```

## План миграции

1. Создать `lg/adapters/optimizations/literals/utils/delimiter_detection.py`
2. Реализовать `DelimiterConfig` и `DelimiterDetector`
3. Мигрировать языки по одному:
   - Python (эталонная реализация)
   - TypeScript/JavaScript (простые, без префиксов)
   - Kotlin/Scala (с интерполяцией)
   - Rust/C++ (raw strings)
   - Java/Go/C (простые)
4. Удалить старые `_detect_*` функции из дескрипторов
5. Запустить тесты для каждого языка после миграции

## Ожидаемые выгоды

- Устранение 20 дублированных функций
- Единое место для багфиксов delimiter detection
- Упрощение добавления новых языков (только конфигурация)
- Явная документация паттернов delimiter detection через `DelimiterConfig`
- Снижение вероятности ошибок (централизованная логика)
