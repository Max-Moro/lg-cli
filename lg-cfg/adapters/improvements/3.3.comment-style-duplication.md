# Дублирование comment style в компонентах

## Проблема

`BlockInitProcessorBase` хранит локальные копии `single_comment` и `block_comment`, хотя эта информация уже есть в `CommentFormatter`, который передается в конструктор. Это приводит к дублированию данных и нарушению принципа DRY.

## Анализ дублирования

```python
# components/block_init.py (текущая версия)
class BlockInitProcessorBase(LiteralProcessor):
    def __init__(
        self,
        tokenizer,
        all_profiles: List[LiteralProfile],
        process_literal_callback: ProcessLiteralCallback,
        comment_style: tuple[str, tuple[str, str]],  # Принимаем comment_style
    ):
        self.tokenizer = tokenizer
        self.all_profiles = all_profiles
        self.process_literal_callback = process_literal_callback

        # ДУБЛИРОВАНИЕ: распаковываем и храним локально
        self.single_comment = comment_style[0]       # ДУБЛИРУЕТСЯ с CommentFormatter!
        self.block_comment = comment_style[1]        # ДУБЛИРУЕТСЯ с CommentFormatter!

        self.source_text = None
        self.doc = None

    def _reconstruct_block(self, ...):
        # Используем локальную копию
        placeholder_comment = f"{self.single_comment} … ({removed_count} more, −{tokens_saved} tokens)"
        # ...
```

```python
# utils/comment_formatter.py
class CommentFormatter:
    """Utilities for formatting and positioning comments."""

    def __init__(self, comment_style: tuple[str, tuple[str, str]]):
        # ТА ЖЕ информация хранится здесь!
        self.single_comment = comment_style[0]
        self.block_comment = comment_style[1]

    def format_single(self, content: str) -> str:
        return f" {self.single_comment} {content}"

    def format_block(self, content: str) -> str:
        return f" {self.block_comment[0]} {content} {self.block_comment[1]}"
```

### Последствия

1. **Дублирование данных**: одна и та же информация хранится в двух местах
2. **Несогласованность**: если `comment_style` изменится (что маловероятно, но теоретически возможно), локальные копии не обновятся
3. **Излишняя зависимость**: компонент зависит от `comment_style` напрямую, хотя вся логика форматирования уже в `CommentFormatter`
4. **Нарушение DRY**: single source of truth должен быть в `CommentFormatter`

## Решение: переиспользовать CommentFormatter

### Обновление BlockInitProcessorBase

```python
# components/block_init.py (исправленная версия)
class BlockInitProcessorBase(LiteralProcessor):
    """
    Base class for block initialization processors.

    Subclasses implement specific patterns (Java double-brace, Rust let-group).
    """

    def __init__(
        self,
        tokenizer,
        all_profiles: List[LiteralProfile],
        process_literal_callback: ProcessLiteralCallback,
        comment_formatter: CommentFormatter,  # ИЗМЕНЕНО: принимаем CommentFormatter
    ):
        """
        Initialize base processor.

        Args:
            tokenizer: Token counting service
            all_profiles: List of all literal profiles for nested literal detection
            process_literal_callback: Callback for processing nested literals
            comment_formatter: Shared CommentFormatter instance
        """
        self.tokenizer = tokenizer
        self.all_profiles = all_profiles
        self.process_literal_callback = process_literal_callback
        self.comment_formatter = comment_formatter  # Сохраняем форматтер

        self.source_text = None
        self.doc = None

        # УДАЛЕНО: self.single_comment, self.block_comment

    def _reconstruct_block(
        self,
        original_node: Node,
        keep_stmts: List[Node],
        remove_stmts: List[Node],
        profile: BlockInitProfile,
        doc: TreeSitterDocument,
        base_indent: str,
        token_budget: int,
    ) -> str:
        """Reconstruct block with kept statements and placeholder."""
        # ...

        # Используем CommentFormatter напрямую
        if remove_stmts and profile.placeholder_position.value == "middle" and keep_stmts:
            removed_count = len(remove_stmts)
            tokens_saved = sum(
                self.tokenizer.count_text_cached(doc.get_node_text(s))
                for s in remove_stmts
            )

            comment_text = f"… ({removed_count} more, −{tokens_saved} tokens)"
            # ИЗМЕНЕНО: используем метод форматтера
            placeholder_comment = f"{separator}{self.comment_formatter.single_comment} {comment_text}"
            stmt_parts.append(placeholder_comment)

        # ...
```

### Обновление вызывающего кода в pipeline

```python
# processing/pipeline.py
class LiteralPipeline:
    def __init__(self, cfg: LiteralConfig, adapter):
        # ...
        comment_style: tuple[str, tuple[str, str]] = cast(
            tuple[str, tuple[str, str]], self.adapter.get_comment_style()[:2]
        )

        # Shared services
        self.comment_formatter = CommentFormatter(comment_style)

        # Processing components
        self.special_components: List[LiteralProcessor] = [
            # ...
            JavaDoubleBraceProcessor(
                self.adapter.tokenizer,
                self.descriptor.profiles,
                self._process_literal,
                self.comment_formatter,  # ИЗМЕНЕНО: передаем форматтер
            ),
            RustLetGroupProcessor(
                self.adapter.tokenizer,
                self.descriptor.profiles,
                self._process_literal,
                self.comment_formatter,  # ИЗМЕНЕНО: передаем форматтер
            ),
            # ...
        ]
```

### Обновление JavaDoubleBraceProcessor

```python
# components/java_double_brace.py
class JavaDoubleBraceProcessor(BlockInitProcessorBase):
    """Processes Java double-brace initialization patterns."""

    # КОНСТРУКТОР наследуется от BlockInitProcessorBase - изменения не нужны

    def _reconstruct_block(self, ...):
        # ...
        if remove_stmts and profile.placeholder_position.value == "middle" and keep_stmts:
            removed_count = len(remove_stmts)
            tokens_saved = sum(
                self.tokenizer.count_text_cached(doc.get_node_text(s))
                for s in remove_stmts
            )

            # Используем форматтер из базового класса
            comment_text = f"… ({removed_count} more, −{tokens_saved} tokens)"
            placeholder_comment = f"{separator}{self.comment_formatter.single_comment} {comment_text}"
            stmt_parts.append(placeholder_comment)

        # ...
```

### Обновление RustLetGroupProcessor

```python
# components/rust_let_group.py
class RustLetGroupProcessor(BlockInitProcessorBase):
    """Processes Rust let-group initialization patterns."""

    # КОНСТРУКТОР наследуется от BlockInitProcessorBase - изменения не нужны

    def _reconstruct_let_group(self, ...):
        # ...
        if remove_inserts and profile.placeholder_position.value == "middle":
            removed_count = len(remove_inserts)
            tokens_saved = sum(
                self.tokenizer.count_text_cached(doc.get_node_text(s))
                for s in remove_inserts
            )

            # Используем форматтер из базового класса
            comment_text = f"… ({removed_count} more, −{tokens_saved} tokens)"
            placeholder = f"{self.comment_formatter.single_comment} {comment_text}"
            insert_parts.append(placeholder)

        # ...
```

## Дополнительная унификация

Можно пойти дальше и унифицировать создание placeholder комментариев:

```python
# components/block_init.py
class BlockInitProcessorBase(LiteralProcessor):
    def _create_placeholder_comment(
        self,
        removed_count: int,
        tokens_saved: int,
        separator: str,
    ) -> str:
        """
        Create placeholder comment for removed statements.

        Args:
            removed_count: Number of removed statements
            tokens_saved: Tokens saved by removal
            separator: Separator to prepend (e.g., newline + indent)

        Returns:
            Formatted placeholder comment
        """
        comment_text = f"… ({removed_count} more, −{tokens_saved} tokens)"
        return f"{separator}{self.comment_formatter.single_comment} {comment_text}"


    def _reconstruct_block(self, ...):
        # ...
        if remove_stmts and profile.placeholder_position.value == "middle" and keep_stmts:
            removed_count = len(remove_stmts)
            tokens_saved = sum(
                self.tokenizer.count_text_cached(doc.get_node_text(s))
                for s in remove_stmts
            )

            # Используем унифицированный метод
            placeholder_comment = self._create_placeholder_comment(
                removed_count, tokens_saved, separator
            )
            stmt_parts.append(placeholder_comment)

        # ...
```

## Тестирование

```python
# tests/adapters/test_blockinit_comment_formatter.py
import pytest
from unittest.mock import Mock
from lg.adapters.optimizations.literals.components.block_init import BlockInitProcessorBase
from lg.adapters.optimizations.literals.utils import CommentFormatter


def test_uses_comment_formatter():
    """BlockInitProcessorBase should use CommentFormatter, not local copies."""
    comment_formatter = CommentFormatter(("//", ("/*", "*/")))

    processor = BlockInitProcessorBase(
        tokenizer=Mock(),
        all_profiles=[],
        process_literal_callback=Mock(),
        comment_formatter=comment_formatter,
    )

    # Должен хранить ссылку на форматтер
    assert processor.comment_formatter is comment_formatter

    # НЕ должен иметь локальных копий
    assert not hasattr(processor, 'single_comment')
    assert not hasattr(processor, 'block_comment')


def test_create_placeholder_comment():
    """Placeholder comment should use formatter's syntax."""
    comment_formatter = CommentFormatter(("//", ("/*", "*/")))

    processor = BlockInitProcessorBase(
        tokenizer=Mock(),
        all_profiles=[],
        process_literal_callback=Mock(),
        comment_formatter=comment_formatter,
    )

    comment = processor._create_placeholder_comment(
        removed_count=5,
        tokens_saved=120,
        separator="\n    ",
    )

    # Should use formatter's single_comment syntax
    assert comment == "\n    // … (5 more, −120 tokens)"


def test_different_comment_syntax():
    """Should work with different comment syntaxes."""
    # Python-style comments
    python_formatter = CommentFormatter(("#", ('"""', '"""')))
    processor = BlockInitProcessorBase(
        tokenizer=Mock(),
        all_profiles=[],
        process_literal_callback=Mock(),
        comment_formatter=python_formatter,
    )

    comment = processor._create_placeholder_comment(3, 50, "\n    ")
    assert comment == "\n    # … (3 more, −50 tokens)"
```

## Ожидаемые выгоды

- Устранение дублирования данных
- Единый источник truth для comment syntax (`CommentFormatter`)
- Упрощение поддержки (изменения в comment formatting в одном месте)
- Более явная архитектура (компонент использует shared сервис)
- Упрощение тестирования (можно мокировать `CommentFormatter`)
