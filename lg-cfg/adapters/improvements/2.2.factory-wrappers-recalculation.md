# Повторное вычисление factory_wrappers

## Проблема

`ElementParser.collect_factory_wrappers_from_descriptor()` вызывается в `StandardCollectionsProcessor._get_parser_for_profile()`, что происходит для каждого профиля при каждом литерале. Это приводит к повторному проходу по всем профилям дескриптора множество раз.

## Анализ текущего поведения

```python
# components/standard_collections.py (текущая версия)
class StandardCollectionsProcessor(LiteralProcessor):
    def __init__(
        self,
        tokenizer: TokenService,
        literal_parser: LiteralParser,
        selector: BudgetSelector,
        comment_formatter: CommentFormatter,
        descriptor: LanguageLiteralDescriptor,
    ):
        self.tokenizer = tokenizer
        self.parser = literal_parser
        self.selector = selector
        self.collection_formatter = CollectionFormatter(tokenizer, comment_formatter)
        self.descriptor = descriptor
        self._parsers: dict[str, ElementParser] = {}

    def _get_parser_for_profile(self, profile: CollectionProfile) -> ElementParser:
        # ...
        key = f"{separator}:{kv_separator}:{tuple_size}"

        if key not in self._parsers:
            config = ParseConfig.from_profile_and_descriptor(profile, self.descriptor)
            self._parsers[key] = ElementParser(config)

        return self._parsers[key]
```

```python
# utils/element_parser.py
class ParseConfig:
    @classmethod
    def from_profile_and_descriptor(
        cls,
        profile: CollectionProfile,
        descriptor: LanguageLiteralDescriptor
    ) -> ParseConfig:
        separator = profile.separator
        kv_separator = None

        if isinstance(profile, (MappingProfile, FactoryProfile)):
            kv_separator = profile.kv_separator

        # ПРОБЛЕМА: вызывается КАЖДЫЙ РАЗ при создании parser!
        factory_wrappers = ElementParser.collect_factory_wrappers_from_descriptor(descriptor)

        return cls(
            separator=separator,
            kv_separator=kv_separator,
            factory_wrappers=factory_wrappers,
        )


class ElementParser:
    @staticmethod
    def collect_factory_wrappers_from_descriptor(
        descriptor: LanguageLiteralDescriptor
    ) -> List[str]:
        """
        Извлечь все factory wrappers из дескриптора языка.

        ПРОБЛЕМА: проходит по ВСЕМ профилям КАЖДЫЙ РАЗ!
        """
        wrappers = []

        # Проход по всем профилям (O(n_profiles))
        for profile in descriptor.profiles:
            if isinstance(profile, FactoryProfile):
                if profile.wrapper_match:
                    # Парсинг regex...
                    # ...
```

### Сложность

- **N** = количество литералов в файле
- **P** = количество профилей в дескрипторе (~5-10 для типичного языка)
- **Текущая сложность**: O(N × P) — для каждого литерала проходим по всем профилям

**Пример**: Файл с 50 литералами, 8 профилей → 400 проходов по профилям вместо 1.

## Решение: предвычисление при инициализации

```python
# components/standard_collections.py (исправленная версия)
class StandardCollectionsProcessor(LiteralProcessor):
    """
    Processes standard collection literals with DFS optimization.

    Autonomous component that:
    - Parses collection structure
    - Applies DFS selection with budget
    - Formats result with nested handling
    """

    def __init__(
        self,
        tokenizer: TokenService,
        literal_parser: LiteralParser,
        selector: BudgetSelector,
        comment_formatter: CommentFormatter,
        descriptor: LanguageLiteralDescriptor,
        parser_factory: ElementParserFactory,
    ):
        """
        Initialize processor.

        Args:
            tokenizer: Token counting service
            literal_parser: Shared LiteralParser instance
            selector: BudgetSelector instance
            comment_formatter: Shared CommentFormatter instance
            descriptor: Language literal descriptor
            parser_factory: Shared ElementParserFactory instance
        """
        self.tokenizer = tokenizer
        self.parser = literal_parser
        self.selector = selector
        self.collection_formatter = CollectionFormatter(tokenizer, comment_formatter)
        self.descriptor = descriptor
        self.parser_factory = parser_factory

        # НОВОЕ: Предвычислить factory_wrappers ОДИН РАЗ при инициализации
        self.factory_wrappers = ElementParser.collect_factory_wrappers_from_descriptor(
            self.descriptor
        )

    def _get_parser_for_profile(self, profile: CollectionProfile) -> ElementParser:
        """
        Get parser for a profile via shared factory.

        Uses pre-computed factory_wrappers instead of recalculating
        for every profile.

        Args:
            profile: CollectionProfile to create parser for

        Returns:
            ElementParser configured for this profile
        """
        separator = profile.separator
        kv_separator = profile.kv_separator if isinstance(profile, (MappingProfile, FactoryProfile)) else None
        tuple_size = profile.tuple_size if isinstance(profile, FactoryProfile) else 1

        # Используем предвычисленное значение factory_wrappers
        return self.parser_factory.get_parser(
            separator=separator,
            kv_separator=kv_separator,
            tuple_size=tuple_size,
            factory_wrappers=self.factory_wrappers,  # Переиспользуем!
        )
```

## Альтернатива: кэширование в дескрипторе

Если предвычисление в компоненте недостаточно явно, можно кэшировать на уровне дескриптора:

```python
# descriptor.py
@dataclass
class LanguageLiteralDescriptor:
    """
    Declarative description of literal patterns in a language.

    Profiles are automatically sorted by priority on initialization.
    """

    profiles: List[LiteralProfile] = field(default_factory=list)
    nested_factory_wrappers: List[str] = field(default_factory=list)

    # Кэш для factory_wrappers (вычисляется лениво)
    _cached_factory_wrappers: Optional[List[str]] = field(default=None, init=False, repr=False)

    def get_factory_wrappers(self) -> List[str]:
        """
        Get all factory wrappers from profiles.

        Cached for performance - computed once on first access.

        Returns:
            List of factory wrapper names (e.g., ["List.of", "Map.of"])
        """
        if self._cached_factory_wrappers is None:
            # Compute once
            from .utils.element_parser import ElementParser
            self._cached_factory_wrappers = (
                ElementParser.collect_factory_wrappers_from_descriptor(self)
            )

        return self._cached_factory_wrappers
```

```python
# components/standard_collections.py (использование дескриптора)
class StandardCollectionsProcessor(LiteralProcessor):
    def __init__(
        self,
        tokenizer: TokenService,
        literal_parser: LiteralParser,
        selector: BudgetSelector,
        comment_formatter: CommentFormatter,
        descriptor: LanguageLiteralDescriptor,
        parser_factory: ElementParserFactory,
    ):
        # ...
        # Используем метод дескриптора с кэшированием
        self.factory_wrappers = descriptor.get_factory_wrappers()

    # _get_parser_for_profile остается без изменений
```

## Сравнение подходов

### Подход 1: Предвычисление в компоненте

**Плюсы**:
- Простая реализация
- Явная инициализация
- Не меняет публичный API дескриптора

**Минусы**:
- Дублирование если несколько компонентов используют factory_wrappers

### Подход 2: Кэширование в дескрипторе

**Плюсы**:
- Единственное место вычисления
- Переиспользуется всеми компонентами
- Ленивое вычисление

**Минусы**:
- Немного сложнее (нужен `_cached_factory_wrappers` field)
- Изменяет внутреннюю структуру дескриптора

**Рекомендация**: Использовать **Подход 1** (предвычисление в компоненте) как более простое и прямое решение.

## Тестирование

```python
# tests/adapters/test_factory_wrappers_performance.py
import pytest
from unittest.mock import Mock, patch
from lg.adapters.optimizations.literals import LanguageLiteralDescriptor
from lg.adapters.optimizations.literals.components import StandardCollectionsProcessor
from lg.adapters.optimizations.literals.utils import ElementParser


def test_factory_wrappers_computed_once():
    """Factory wrappers should be computed once during init."""
    descriptor = LanguageLiteralDescriptor(profiles=[...])

    # Mock для отслеживания вызовов
    with patch.object(
        ElementParser,
        'collect_factory_wrappers_from_descriptor',
        wraps=ElementParser.collect_factory_wrappers_from_descriptor
    ) as mock_collect:
        # Создаем компонент
        processor = StandardCollectionsProcessor(
            tokenizer=Mock(),
            literal_parser=Mock(),
            selector=Mock(),
            comment_formatter=Mock(),
            descriptor=descriptor,
            parser_factory=Mock(),
        )

        # Должен быть вызван ОДИН РАЗ в __init__
        assert mock_collect.call_count == 1

        # Вызываем _get_parser_for_profile несколько раз
        mock_profile = Mock(separator=",", kv_separator=":", tuple_size=1)
        processor._get_parser_for_profile(mock_profile)
        processor._get_parser_for_profile(mock_profile)
        processor._get_parser_for_profile(mock_profile)

        # НЕ должен вызываться повторно
        assert mock_collect.call_count == 1  # Все еще 1!


def test_factory_wrappers_reused_across_parsers():
    """Same factory_wrappers list should be used for all parsers."""
    descriptor = LanguageLiteralDescriptor(profiles=[...])

    processor = StandardCollectionsProcessor(
        tokenizer=Mock(),
        literal_parser=Mock(),
        selector=Mock(),
        comment_formatter=Mock(),
        descriptor=descriptor,
        parser_factory=Mock(),
    )

    # Сохраняем ссылку на factory_wrappers
    original_wrappers = processor.factory_wrappers

    # Получаем парсеры для разных профилей
    mock_profile1 = Mock(separator=",", kv_separator=":", tuple_size=1)
    mock_profile2 = Mock(separator=";", kv_separator=" -> ", tuple_size=2)

    with patch.object(processor.parser_factory, 'get_parser') as mock_get:
        processor._get_parser_for_profile(mock_profile1)
        processor._get_parser_for_profile(mock_profile2)

        # Проверяем что factory_wrappers передается одинаковый
        assert mock_get.call_count == 2
        for call in mock_get.call_args_list:
            kwargs = call[1]
            assert kwargs['factory_wrappers'] is original_wrappers  # Same object!
```

## Ожидаемые выгоды

- Снижение вычислительных затрат с O(N × P) до O(1) для factory_wrappers extraction
- Ускорение обработки файлов с множеством литералов
- Более явная архитектура (предвычисление при инициализации)
- Упрощение профилирования (нет множественных вызовов extract)
