# Inconsistent naming: _get_ vs _create_

## Проблема

Методы с префиксом `_get_` используются непоследовательно: иногда они извлекают данные из кэша или существующих структур, иногда создают новые объекты. Это создает путаницу при чтении кода и нарушает ожидания от naming conventions.

## Примеры несогласованности

### StandardCollectionsProcessor._get_parser_for_profile()

```python
# components/standard_collections.py
class StandardCollectionsProcessor(LiteralProcessor):
    def _get_parser_for_profile(self, profile: CollectionProfile) -> ElementParser:
        """Get or create parser for a profile."""
        # ...
        key = f"{separator}:{kv_separator}:{tuple_size}"

        if key not in self._parsers:
            # СОЗДАЕТ новый parser!
            config = ParseConfig.from_profile_and_descriptor(profile, self.descriptor)
            self._parsers[key] = ElementParser(config)

        return self._parsers[key]
```

**Проблема**: Название `_get_parser_for_profile` подразумевает простое извлечение, но метод также СОЗДАЕТ parser при отсутствии в кэше.

### ElementParser._create_element()

```python
# utils/element_parser.py
class ElementParser:
    def _create_element(
        self,
        text: str,
        raw_text: str,
        start: int,
        end: int
    ) -> Element:
        """Create an Element, detecting key-value pairs and nested structures."""
        # Всегда создает новый Element
        # ...
        return Element(...)
```

**Правильно**: Название `_create_element` точно отражает поведение — всегда создается новый объект.

### LiteralParser.parse_from_node()

```python
# processing/parser.py
class LiteralParser:
    def parse_from_node(
        self,
        node,
        doc,
        source_text: str,
        profile: P
    ) -> Optional[ParsedLiteral[P]]:
        """
        High-level API: parse literal with automatic parameter detection.
        """
        # СОЗДАЕТ ParsedLiteral, но название _parse_ корректно
```

**Правильно**: Название `parse_from_node` подразумевает создание структуры данных из node.

## Рекомендуемые naming conventions

### _get_* — извлечение без создания

Методы с префиксом `_get_` должны ТОЛЬКО извлекать данные из существующих структур:

```python
# Хорошо
def _get_node_text(self, node: Node) -> str:
    """Get text content of node."""
    return self.doc.get_node_text(node)

def _get_cached_value(self, key: str) -> Optional[Value]:
    """Get value from cache, or None if not found."""
    return self._cache.get(key)

def _get_profile_type(self, profile: LiteralProfile) -> str:
    """Get type name of profile."""
    return type(profile).__name__
```

### _create_* — создание нового объекта

Методы с префиксом `_create_` должны всегда создавать новый объект:

```python
# Хорошо
def _create_element(self, text: str, ...) -> Element:
    """Create new Element from text."""
    return Element(...)

def _create_placeholder(self, count: int) -> str:
    """Create placeholder comment."""
    return f"... ({count} more)"

def _create_parser(self, config: ParseConfig) -> ElementParser:
    """Create new ElementParser from config."""
    return ElementParser(config)
```

### _parse_* — парсинг и создание структуры

Методы с префиксом `_parse_` подразумевают парсинг входных данных и создание структуры:

```python
# Хорошо
def parse_from_node(self, node, ...) -> ParsedLiteral:
    """Parse literal from tree-sitter node."""
    # Парсит node и создает ParsedLiteral
    return ParsedLiteral(...)

def _parse_elements(self, content: str) -> List[Element]:
    """Parse content into list of elements."""
    # Парсит content и создает список Element
    return [...]
```

### _get_or_create_* — кэширование с ленивым созданием

Методы, которые извлекают из кэша ИЛИ создают при отсутствии:

```python
# Хорошо - явное название
def _get_or_create_parser(self, profile: CollectionProfile) -> ElementParser:
    """Get cached parser or create new one."""
    key = self._make_cache_key(profile)

    if key not in self._parsers:
        self._parsers[key] = self._create_parser_from_profile(profile)

    return self._parsers[key]

# Плохо - неявное поведение
def _get_parser(self, profile: CollectionProfile) -> ElementParser:
    """Get parser for profile."""  # Неясно, создается ли новый?
    # ...
```

## Исправления в коде

### StandardCollectionsProcessor

```python
# components/standard_collections.py (исправленная версия)
class StandardCollectionsProcessor(LiteralProcessor):
    # БЫЛО
    # def _get_parser_for_profile(self, profile: CollectionProfile) -> ElementParser:

    # СТАЛО - явное название
    def _get_or_create_parser(self, profile: CollectionProfile) -> ElementParser:
        """
        Get cached parser or create new one for profile.

        Uses shared ElementParserFactory to get cached parser,
        avoiding redundant creation.

        Args:
            profile: CollectionProfile to get parser for

        Returns:
            ElementParser configured for this profile
        """
        separator = profile.separator
        kv_separator = profile.kv_separator if isinstance(profile, (MappingProfile, FactoryProfile)) else None
        tuple_size = profile.tuple_size if isinstance(profile, FactoryProfile) else 1

        # Используем фабрику (после задачи 2.1)
        return self.parser_factory.get_parser(
            separator=separator,
            kv_separator=kv_separator,
            tuple_size=tuple_size,
            factory_wrappers=self.factory_wrappers,
        )

    def process(self, node, doc, source_text: str, profile: CollectionProfile, token_budget: int) -> Optional[TrimResult]:
        # ...
        # Обновить вызов
        parser = self._get_or_create_parser(profile)
        # ...
```

### BlockInitProcessorBase

```python
# components/block_init.py (исправленная версия)
class BlockInitProcessorBase(LiteralProcessor):
    # БЫЛО
    # def _get_all_literal_nodes(self, doc: TreeSitterDocument) -> set:

    # СТАЛО - более точное название
    def _get_or_compute_literal_nodes(self, doc: TreeSitterDocument) -> set:
        """
        Get cached literal nodes or compute from document.

        Caches results per document to avoid repeated tree-sitter queries.

        Args:
            doc: Tree-sitter document

        Returns:
            Set of (start_byte, end_byte) tuples for all literal nodes
        """
        doc_id = id(doc)

        if self._literal_nodes_cache is None:
            self._literal_nodes_cache = {}

        if doc_id not in self._literal_nodes_cache:
            literal_coords = set()

            # Compute literal nodes
            for profile in self.all_profiles:
                try:
                    nodes = doc.query_nodes(profile.query, "lit")
                    literal_coords.update(
                        (n.start_byte, n.end_byte) for n in nodes
                    )
                except:
                    continue

            self._literal_nodes_cache[doc_id] = literal_coords

        return self._literal_nodes_cache[doc_id]

    # Добавить вспомогательный метод для ЧИСТОГО извлечения
    def _get_profile_type_for_node(self, node: Node, doc: TreeSitterDocument) -> str:
        """
        Get profile type name for literal node.

        Determines which profile matched this node by querying profiles.

        Args:
            node: Literal node
            doc: Tree-sitter document

        Returns:
            Profile type name (e.g., "StringProfile", "SequenceProfile")
        """
        for profile in self.all_profiles:
            try:
                nodes = doc.query_nodes(profile.query, "lit")
                if node in nodes:
                    return type(profile).__name__
            except:
                continue

        return "UnknownProfile"
```

### ElementParser

```python
# utils/element_parser.py (исправленная версия)
class ElementParser:
    def parse(self, content: str) -> List[Element]:
        """
        Parse content into list of elements.

        Args:
            content: Content string (without opening/closing delimiters)

        Returns:
            List of parsed elements
        """
        # ...
        # Вызывает _create_element для каждого элемента
        elements.append(self._create_element(element_text, raw_text, current_start, i))
        # ...

    def _create_element(
        self,
        text: str,
        raw_text: str,
        start: int,
        end: int
    ) -> Element:
        """
        Create Element from parsed text.

        Detects key-value pairs and nested structures.

        Args:
            text: Element text (trimmed)
            raw_text: Element text (with whitespace)
            start: Start offset in content
            end: End offset in content

        Returns:
            Newly created Element
        """
        # ... (создает и возвращает Element)
```

## Дополнительные рекомендации

### Избегать ambiguous названий

```python
# Плохо - неясно что делает
def _process_node(self, node): pass
def _handle_element(self, elem): pass
def _make_result(self, data): pass

# Хорошо - конкретное действие
def _extract_node_text(self, node): pass
def _format_element(self, elem): pass
def _create_result_from_data(self, data): pass
```

### Использовать consistent prefixes

- `_get_*` — извлечение
- `_create_*` — создание
- `_parse_*` — парсинг
- `_format_*` — форматирование
- `_compute_*` — вычисление
- `_build_*` — построение сложных структур
- `_find_*` — поиск
- `_extract_*` — извлечение из сложной структуры

## Checklist для review

При создании нового метода:

1. **Метод извлекает данные?** → `_get_*`
2. **Метод создает новый объект?** → `_create_*`
3. **Метод парсит данные?** → `_parse_*`
4. **Метод кэширует с ленивым созданием?** → `_get_or_create_*`
5. **Метод вычисляет значение?** → `_compute_*` или `_calculate_*`
6. **Метод форматирует данные?** → `_format_*`

## Ожидаемые выгоды

- Более понятный код (self-documenting names)
- Ясные ожидания от методов
- Упрощение code review
- Снижение cognitive load при чтении кода
- Соответствие общепринятым naming conventions
