# Extract Body Range Computation Logic

## Problem

Method `_compute_body_range` in `ElementCollector` is ~50 lines with multiple responsibilities:
1. Get inner content range (exclude braces)
2. Handle leading comments as siblings
3. Adjust for docstring
4. Handle line-based vs brace-based languages

This violates SRP — collector should collect, not compute complex ranges.

## Target File

`lg/adapters/shared/collector.py`

## Solution

Create `lg/adapters/shared/body_range.py`:

```python
"""Body range computation for function/method elements."""

from typing import Optional, Set, Tuple

from lg.adapters.tree_sitter_support import Node, TreeSitterDocument


class BodyRangeComputer:
    """Computes strippable range for function bodies."""

    def __init__(self, doc: TreeSitterDocument, comment_types: Set[str]):
        self.doc = doc
        self.comment_types = comment_types

    def compute(
        self,
        func_def: Node,
        body_node: Node,
        docstring_extractor=None,
        body_range_computer=None,
    ) -> Tuple[int, int]:
        """
        Compute strippable byte range for function body.

        Args:
            func_def: Function definition node
            body_node: Body node (block, statement_block, etc.)
            docstring_extractor: Optional callback to find docstring
            body_range_computer: Optional custom range computer from profile

        Returns:
            Tuple of (start_byte, end_byte) for strippable content
        """
        # Custom computer takes precedence
        if body_range_computer:
            return body_range_computer(func_def, self.doc)

        # Standard computation
        start_byte, end_byte = self._compute_inner_range(body_node)
        is_brace_based = (start_byte != body_node.start_byte)

        # Check for leading sibling comments
        sibling_comment_start = self._find_leading_sibling_comments(func_def, body_node)
        if sibling_comment_start is not None:
            start_byte = min(start_byte, sibling_comment_start)

        # Adjust for docstring
        if docstring_extractor:
            docstring = docstring_extractor(body_node, self.doc)
            if docstring:
                start_byte = self._find_next_content_byte(docstring.end_byte)

        # Adjust to line start for non-brace languages
        if not is_brace_based:
            func_line = func_def.start_point[0]
            body_line = body_node.start_point[0]
            if body_line > func_line:
                start_byte = self._find_line_start(start_byte)

        return (start_byte, end_byte)

    def _compute_inner_range(self, body_node: Node) -> Tuple[int, int]:
        """Get inner content range, excluding braces if present."""
        if not body_node.children:
            return (body_node.start_byte, body_node.end_byte)

        first_child = body_node.children[0]
        last_child = body_node.children[-1]

        first_text = self.doc.get_node_text(first_child)
        last_text = self.doc.get_node_text(last_child)

        if first_text == "{" and last_text == "}":
            return (first_child.end_byte, last_child.start_byte)

        return (body_node.start_byte, body_node.end_byte)

    def _find_leading_sibling_comments(
        self, func_def: Node, body_node: Node
    ) -> Optional[int]:
        """Find comments between function signature and body."""
        body_index = None
        for i, child in enumerate(func_def.children):
            if child == body_node:
                body_index = i
                break

        if body_index is None:
            return None

        first_comment_start = None
        for i in range(body_index - 1, -1, -1):
            child = func_def.children[i]
            if child.type in self.comment_types:
                first_comment_start = child.start_byte
            else:
                break

        return first_comment_start

    def _find_next_content_byte(self, pos: int) -> int:
        """Find start of next line after position."""
        newline_pos = self.doc.text.find('\n', pos)
        if newline_pos == -1:
            return pos
        return newline_pos + 1

    def _find_line_start(self, pos: int) -> int:
        """Find start of line containing position."""
        line_start = self.doc.text.rfind('\n', 0, pos)
        if line_start == -1:
            return 0
        return line_start + 1
```

## Migration in ElementCollector

Replace in `collector.py`:

```python
# Before
def _compute_body_range(self, func_def, body_node, profile):
    # ... 50 lines of logic ...

# After
from .body_range import BodyRangeComputer

class ElementCollector:
    def __init__(self, doc, descriptor):
        self.doc = doc
        self.descriptor = descriptor
        self._body_range_computer = BodyRangeComputer(doc, descriptor.comment_types)

    def _compute_body_range(self, func_def, body_node, profile):
        return self._body_range_computer.compute(
            func_def,
            body_node,
            docstring_extractor=profile.docstring_extractor,
            body_range_computer=profile.body_range_computer,
        )
```

## Benefits

1. **Single Responsibility** — Collector collects, BodyRangeComputer computes
2. **Testability** — Can unit test BodyRangeComputer in isolation
3. **Extensibility** — Easier to add new computation strategies
4. **Clarity** — 50 lines of logic moved to dedicated class
