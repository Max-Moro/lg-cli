# Отсутствие unit-тестов для utils

## Проблема

Утилитные модули в `lg/adapters/optimizations/literals/utils/` (`interpolation.py`, `element_parser.py`, `indentation.py`, `comment_formatter.py`) не покрыты отдельными unit-тестами. Эти модули являются критичными компонентами, используемыми всеми языковыми адаптерами.

## Риски отсутствия unit-тестов

1. **Баги в утилитах ломают ВСЕ языки** — один баг в `InterpolationHandler` может сломать обработку строк в Python, JavaScript, Kotlin, Scala одновременно

2. **Сложно рефакторить без уверенности** — изменения в `ElementParser` требуют прогона всех integration тестов для проверки корректности

3. **Edge cases не проверяются** — граничные условия (пустые строки, unicode, вложенность) остаются непроверенными до production

4. **Регрессии обнаруживаются поздно** — проблема выявляется только через падение integration тестов, что усложняет локализацию

## Модули требующие покрытия

### 1. InterpolationHandler (utils/interpolation.py)

**Критичность**: Высокая
**Используется в**: Python, JavaScript, TypeScript, Kotlin, Scala (строки с интерполяцией)

**Что нужно тестировать**:
- `get_active_markers()` — активация markers по условиям
- `adjust_truncation()` — корректировка обрезки на границах интерполяции
- `find_interpolation_regions()` — поиск всех регионов интерполяции
- `_find_matching_brace()` — поиск парных скобок с учетом вложенности
- `_find_identifier_end()` — определение конца идентификатора

**Edge cases**:
- Вложенные интерполяторы: `"${outer ${inner} more}"`
- Строки внутри интерполяторов: `"${func("string")}"`
- Escape sequences: `"${var\}not_closing}"`
- Пустые интерполяторы: `"${}"`
- Unicode в интерполяторах: `"${имя}"`

### 2. ElementParser (utils/element_parser.py)

**Критичность**: Критическая
**Используется в**: ВСЕ языки (парсинг элементов коллекций)

**Что нужно тестировать**:
- `parse()` — парсинг списка элементов с учетом вложенности
- `_create_element()` — создание Element с детекцией key-value и nested
- `_split_kv()` — разбиение на ключ-значение
- `_extract_nested_info()` — извлечение информации о вложенных структурах
- `_matches_pattern()` — проверка соответствия паттерну
- `collect_factory_wrappers_from_descriptor()` — сбор factory wrappers

**Edge cases**:
- Вложенные скобки: `{a: {b: {c: d}}}`
- Строки с разделителями: `["a,b", "c,d"]`
- Пустые элементы: `[, , ,]` (некоторые языки)
- Unicode ключи: `{"ключ": "значение"}`
- Многострочные элементы
- Factory wrappers с точками: `Map.of`, `List.of`

### 3. Indentation utilities (utils/indentation.py)

**Критичность**: Средняя
**Используется в**: ВСЕ языки (определение отступов)

**Что нужно тестировать**:
- `detect_base_indent()` — определение базового отступа
- `detect_element_indent()` — определение отступа элементов

**Edge cases**:
- Табы vs пробелы
- Смешанные отступы
- Literal в начале строки (нет отступа)
- Многострочные literals
- Unicode whitespace (неразрывные пробелы)

### 4. CommentFormatter (utils/comment_formatter.py)

**Критичность**: Средняя
**Используется в**: ВСЕ языки (форматирование комментариев)

**Что нужно тестировать**:
- `generate_comment()` — генерация комментария с метриками
- `format_for_context()` — форматирование с учетом контекста
- `format_single()` — форматирование single-line комментария
- `format_block()` — форматирование block комментария
- `_find_insertion_point()` — поиск точки вставки комментария

**Edge cases**:
- Комментарии после точки с запятой
- Комментарии после запятой
- Вложенные блочные комментарии
- Разные стили комментариев (C++, Python, etc.)

## Структура тестов

```
tests/adapters/literals/
├── __init__.py
├── test_interpolation.py          # InterpolationHandler
├── test_element_parser.py          # ElementParser + ParseConfig
├── test_indentation.py             # Indentation utilities
├── test_comment_formatter.py       # CommentFormatter
└── test_parser_factory.py          # ElementParserFactory (после задачи 2.1)
```

## Примеры тестов

### tests/adapters/literals/test_interpolation.py

```python
"""Unit tests for InterpolationHandler."""

import pytest
from lg.adapters.optimizations.literals.utils import InterpolationHandler


class TestGetActiveMarkers:
    def test_returns_empty_for_no_markers(self):
        """Should return empty list when no markers defined."""
        handler = InterpolationHandler()
        from lg.adapters.optimizations.literals import StringProfile

        profile = StringProfile(
            query="(string) @lit",
            opening='"',
            closing='"',
            interpolation_markers=[],
        )

        markers = handler.get_active_markers(profile, '"', "content")

        assert markers == []

    def test_returns_self_verifying_markers(self):
        """Markers with prefix should be self-verifying."""
        handler = InterpolationHandler()
        from lg.adapters.optimizations.literals import StringProfile

        profile = StringProfile(
            query="(string) @lit",
            opening='"',
            closing='"',
            interpolation_markers=[
                ("$", "{", "}"),  # Self-verifying (has prefix)
                ("#", "{", "}"),  # Self-verifying
            ],
        )

        markers = handler.get_active_markers(profile, '"', "content")

        assert len(markers) == 2
        assert ("$", "{", "}") in markers
        assert ("#", "{", "}") in markers

    def test_uses_callback_for_empty_prefix(self):
        """Should use interpolation_active callback for empty prefix markers."""
        handler = InterpolationHandler()
        from lg.adapters.optimizations.literals import StringProfile

        def is_f_string(opening: str, content: str) -> bool:
            return opening.startswith('f"')

        profile = StringProfile(
            query="(string) @lit",
            opening='f"',
            closing='"',
            interpolation_markers=[
                ("", "{", "}"),  # Empty prefix - needs callback
            ],
            interpolation_active=is_f_string,
        )

        markers = handler.get_active_markers(profile, 'f"', "content")

        assert len(markers) == 1
        assert markers[0] == ("", "{", "}")

    def test_skips_inactive_markers(self):
        """Should skip markers that don't pass activation callback."""
        handler = InterpolationHandler()
        from lg.adapters.optimizations.literals import StringProfile

        def is_f_string(opening: str, content: str) -> bool:
            return opening.startswith('f"')

        profile = StringProfile(
            query="(string) @lit",
            opening='"',  # NOT f-string
            closing='"',
            interpolation_markers=[
                ("", "{", "}"),  # Should be skipped (callback returns False)
            ],
            interpolation_active=is_f_string,
        )

        markers = handler.get_active_markers(profile, '"', "content")

        assert len(markers) == 0


class TestFindInterpolationRegions:
    def test_finds_simple_interpolation(self):
        """Should find simple ${} interpolation."""
        handler = InterpolationHandler()
        content = "Hello ${name}, you are ${age} years old"
        markers = [("$", "{", "}")]

        regions = handler.find_interpolation_regions(content, markers)

        assert regions == [(6, 13), (24, 30)]

    def test_finds_nested_interpolation(self):
        """Should handle nested braces correctly."""
        handler = InterpolationHandler()
        content = "${outer ${inner} more}"
        markers = [("$", "{", "}")]

        regions = handler.find_interpolation_regions(content, markers)

        # Should find the outer interpolation
        assert len(regions) == 1
        assert regions[0] == (0, 23)

    def test_handles_strings_inside_interpolation(self):
        """Should not count braces inside strings."""
        handler = InterpolationHandler()
        content = '${func("string with } brace")}'
        markers = [("$", "{", "}")]

        regions = handler.find_interpolation_regions(content, markers)

        assert len(regions) == 1
        assert regions[0] == (0, 31)

    def test_finds_simple_identifier_interpolation(self):
        """Should find $identifier style interpolation."""
        handler = InterpolationHandler()
        content = "Hello $name, you are $age_123 years old"
        markers = [("$", "", "")]  # Simple identifier

        regions = handler.find_interpolation_regions(content, markers)

        assert len(regions) == 2
        assert regions[0] == (6, 11)  # $name
        assert regions[1] == (21, 29)  # $age_123

    def test_handles_empty_interpolation(self):
        """Should handle empty interpolation gracefully."""
        handler = InterpolationHandler()
        content = "Hello ${} world"
        markers = [("$", "{", "}")]

        regions = handler.find_interpolation_regions(content, markers)

        assert len(regions) == 1
        assert regions[0] == (6, 9)  # ${}

    def test_handles_unicode_in_interpolation(self):
        """Should handle unicode correctly."""
        handler = InterpolationHandler()
        content = "Привет ${имя}, тебе ${возраст} лет"
        markers = [("$", "{", "}")]

        regions = handler.find_interpolation_regions(content, markers)

        assert len(regions) == 2


class TestAdjustTruncation:
    def test_extends_to_include_full_interpolator(self):
        """Should extend truncation to include complete interpolator."""
        handler = InterpolationHandler()
        original = "Hello ${name} world"
        truncated = "Hello $"  # Cut inside interpolator
        markers = [("$", "{", "}")]

        adjusted = handler.adjust_truncation(truncated, original, markers)

        assert adjusted == "Hello ${name}"  # Extended to full interpolator

    def test_no_adjustment_when_outside_interpolator(self):
        """Should not adjust when cut point is outside interpolation."""
        handler = InterpolationHandler()
        original = "Hello ${name} world"
        truncated = "Hello "  # Before interpolator
        markers = [("$", "{", "}")]

        adjusted = handler.adjust_truncation(truncated, original, markers)

        assert adjusted == "Hello "  # No change

    def test_handles_multiple_interpolators(self):
        """Should handle multiple interpolators correctly."""
        handler = InterpolationHandler()
        original = "Hello ${first} and ${second} world"
        truncated = "Hello ${first} and $"  # Cut in second interpolator
        markers = [("$", "{", "}")]

        adjusted = handler.adjust_truncation(truncated, original, markers)

        assert adjusted == "Hello ${first} and ${second}"


class TestFindMatchingBrace:
    def test_finds_simple_matching_brace(self):
        """Should find simple matching closing brace."""
        handler = InterpolationHandler()
        content = "{hello world}"

        end = handler._find_matching_brace(content, 0)

        assert end == 12  # Position of '}'

    def test_handles_nested_braces(self):
        """Should handle nested braces correctly."""
        handler = InterpolationHandler()
        content = "{outer {inner} more}"

        end = handler._find_matching_brace(content, 0)

        assert end == 19  # Position of final '}'

    def test_handles_strings_with_braces(self):
        """Should not count braces inside strings."""
        handler = InterpolationHandler()
        content = '{text "with } brace"}'

        end = handler._find_matching_brace(content, 0)

        assert end == 20  # Position of final '}'

    def test_returns_minus_one_for_unmatched(self):
        """Should return -1 when no matching brace found."""
        handler = InterpolationHandler()
        content = "{no closing brace"

        end = handler._find_matching_brace(content, 0)

        assert end == -1


class TestFindIdentifierEnd:
    def test_finds_simple_identifier_end(self):
        """Should find end of simple identifier."""
        handler = InterpolationHandler()
        content = "name_123xyz"

        end = handler._find_identifier_end(content, 0)

        assert end == 11

    def test_stops_at_non_identifier_char(self):
        """Should stop at first non-identifier character."""
        handler = InterpolationHandler()
        content = "name, other"

        end = handler._find_identifier_end(content, 0)

        assert end == 4  # Before comma

    def test_handles_unicode_identifiers(self):
        """Should handle unicode identifiers."""
        handler = InterpolationHandler()
        content = "имя_переменной"

        end = handler._find_identifier_end(content, 0)

        assert end == 14

    def test_returns_start_for_non_identifier_start(self):
        """Should return start pos if doesn't start with valid char."""
        handler = InterpolationHandler()
        content = "123invalid"

        end = handler._find_identifier_end(content, 0)

        assert end == 0  # Invalid start
```

### tests/adapters/literals/test_element_parser.py

```python
"""Unit tests for ElementParser."""

import pytest
from lg.adapters.optimizations.literals.utils import ElementParser, ParseConfig


class TestElementParserBasic:
    def test_parses_simple_elements(self):
        """Should parse simple comma-separated elements."""
        config = ParseConfig(separator=",")
        parser = ElementParser(config)

        elements = parser.parse("a, b, c")

        assert len(elements) == 3
        assert [e.text for e in elements] == ["a", "b", "c"]

    def test_handles_nested_brackets(self):
        """Should not split on separator inside brackets."""
        config = ParseConfig(separator=",")
        parser = ElementParser(config)

        elements = parser.parse("a, [b, c], d")

        assert len(elements) == 3
        assert elements[0].text == "a"
        assert elements[1].text == "[b, c]"
        assert elements[2].text == "d"

    def test_handles_strings_with_separator(self):
        """Should not split on separator inside strings."""
        config = ParseConfig(separator=",")
        parser = ElementParser(config)

        elements = parser.parse('"a, b", "c, d"')

        assert len(elements) == 2
        assert elements[0].text == '"a, b"'
        assert elements[1].text == '"c, d"'


class TestKeyValueParsing:
    def test_splits_key_value_pairs(self):
        """Should split key-value pairs at depth 0."""
        config = ParseConfig(separator=",", kv_separator=":")
        parser = ElementParser(config)

        elements = parser.parse("key1: value1, key2: value2")

        assert len(elements) == 2
        assert elements[0].key == "key1"
        assert elements[0].value == "value1"
        assert elements[1].key == "key2"
        assert elements[1].value == "value2"

    def test_does_not_split_nested_colon(self):
        """Should not split on colon inside nested structure."""
        config = ParseConfig(separator=",", kv_separator=":")
        parser = ElementParser(config)

        elements = parser.parse("key: {nested: value}")

        assert len(elements) == 1
        assert elements[0].key == "key"
        assert elements[0].value == "{nested: value}"


class TestNestedStructureDetection:
    def test_detects_nested_brackets(self):
        """Should detect nested bracket structures."""
        config = ParseConfig(separator=",")
        parser = ElementParser(config)

        elements = parser.parse("{a: [1, 2, 3]}")

        assert len(elements) == 1
        assert elements[0].is_nested
        assert elements[0].nested_opening == "{"
        assert elements[0].nested_closing == "}"
        assert elements[0].nested_content == "a: [1, 2, 3]"

    def test_detects_factory_wrappers(self):
        """Should detect factory method wrappers."""
        config = ParseConfig(
            separator=",",
            factory_wrappers=["List.of", "Map.of"]
        )
        parser = ElementParser(config)

        elements = parser.parse("List.of(1, 2, 3)")

        assert len(elements) == 1
        assert elements[0].is_nested
        assert elements[0].nested_wrapper == "List.of"
        assert elements[0].nested_opening == "("
        assert elements[0].nested_content == "1, 2, 3"


class TestFactoryWrappersCollection:
    def test_collects_from_factory_profiles(self):
        """Should collect wrappers from FactoryProfile."""
        from lg.adapters.optimizations.literals import (
            LanguageLiteralDescriptor,
            FactoryProfile,
        )

        descriptor = LanguageLiteralDescriptor(
            profiles=[
                FactoryProfile(
                    query="...",
                    wrapper_match=r"(List\.of|Set\.of)$",
                    opening="(",
                    closing=")",
                    separator=",",
                ),
            ],
        )

        wrappers = ElementParser.collect_factory_wrappers_from_descriptor(descriptor)

        assert "List.of" in wrappers
        assert "Set.of" in wrappers


class TestEdgeCases:
    def test_handles_empty_content(self):
        """Should handle empty content gracefully."""
        config = ParseConfig(separator=",")
        parser = ElementParser(config)

        elements = parser.parse("")

        assert elements == []

    def test_handles_single_element(self):
        """Should handle single element without separator."""
        config = ParseConfig(separator=",")
        parser = ElementParser(config)

        elements = parser.parse("single")

        assert len(elements) == 1
        assert elements[0].text == "single"

    def test_handles_trailing_separator(self):
        """Should handle trailing separator."""
        config = ParseConfig(separator=",")
        parser = ElementParser(config)

        elements = parser.parse("a, b, c,")

        # Trailing separator creates empty element (handled by DFS selector)
        assert len(elements) in (3, 4)  # Depends on implementation

    def test_handles_unicode_elements(self):
        """Should handle unicode correctly."""
        config = ParseConfig(separator=",", kv_separator=":")
        parser = ElementParser(config)

        elements = parser.parse('{"ключ": "значение", "名前": "値"}')

        assert len(elements) == 1
        assert elements[0].is_nested
```

## Метрики покрытия

### Целевые показатели

- **InterpolationHandler**: 90%+ line coverage
- **ElementParser**: 85%+ line coverage
- **Indentation utilities**: 95%+ line coverage
- **CommentFormatter**: 90%+ line coverage

### Инструменты

```bash
# Запуск с coverage
pytest tests/adapters/literals/ --cov=lg/adapters/optimizations/literals/utils --cov-report=html

# Просмотр отчета
open htmlcov/index.html
```

## Ожидаемые выгоды

- Высокая уверенность в корректности базовых утилит
- Возможность рефакторинга без страха
- Раннее обнаружение регрессий (на уровне unit-тестов, а не integration)
- Документация ожидаемого поведения через тесты
- Упрощение отладки (локализация проблем до конкретной утилиты)
- Быстрая итерация (unit-тесты выполняются за секунды vs minutes для integration)
