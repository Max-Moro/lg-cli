# Вынос логики позиционирования комментариев

## Проблема

Метод `ResultFormatter._find_comment_insertion_point` (строки 125-179) анализирует синтаксис языка для определения правильной позиции и стиля комментария:

- Анализирует closing brackets, semicolons, commas
- Определяет нужен ли block comment vs single-line comment
- Проверяет наличие кода после литерала

Это не задача formatter — formatter должен форматировать результаты, а не анализировать синтаксические особенности языка. Такая логика должна быть в отдельной утилите.

Текущая оценка Formatter: **5/10** — смешение ответственности.

## Целевые файлы

- `lg/adapters/optimizations/literals/processing/formatter.py` (упростить)
- `lg/adapters/optimizations/literals/utils/comment_placement.py` (создать)
- `lg/adapters/optimizations/literals/utils/__init__.py` (обновить экспорты)

## План рефакторинга

### Шаг 1: Создать CommentPlacementAnalyzer утилиту

Создать файл `lg/adapters/optimizations/literals/utils/comment_placement.py`:

```python
"""
Comment placement analysis utility.

Analyzes source code context to determine optimal comment positioning.
"""

from __future__ import annotations

from typing import Tuple


class CommentPlacementAnalyzer:
    """
    Analyzes source code context to determine comment placement.

    Handles:
    - Determining insertion offset (after semicolons, brackets, etc.)
    - Choosing between single-line and block comments
    - Avoiding syntax errors in different contexts
    """

    def __init__(self, comment_style: tuple[str, tuple[str, str]]):
        """
        Initialize analyzer.

        Args:
            comment_style: (single_line_prefix, (block_open, block_close))
        """
        self.single_comment = comment_style[0]
        self.block_comment = comment_style[1]

    def analyze(
        self,
        text_after_literal: str,
        comment_content: str,
    ) -> tuple[str, int]:
        """
        Analyze context and format comment appropriately.

        Args:
            text_after_literal: Text after the literal in source code
            comment_content: Raw comment text (e.g., "literal string (−42 tokens)")

        Returns:
            Tuple of (formatted_comment, offset_from_literal_end)
            - formatted_comment: Complete formatted comment with syntax
            - offset_from_literal_end: Characters to skip before inserting
        """
        # Find insertion point and determine comment style
        offset, needs_block = self._find_insertion_point(text_after_literal)

        if needs_block:
            return self._format_block_comment(comment_content), offset

        return self._format_single_comment(comment_content), offset

    def _find_insertion_point(self, line_remainder: str) -> tuple[int, bool]:
        """
        Find the best insertion point for comment.

        Analyzes trailing code after the literal to determine:
        1. How many characters to skip (offset)
        2. Whether block comment is needed

        Logic:
        - Empty line: single-line at literal end (offset=0)
        - Closing brackets: skip them, then check what follows
        - Semicolon: if nothing after, single-line OK; otherwise block
        - Comma: if followed by more elements, block needed; otherwise single-line
        - Other code: always use block comment

        Args:
            line_remainder: Text after literal on same line

        Returns:
            Tuple of (offset, needs_block_comment)
        """
        if not line_remainder.strip():
            return 0, False  # Empty line - insert at literal end, single-line OK

        # Look for punctuation that should come before the comment
        offset = 0

        # Skip closing brackets first
        while offset < len(line_remainder) and line_remainder[offset] in ')]}':
            offset += 1

        # Check for semicolon
        if offset < len(line_remainder) and line_remainder[offset] == ';':
            offset += 1
            # Check what follows the semicolon
            after_semi = line_remainder[offset:].strip()
            if after_semi:
                # Code after semicolon - need block comment
                return offset, True
            return offset, False

        # Check for comma
        if offset < len(line_remainder) and line_remainder[offset] == ',':
            offset += 1
            after_comma = line_remainder[offset:].strip()
            # Safe if followed by closing bracket or end of line
            if not after_comma or after_comma[0] in ')]}':
                return offset, False
            # More elements follow - need block comment
            return offset, True

        # No recognized punctuation - check if there's code
        remaining = line_remainder[offset:].strip()
        if remaining:
            return offset, True  # Code present - need block comment

        return offset, False

    def _format_single_comment(self, content: str) -> str:
        """Format as single-line comment."""
        return f" {self.single_comment} {content}"

    def _format_block_comment(self, content: str) -> str:
        """Format as block comment."""
        return f" {self.block_comment[0]} {content} {self.block_comment[1]}"
```

### Шаг 2: Упростить ResultFormatter через делегирование

Обновить `ResultFormatter` в `formatter.py`:

```python
class ResultFormatter:
    """Formats trimmed literal results for source code insertion."""

    def __init__(
        self,
        tokenizer: TokenService,
        comment_style: tuple[str, tuple[str, str]]
    ):
        """Initialize formatter with tokenizer and comment syntax."""
        self.tokenizer = tokenizer
        self.single_comment = comment_style[0]
        self.block_comment = comment_style[1]

        # Create comment placement analyzer
        from ..utils.comment_placement import CommentPlacementAnalyzer
        self.comment_analyzer = CommentPlacementAnalyzer(comment_style)

    def _format_comment_for_context(
        self,
        text_after_literal: str,
        comment_content: str,
    ) -> tuple[str, int]:
        """
        Determine comment format and insertion offset based on context.

        Delegates to CommentPlacementAnalyzer for analysis.

        Args:
            text_after_literal: Text after the literal in source code
            comment_content: Raw comment text

        Returns:
            Tuple of (formatted_comment, offset_from_literal_end)
        """
        return self.comment_analyzer.analyze(text_after_literal, comment_content)

    # Remove old methods:
    # - _find_comment_insertion_point (moved to CommentPlacementAnalyzer)
    # - _format_single_comment (moved to CommentPlacementAnalyzer)
    # - _format_block_comment (moved to CommentPlacementAnalyzer)
```

### Шаг 3: Обновить экспорты

Обновить `lg/adapters/optimizations/literals/utils/__init__.py`:

```python
"""
Components for literals optimization.
"""

from .element_parser import ElementParser, Element, ParseConfig
from .interpolation import InterpolationHandler
from .indentation import detect_base_indent, detect_element_indent
from .comment_placement import CommentPlacementAnalyzer

__all__ = [
    'ElementParser',
    'Element',
    'ParseConfig',
    'InterpolationHandler',
    'detect_base_indent',
    'detect_element_indent',
    'CommentPlacementAnalyzer',
]
```

## Критерии успешности

После рефакторинга:

1. **Четкое разделение ответственности**:
   - Formatter только форматирует результаты
   - CommentPlacementAnalyzer анализирует синтаксис
   - Логика анализа изолирована и переиспользуема

2. **Размер модулей**:
   - `formatter.py`: уменьшается на ~60 строк
   - `comment_placement.py`: ~120 строк (новый)

3. **Тестируемость**:
   - CommentPlacementAnalyzer можно тестировать независимо
   - Легко добавить unit tests для edge cases

## Проверка результата

1. Запустить golden tests:
   ```bash
   ./scripts/test_adapters.sh literals all
   ```

2. Особое внимание к контекстам комментариев:
   - После semicolons
   - После commas в multiline literals
   - В конце строки
   - Перед closing brackets

3. Проверить форматирование комментариев в разных языках

## Ожидаемый результат

- ✅ Все golden tests проходят без изменений
- ✅ Логика анализа синтаксиса вынесена из formatter
- ✅ Код более maintainable
- ✅ Оценка Formatter повышается с 5/10 до 7/10 (после этого + рефакторинга из 00)
