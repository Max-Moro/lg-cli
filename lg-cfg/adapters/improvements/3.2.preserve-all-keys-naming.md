# Неявное поведение preserve_all_keys

## Проблема

Параметр `preserve_all_keys` в `MappingProfile` влияет только на top-level ключи, но это не документировано явно. Название параметра может создать неправильные ожидания, что ВСЕ ключи на ВСЕХ уровнях вложенности будут сохранены.

## Примеры неоднозначности

```python
# go/literals.py
GO_STRUCT_PROFILE = MappingProfile(
    query="""
    (composite_literal
      type: (type_identifier) @type_name
      (#not-match? @type_name "^map")
      body: (literal_value)) @lit
    """,
    opening="{",
    closing="}",
    separator=",",
    kv_separator=":",
    wrapper_match=r"^(?!map\[)(?!\[\]).*",
    placeholder_position=PlaceholderPosition.END,
    placeholder_template='"…"',
    preserve_all_keys=True,  # ??? Что именно сохраняется?
    min_elements=1,
    comment_name="struct",
)
```

**Неочевидное поведение**:

```go
// Original Go struct literal
Config{
    Host: "localhost",
    Port: 8080,
    Settings: map[string]string{
        "key1": "value1",
        "key2": "value2",
        "key3": "value3",
        "key4": "value4",
        "key5": "value5",
    }
}

// With preserve_all_keys=True
// Ожидание (НЕПРАВИЛЬНОЕ): все ключи сохранены
Config{
    Host: "localhost",                 // Top-level - kept
    Port: 8080,                        // Top-level - kept
    Settings: map[string]string{       // Top-level - kept
        "key1": "value1",              // Nested - kept???
        "key2": "value2",              // Nested - kept???
        "key3": "value3",              // Nested - kept???
        "key4": "value4",              // Nested - kept???
        "key5": "value5",              // Nested - kept???
    }
}

// Реальность: только top-level ключи
Config{
    Host: "localhost",                 // Top-level field - KEPT
    Port: 8080,                        // Top-level field - KEPT
    Settings: map[string]string{       // Top-level field - KEPT
        "key1": "value1",
        // ... (4 more, −50 tokens)   // Nested map - OPTIMIZED!
    }
}
```

## Решение 1: Улучшить документацию

```python
# patterns.py
@dataclass
class MappingProfile(CollectionProfile):
    """
    Profile for mapping literal patterns.

    Describes how to recognize and process mapping literals (dicts, maps,
    objects, hash maps), including key-value separation, element separation,
    and handling of typed structures where all keys must be preserved.

    Parameters:
    -----------
    preserve_all_keys : bool
        Preserve all keys/fields at TOP LEVEL ONLY.

        When True:
            - All top-level keys are kept (never removed)
            - Optimization is applied to nested values
            - Nested mappings are still subject to normal optimization

        When False:
            - Both keys and values can be optimized
            - Top-level elements can be removed if over budget

        Use case: Typed struct literals where field names must be preserved
        to maintain type safety and code clarity.

        Examples:
            Go struct with preserve_all_keys=True:
                Original:
                    Config{
                        Host: "localhost",       // 3 top-level fields
                        Port: 8080,
                        Settings: map[string]string{
                            "key1": "value1",    // Nested map
                            "key2": "value2",
                            "key3": "value3",
                            // ... many more
                        }
                    }

                Optimized:
                    Config{
                        Host: "localhost",       // KEPT (top-level field)
                        Port: 8080,              // KEPT (top-level field)
                        Settings: map[string]string{
                            "key1": "value1",
                            // ... (25 more, −120 tokens)  // NESTED map optimized!
                        }
                    }

            Python dict with preserve_all_keys=False:
                Original:
                    {
                        "name": "Alice",
                        "age": 30,
                        "email": "alice@example.com",
                        "address": {...},
                        // ... many more fields
                    }

                Optimized:
                    {
                        "name": "Alice",
                        // ... (50 more, −200 tokens)  // Top-level can be removed
                    }

        Note:
            - This parameter does NOT affect recursion depth
            - Nested mappings always use their own profile settings
            - To preserve all keys at all levels, you would need to set
              preserve_all_keys=True for ALL mapping profiles (not recommended)
    """

    kv_separator: str = ":"
    placeholder_position: PlaceholderPosition = PlaceholderPosition.MIDDLE_COMMENT
    placeholder_template: str = '"…": "…"'
    preserve_all_keys: bool = False  # Preserve all TOP-LEVEL keys only
    wrapper_match: Optional[str] = None
```

## Решение 2: Переименовать параметр

Более явное имя, отражающее scope действия:

```python
@dataclass
class MappingProfile(CollectionProfile):
    """
    Profile for mapping literal patterns.
    """

    kv_separator: str = ":"
    placeholder_position: PlaceholderPosition = PlaceholderPosition.MIDDLE_COMMENT
    placeholder_template: str = '"…": "…"'

    # НОВОЕ НАЗВАНИЕ - более явное!
    preserve_top_level_keys: bool = False  # Only top-level keys are preserved

    wrapper_match: Optional[str] = None
```

**Миграция**:

```python
# Добавить deprecated alias для backward compatibility
@dataclass
class MappingProfile(CollectionProfile):
    preserve_top_level_keys: bool = False

    # Deprecated alias (can be removed in future)
    @property
    def preserve_all_keys(self) -> bool:
        """Deprecated: use preserve_top_level_keys instead."""
        import warnings
        warnings.warn(
            "preserve_all_keys is deprecated, use preserve_top_level_keys",
            DeprecationWarning,
            stacklevel=2
        )
        return self.preserve_top_level_keys
```

**Обновление дескрипторов**:

```python
# go/literals.py
GO_STRUCT_PROFILE = MappingProfile(
    query="""...""",
    opening="{",
    closing="}",
    separator=",",
    kv_separator=":",
    wrapper_match=r"^(?!map\[)(?!\[\]).*",
    placeholder_position=PlaceholderPosition.END,
    placeholder_template='"…"',
    preserve_top_level_keys=True,  # Более явное название!
    min_elements=1,
    comment_name="struct",
)
```

## Сравнение решений

### Решение 1: Улучшить документацию

**Плюсы**:
- Не ломает существующий код
- Простая реализация
- Сохраняет обратную совместимость

**Минусы**:
- Название остается неявным
- Требует чтения документации
- Потенциальная путаница для новых пользователей

### Решение 2: Переименовать

**Плюсы**:
- Явное имя отражает поведение
- Self-documenting code
- Меньше путаницы

**Минусы**:
- Breaking change (требует миграции)
- Нужен deprecated alias для backward compatibility

**Рекомендация**: Использовать **Решение 2** (переименовать) с deprecated alias для плавной миграции.

## Дополнительная документация в selector.py

```python
# processing/selector.py
class BudgetSelector:
    def select_dfs(
        self,
        elements: List[Element],
        budget: int,
        parser: ElementParser,
        min_keep: int = 1,
        tuple_size: int = 1,
        preserve_top_level_keys: bool = False,  # Обновленное имя
    ) -> DFSSelection:
        """
        Select elements using depth-first strategy for nested structures.

        Args:
            elements: List of elements at current level
            budget: Token budget for this level and all nested levels
            parser: ElementParser configured for a profile
            min_keep: Minimum elements to keep at each level
            tuple_size: Group elements into tuples (e.g., 2 for k,v pairs)
            preserve_top_level_keys: If True, keep all keys at THIS level.
                                     DOES NOT affect nested levels.

        Returns:
            DFSSelection with kept/removed elements and nested selections

        Note on preserve_top_level_keys:
            When True, all top-level elements are kept regardless of budget.
            This is useful for typed structures (Go structs, TypeScript interfaces)
            where field names must be preserved for type safety.

            Nested structures within values are still optimized normally.

            Example:
                preserve_top_level_keys=True at top level:
                    Struct{
                        Field1: "value",          // KEPT (top level)
                        Field2: {...nested...},   // KEPT (top level), but nested optimized
                    }

                preserve_top_level_keys=False (default):
                    {
                        "key1": "value",          // Can be removed if over budget
                        "key2": {...nested...},   // Can be removed if over budget
                    }
        """
        # ...
```

## Тестирование

```python
# tests/adapters/test_preserve_top_level_keys.py
import pytest
from lg.adapters.optimizations.literals import MappingProfile


def test_preserve_top_level_keys_default_false():
    """preserve_top_level_keys should default to False."""
    profile = MappingProfile(
        query="(object) @lit",
        opening="{",
        closing="}",
        separator=",",
        kv_separator=":",
    )
    assert profile.preserve_top_level_keys is False


def test_preserve_top_level_keys_explicit_true():
    """Can explicitly set preserve_top_level_keys to True."""
    profile = MappingProfile(
        query="(struct) @lit",
        opening="{",
        closing="}",
        separator=",",
        kv_separator=":",
        preserve_top_level_keys=True,
    )
    assert profile.preserve_top_level_keys is True


def test_deprecated_preserve_all_keys_alias():
    """preserve_all_keys should be deprecated alias."""
    profile = MappingProfile(
        query="(struct) @lit",
        opening="{",
        closing="}",
        separator=",",
        kv_separator=":",
        preserve_top_level_keys=True,
    )

    # Access via deprecated alias should work but warn
    with pytest.warns(DeprecationWarning, match="preserve_all_keys is deprecated"):
        value = profile.preserve_all_keys
        assert value is True
```

## Ожидаемые выгоды

- Явное понимание scope параметра (только top-level)
- Предотвращение неправильных ожиданий
- Self-documenting code через явное имя параметра
- Улучшенная документация с примерами
- Плавная миграция через deprecated alias
