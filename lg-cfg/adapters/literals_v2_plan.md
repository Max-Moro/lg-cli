# План рефакторинга Literal Optimization v2

## Вводная
Текущая подсистема оптимизации литералов развивалась достаточно длительное время и постепенно усложнялась. Ее текущее ядро сразу не учитывало потребности всех 10 языков. По этой причине каждый из новых добавляемых языков привносил новые проблемы. И каждый раз приходилось расширять возможности ядра `lg/adapters/optimizations/literals/`. Из-за постоянно точечных изменений текущий код уже выглядит не так стройно и красиво. В нем множество эвристических проверок и частных случаев.

Я предлагаю сейчас взять и кардинально переписать систему "Literal Optimization" на версию 2.0, в которой сразу будут элегантным образом учитываться потребности и особенности всех 10 языков. Это будет способствовать облегчению и добавлению новых языков в будущем.

Новое ядро мы будем писать параллельно, не удаляя старый код. То есть мы заведем новую директорию `lg/adapters/optimizations/literals_v2/`, а в каждом языке мы заведем новый модуль `lg/adapters/<язык>/literals_v2.py`. На уровне `lg/adapters/<язык>/adapter.py` — добавим новый метод `def create_literal_descriptor_v2(self) -> LanguageLiteralDescriptorv2`. Таким образом у нас будут доступны и старая и новая версии, которые при необходимости мы в любой момент сможем сравнить.

При разработке "Literal Optimization V2" необходимо будет решить следующие проблему текущей версии:

1. Громоздкие языковые конфиги на уровне `lg/adapters/<язык>/literals.py`. Конфигурация паттернов `LiteralPattern` слишком плоская (не позволяет по группам исключать или добавлять связанные параметры), плохо подобраны дефолтные значения. В принципе приветствуются любые идеи, как модули `lg/adapters/<язык>/literals.py` сделать компактнее и меньше дублировать конфигурационную шаблонную логику между разными языками.

2. `LanguageLiteralDescriptor` используется почти что просто как контейнер для `patterns: List[LiteralPattern]`. Возможно стоит задуматься о расширении его роли. Возможно можно придумать универсальные флаги, целиком определяющие синтаксис языка в рамках разных паттернов.

3. Частные случаи в ядре, которые полагаются не на четкую конфигурацию, а на хитрые эвристические алгоритмы. В некоторые местах можно было бы сильно упростить код ядра, просто совсем немного расширив конфигурацию. То есть сделав логику более явной.

4. Ядро в изначальной схеме слишком простое. Поэтому все особые языковые нюансы в него добавлены, как бы сбоку. Они не были учтены с самого начала.

5. Внутренняя ER-модель ядра слишком бедная. Часто передается сквозным образом между методами слишком крупный кусок данных в виде `LiteralPattern`.

## Текущая структура и недостатки (v1)
- Файлы (`wc -l`): `handler.py` 905, `block_init.py` 778, `formatter.py` 585, `parser.py` 522, `selector.py` 556, `core.py` 394, `categories.py` 198, `descriptor.py` 29, `__init__.py` 31 (всего ~3998 строк).
- Недостатки:
  - Монолитные модули (handler/block_init/formatter/parser/selector) с большим объёмом кода и пересекающимися обязанностями.
  - Много эвристик и частных случаев, не выразимых через конфиг; языковые особенности вшиты в код.
  - Плоский `LiteralPattern`, слабая ER-модель, `LanguageLiteralDescriptor` — фактически контейнер.
  - Повторяющаяся логика между языковыми модулями `literals.py`, отсутствие групповых профилей и наследования.

## Уроки из истории (1be3e3557ca812a321368d0e0107cbcec2f40517 → d82e57f34b1ef3ba688165b57f1f253387f313f6)
- В диапазоне коммитов заметны частые “горячие” фиксы и рефакторы v2: formatter (1b66e9b), selection (aa3b41b), handler/lang фиксы (92f04de), кеш токенизатора (ca68811), поддержка интерполяции/TypeScript (1034c06), двухпроходность/Java (b5f8e56), миграции Kotlin/Scala/Go/C/C++ и BLOCK_INIT (0da2531, 7943bce, 20324b8, 2dd4928, d82e57f). Это отражает накопление хаотичных правок и отсутствие жёстких границ.
- Итеративные точечные патчи вносились прямо в handler/formatter/selector, размывая ответственность.
- Новые языковые нюансы внедрялись внутрь общего кода, вместо изолированных компонентов.
- Вывод: нужны жёсткие контрактные границы и компонентная композиция, чтобы пресечь “быстрые” хаки и локализовать изменения.

## Архитектура v2 (компонентная композиция) и покрытие проблем
- `lg/adapters/optimizations/literals_v2/`:
  - `patterns.py`: типизированная иерархия паттернов и профилей (strings/raw/interp, seq, map, factory, block_init, ast_seq) с групповой настройкой и наследованием → решает плоскость конфигов и дубли.
  - `descriptor.py`: `LanguageLiteralDescriptorV2` с флагами синтаксиса (comment style, raw/template/interp strings, factory wrappers, block_init, ast-seq) и включаемыми профилями → убирает хардкод в коде.
  - `components/`: расширяемый набор специализированных движков, подключаемых через стабильные интерфейсы:
    - `block_init.py`: imperative init с настраиваемыми селекторами/placeholder.
    - `ast_sequence.py`: AST-последовательности (конкатенация строк и др.).
    - `interpolation.py`: правила границ интерполяции/делимитеров, чтобы не дублировать в parser/formatter.
    - `placeholder.py`: единый форматтер плейсхолдеров/комментариев (с сохранением текущего формата).
    - `budgeting.py`: вспомогательные политики бюджетов/приоритетов (без форматирования).
    - `…`: дополнительные компоненты по мере появления новых особенностей, чтобы не патчить общий пайплайн.
  - `processing/`:
    - `pipeline.py`: LiteralPipeline — точка входа v2, orchestration без языковых хаков.
    - `parser.py`: ContentParser — разбор без знаний о placeholder/бюджете.
    - `selector.py`: BudgetSelector — выбор по токен-бюджету, без форматирования.
    - `formatter.py`: ResultFormatter — финальное форматирование и placeholder (с сохранением текущего формата).
- Адаптеры:
  - `create_literal_descriptor_v2` и `lg/adapters/<lang>/literals_v2.py`, опирающиеся на базовые профили с минимальными override → меньше копипасты.

## Границы ответственности и защита от точечных костылей
- `patterns.py`: только декларация паттернов/профилей и их слияние; без парсинга и форматирования.
- `descriptor.py`: декларация возможностей языка; без исполнения.
- `components/*`: изолированные алгоритмы для специфичных структур; подключаются через контракт, не правят пайплайн.
- `processing/pipeline.py`: orchestration/DI компонентов; без языковых хаков.
- `processing/parser.py`: парсинг в структурированное представление; без бюджетов и placeholder.
- `processing/selector.py`: выбор по бюджету; без форматирования и комментариев.
- `processing/formatter.py`: формат и placeholder; без парсинга и бюджетных решений.
- Правило расширения: новая особенность → новый компонент или расширение профилей/descriptor; прямые правки pipeline/formatter/selector запрещены.

## Требования и ограничения
- Переключение v1/v2: энв‑флаг в `lg/adapters/code_analysis.py`.
- Формат плейсхолдеров и комментариев: сохраняем существующий.
- Покрытие: сразу все 10 языков.
- Код строго типизирован; комментарии/докстринги — на английском (план — на русском).


