# План рефакторинга Literal Optimization v2

## Цели
- Построить новое ядро Literal Optimization v2 в `lg/adapters/optimizations/literals_v2/`, сохранив работоспособность старой версии.
- Сразу поддержать все 10 языков, устранить точечные патчи и дублирование конфигурации.
- Сохранить текущий формат плейсхолдеров и комментариев.

## Ограничения и требования
- Переключение v1/v2 через энв‑флаг на уровне `lg/adapters/code_analysis.py`.
- Метрики — без дополнительных ключей: используем существующие поля.
- Формат плейсхолдеров/комментариев менять нельзя.
- Код строго типизирован, без `Any` и `TYPE_CHECKING`; комментарии и докстринги — на английском, но план — на русском.

## Архитектурные идеи v2
- Новый пакет `literals_v2`:
  - `pattern.py`: иерархия паттернов с профилями (strings/raw/interp, seq, map, factory, block_init, ast_seq), групповые дефолты, наследование/override.
  - `descriptor.py`: `LanguageLiteralDescriptorV2` с языковыми флагами (comment style, поддержка raw/template/interp strings, factory wrappers, block_init, ast-based sequences), набором профилей и включаемыми группами.
  - `parser.py`/`selector.py`/`formatter.py`: минимальные эвристики; поведение определяется конфигом (layout, placeholder, budget, priorities).
  - `handler.py`: координация без языковых хаков, опирается на descriptor и флаги.
  - `block_init.py`: общий движок для imperative init (Java double-brace, Rust HashMap, др.) с настраиваемыми селекторами/placeholder.
  - `ast_sequence.py`: общий движок для AST‑последовательностей (конкатенация строк и т.п.), управляемый descriptor.
- В адаптерах добавить `create_literal_descriptor_v2(self) -> LanguageLiteralDescriptorV2`; старая `create_literal_descriptor` остаётся.

## Покрытие языков (обязательно сразу)
- Python, TypeScript/JavaScript, Kotlin, Java, C/C++, Go, Rust, Scala, Markdown (если требуется для литералов), плюс любые вспомогательные.
- Каждому языку — модуль `lg/adapters/<lang>/literals_v2.py` с использованием базовых профилей и минимальными локальными override.

## Миграционный переключатель
- Энв‑флаг в `lg/adapters/code_analysis.py` (например, `LG_LITERALS_V2=1`) для выбора пайплайна v2 при обработке кода; по умолчанию — v1.

## Этапы работ
1) Каркас `literals_v2` (типы, descriptor, handler, parser/selector/formatter, block_init, ast_sequence) + базовые профили.
2) Интеграция энв‑переключателя в `code_analysis.py`, не трогая старый пайплайн.
3) Добавить `create_literal_descriptor_v2` в адаптеры и реализовать v2‑модули для всех 10 языков, сохранив существующий формат плейсхолдеров.
4) Минимальная валидация на существующих тестах/примерных файлах (без изменения метрик и плейсхолдеров).
5) Чистка/упрощение (убрать дубли в конфиге за счёт профилей, проверить дефолты).

## Риски и проверки
- Риск регрессии в форматах плейсхолдеров — контролируем строгим сохранением текущего формата.
- Объём изменений большой: потребуется параллельное существование v1/v2 и быстрый откат через энв‑флаг.
- Разные языковые особенности (raw strings, template/interp, block init) должны быть покрыты профилями, а не хардкодом.

## Открытые пункты (уточнения согласованы)
- Переключатель: энв на уровне `code_analysis.py`.
- Метрики: без новых ключей.
- Покрытие: сразу все языки.
- Формат плейсхолдеров: оставить как есть.

