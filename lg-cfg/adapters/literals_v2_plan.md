# План рефакторинга Literal Optimization v2

## Вводная
Текущая подсистема оптимизации литералов развивалась достаточно длительное время и постепенно усложнялась. Ее текущее ядро сразу не учитывало потребности всех 10 языков. По этой причине каждый из новых добавляемых языков привносил новые проблемы. И каждый раз приходилось расширять возможности ядра `lg/adapters/optimizations/literals/`. Из-за постоянно точечных изменений текущий код уже выглядит не так стройно и красиво. В нем множество эвристических проверок и частных случаев.

Я предлагаю сейчас взять и кардинально переписать систему "Literal Optimization" на версию 2.0, в которой сразу будут элегантным образом учитываться потребности и особенности всех 10 языков. Это будет способствовать облегчению и добавлению новых языков в будущем.

Новое ядро мы будем писать параллельно, не удаляя старый код. То есть мы заведем новую директорию `lg/adapters/optimizations/literals_v2/`, а в каждом языке мы заведем новый модуль `lg/adapters/<язык>/literals_v2.py`. На уровне `lg/adapters/<язык>/adapter.py` — добавим новый метод `def create_literal_descriptor_v2(self) -> LanguageLiteralDescriptorv2`. Таким образом у нас будут доступны и старая и новая версии, которые при необходимости мы в любой момент сможем сравнить.

При разработке "Literal Optimization V2" необходимо будет решить следующие проблему текущей версии:

1. Громоздкие языковые конфиги на уровне `lg/adapters/<язык>/literals.py`. Конфигурация паттернов `LiteralPattern` слишком плоская (не позволяет по группам исключать или добавлять связанные параметры), плохо подобраны дефолтные значения. В принципе приветствуются любые идеи, как модули `lg/adapters/<язык>/literals.py` сделать компактнее и меньше дублировать конфигурационную шаблонную логику между разными языками.

2. `LanguageLiteralDescriptor` используется почти что просто как контейнер для `patterns: List[LiteralPattern]`. Возможно стоит задуматься о расширении его роли. Возможно можно придумать универсальные флаги, целиком определяющие синтаксис языка в рамках разных паттернов.

3. Частные случаи в ядре, которые полагаются не на четкую конфигурацию, а на хитрые эвристические алгоритмы. В некоторые местах можно было бы сильно упростить код ядра, просто совсем немного расширив конфигурацию. То есть сделав логику более явной.

4. Ядро в изначальной схеме слишком простое. Поэтому все особые языковые нюансы в него добавлены, как бы сбоку. Они не были учтены с самого начала.

5. Внутренняя ER-модель ядра слишком бедная. Часто передается сквозным образом между методами слишком крупный кусок данных в виде `LiteralPattern`.

## Текущая структура и недостатки (v1)
- Файлы (`wc -l`): `handler.py` 905, `block_init.py` 778, `formatter.py` 585, `parser.py` 522, `selector.py` 556, `core.py` 394, `categories.py` 198, `descriptor.py` 29, `__init__.py` 31 (всего ~3998 строк).
- Недостатки:
  - Монолитные модули (handler/block_init/formatter/parser/selector) с большим объёмом кода и пересекающимися обязанностями.
  - Много эвристик и частных случаев, не выразимых через конфиг; языковые особенности вшиты в код.
  - Плоский `LiteralPattern`, слабая ER-модель, `LanguageLiteralDescriptor` — фактически контейнер.
  - Повторяющаяся логика между языковыми модулями `literals.py`, отсутствие групповых профилей и наследования.

## Новая структура (v2) и как она закрывает проблемы
- Пакет `lg/adapters/optimizations/literals_v2/`:
  - `pattern.py`: иерархия паттернов с профилями (strings/raw/interp, seq, map, factory, block_init, ast_seq), групповые дефолты, наследование/override → решает плоскость конфигов и дубли.
  - `descriptor.py`: `LanguageLiteralDescriptorV2` с языковыми флагами (comment style, raw/template/interp strings, factory wrappers, block_init, ast-seq) и набором профилей → расширяет роль дескриптора, убирает хардкод.
  - `handler.py`: координация без языковых хаков, опора на descriptor → уменьшение эвристик.
  - `parser.py`/`selector.py`/`formatter.py`: поведение определяется конфигом (layout, placeholder, budget, priorities), минимум частных случаев → явная логика.
  - `block_init.py`: общий движок imperative init с настраиваемыми селекторами/placeholder → учет языковых нюансов без хардкода.
  - `ast_sequence.py`: общий движок для AST‑последовательностей (конкатенация строк и т.п.) → учёт специфичных структур через конфиг.
- Адаптеры:
  - Добавить `create_literal_descriptor_v2` и файлы `lg/adapters/<lang>/literals_v2.py`, опирающиеся на базовые профили с минимальными override → компактные конфиги, меньше копипасты.

## Требования и ограничения
- Переключение v1/v2: энв‑флаг в `lg/adapters/code_analysis.py`.
- Метрики: без новых ключей.
- Формат плейсхолдеров и комментариев: сохраняем существующий.
- Покрытие: сразу все 10 языков.
- Код строго типизирован; комментарии/докстринги — на английском (план — на русском).

## Этапы работ
1) Каркас `literals_v2` (типы, descriptor, handler, parser/selector/formatter, block_init, ast_sequence) + базовые профили.
2) Интегрировать энв‑флаг в `code_analysis.py`, оставить v1 по умолчанию.
3) Добавить `create_literal_descriptor_v2` и `literals_v2.py` во все языки, используя профили v2.
4) Проверить на имеющихся примерах/тестах без изменения метрик и формата плейсхолдеров.
5) Финальная чистка/упрощение конфигов, проверка дефолтов.

