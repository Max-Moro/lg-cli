# Архитектура Literals Optimization

Подсистема оптимизации литералов для языковых адаптеров является наиболее сложной и развитой. Это обусловлено тем, что реальные языки программирования достаточно сильно отличаются правилами и синтаксисом декларации различных литералов. Данная система позволяет настраивать паттерны литералов в декларативном формате, вместо подхода через индивидуальные императивные хуки в каждом конечном языковом адаптере. Но из-за этого ей приходится учитывать множество особенностей и нюансов адаптации под конкретные потребности языков.

## Основная структура подсистемы оптимизации литералов

```
lg/adapters/optimizations/literals/
├── components/                 # Компоненты
│   ├── __init__.py
│   ├── block_init.py           # общий движок imperative init с настраиваемыми селекторами/placeholder → учет языковых нюансов без хардкода.
│   ├── ast_sequence.py         # общий движок для AST‑последовательностей (конкатенация строк и т.п.) → учёт специфичных структур через конфиг.
│   └── …  	                    # Множество других компонентов
├── processing/                 # Стадии процессинга
│   ├── __init__.py
│   ├── pipeline.py             # LiteralPipeline (main entry point)
│   ├── parser.py               # ContentParser (unified parsing)
│   ├── selector.py             # BudgetSelector (token selection)
│   └── formatter.py            # ResultFormatter
├── __init__.py
├── descriptor.py               # Декларативная модель описания литералов в конечных языковых адаптерах
├── element_parser.py           # Универсальный утилитарный модуль — парсер внутреннего содержимого одного элемента.
└── patterns.py                 # Иерархия паттернов (конечные типы литералов и их параметры), которая используется в декларативной модели
```

Ниже подробно описано разделение логики по сферам ответственности.

### Пакет стадий процессинга 

В пакете `processing/` располагается логика последовательных универсальных крупных стадий пайплайна. Они линейно выстраиваются друг за другом и используются во всех языковых адаптерах.

### Пакет компонентов

Отдельные компоненты в `components/` отвечают за особые частные случаи и ситуации, встречающиеся только в отдельных литералах или только в отдельных языках программирования. Обычно они подключаются к централизованном пайплайну в особых ситуациях, где действительно нужна более тонкая расширенная обработка. 

### Основной оркестратор

Модуль `processing/processing/`. Централизованная точка управления пайплайном (**только высокоуровневая оркестрация**):

- Управление двухпроходной логикой
- Вызовы логики компонентов из `components/` и отдельных стадий пайплайна из `processing/`
- Создание и первичное конфигурирование компонентов и стадий пайплаяна, внедрение зависимостей

Оркестратор не должен содержать никакую детальной логику парсинга/форматирования/бюджетирования.

### Корневой пакет

Корневой пакет `literals/` содержит общую декларативную модель данных, дополнительную ER-модель для перемещания нужных данных между стадиями пайплайна. Также корневой пакет содержит универсальные утилитарные модули, которые могут использоваться разными компонентами или стадиями пайплайна.
