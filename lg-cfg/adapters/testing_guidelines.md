# Рекомендации по тестированию при итеративном рефакторинге Literal Optimization

## Базовый инструмент
- Использовать `./scripts/test_adapters.sh` (работает по оптимизациям и языкам, обновление голденов опционально).
- Ключи: `OPTIMIZATIONS` (`literals` группирует все literal*), `LANGUAGES`, `UPDATE_GOLDENS` (`true|false`).

## Режимы запуска
- Все языки, literals (без обновления голденов):
  `./scripts/test_adapters.sh literals all`
- Точечно по языкам:
  `./scripts/test_adapters.sh literals java,scala,go`
- Перегенерация голденов (только для локальной диагностики, после — откатывать):
  `./scripts/test_adapters.sh literals rust true`

## Политика работы с голденами
- **Цель — нулевые расхождения**: любые изменения в голденах считаются регрессией, их нужно устранять.
- Если требуется посмотреть расхождения: временно запустить с `literals all true`, затем сравнить `git diff` и откатить изменения голденов.
- **Никогда не коммитить изменённые голдены без явного понимания причины** - это означает регрессию.

## Контрольные точки для каждого подэтапа

### Обязательные шаги после любого изменения кода:

1. **Запуск тестов в соответствующем scope**:
   - Изменения только в Python → `./scripts/test_adapters.sh literals python`
   - Изменения в 2-3 языках → `./scripts/test_adapters.sh literals python,java,go`
   - Изменения в инфраструктуре (descriptor.py, patterns.py) → `./scripts/test_adapters.sh literals all`
   - Изменения в ядре (handler, formatter, selector) → `./scripts/test_adapters.sh literals all`

2. **Критерий успеха**:
   - Все тесты в scope должны пройти: `N passed in X.XXs`
   - Никаких изменений в goldens: `git status` не должен показывать modified файлы в `tests/adapters/*/goldens/`

3. **При успехе**:
   - Сделать коммит с описанием подэтапа
   - Перейти к следующему подэтапу

4. **При неудаче**:
   - Проанализировать падения (см. секцию "Диагностика")
   - Если проблема системная - откатить через `git restore .`
   - Скорректировать подэтап или разбить на более мелкие шаги
   - Обновить roadmap если требуется изменение плана

## Стратегии тестирования в зависимости от типа изменения

### 1. Добавление новой инфраструктуры (классы, функции) без использования
**Примеры**: Создание patterns.py, добавление LanguageSyntaxFlags как опционального поля

**Стратегия**:
- Запуск: `./scripts/test_adapters.sh literals all`
- Ожидание: 100% тестов проходят без изменений (новый код не используется)
- Если падают - значит сломали импорты или совместимость

### 2. Миграция одного языка на новую модель
**Примеры**: Миграция Python на StringProfile, миграция Java на FactoryProfile

**Стратегия**:
- Запуск: `./scripts/test_adapters.sh literals <язык>`
- Ожидание: Все тесты языка проходят, голдены не меняются
- Дополнительно: после успеха запустить `literals all` для проверки отсутствия side effects

### 3. Миграция группы языков
**Примеры**: Миграция C/C++, миграция JVM-языков (Java/Kotlin/Scala)

**Стратегия**:
- Мигрировать языки последовательно, по одному
- После каждого языка: `./scripts/test_adapters.sh literals <язык>`
- После всей группы: `./scripts/test_adapters.sh literals <lang1>,<lang2>,<lang3>`
- Финальная проверка: `./scripts/test_adapters.sh literals all`

### 4. Изменения в ядре (core, handler, formatter, selector)
**Примеры**: Рефакторинг parser для работы с профилями, вынос форматирования

**Стратегия**:
- Всегда запускать: `./scripts/test_adapters.sh literals all`
- Любое изменение в ядре потенциально затрагивает все языки
- При падениях - локализовать проблемный язык: `./scripts/test_adapters.sh literals <lang>`

### 5. Добавление новых компонентов
**Примеры**: Компонент interpolation, ast_sequence, block_init

**Стратегия**:
- Запуск: `./scripts/test_adapters.sh literals all`
- Если компонент специфичен для языков - дополнительно точечная проверка:
  - `block_init` → `literals java,rust`
  - `interpolation` → `literals python,javascript,typescript,kotlin,scala`
  - `ast_sequence` → `literals c,cpp`

### 6. Удаление legacy кода
**Примеры**: Удаление core.py/handler.py, удаление LiteralPattern

**Стратегия**:
- Обязательно: `./scripts/test_adapters.sh literals all`
- Это критическое изменение - должны пройти все тесты
- Рекомендуется сделать коммит отдельно от других изменений

## Диагностика падений

### Быстрая локализация проблемы

1. **Определить scope падений**:
   - Падает один язык → проблема в language descriptor
   - Падают все языки → проблема в инфраструктуре или ядре
   - Падают языки с определённым паттерном (например, только с factory methods) → проблема в конкретном профиле

2. **Анализ одного теста с подробным выводом**:
   ```bash
   pytest tests/adapters/<lang>/test_literals.py::<TestClass>::<test_name> -vv
   ```

3. **Сравнение с ожидаемым форматом**:
   - Посмотреть diff в выводе теста
   - Если формат плейсхолдера изменился - нарушена backward compatibility
   - Если литерал не обрезается - проблема в pattern matching или query

### Частые проблемы

**Проблема**: Плейсхолдер в неправильной позиции
- **Симптом**: Expected `// … (N more)` внутри, got `"…",` + comment after
- **Причина**: Неправильный `PlaceholderPosition` в профиле
- **Решение**: Проверить какой формат используется в golden, скорректировать профиль

**Проблема**: Литерал вообще не обрезается
- **Симптом**: В результате полный литерал без плейсхолдера
- **Причина**: Tree-sitter query не матчится или pattern не создаётся
- **Решение**: Проверить query синтаксис, добавить debug logging в pattern matching

**Проблема**: Ломается синтаксис после обрезки (raw strings)
- **Симптом**: Делимитеры raw string не сохраняются (Go backtick, Rust r#"#, C++ R"()")
- **Причина**: Функции detect_opening/detect_closing работают неправильно
- **Решение**: Проверить реализацию detection функций для raw strings

### Временные техники диагностики

- При сложных падениях не трогать реальные голдены: писать временные тесты без голден-инфраструктуры с подробным логированием
- Временно добавлять логирование в продуктовый код (print/logging) и убирать после фикса
- Разрешено подсмотреть старую реализацию v1 для локализации регрессии, но итоговое решение должно соответствовать новой архитектуре
- Использовать `git diff` с временным обновлением голденов для визуализации изменений

### Стратегия при множественных падениях (>10)

1. Сгруппировать падения по типу (golden vs edge case, по языкам, по типу literal)
2. Взять самый простой failing test и решить его
3. Перезапустить тесты - часть может исправиться автоматически
4. Если проблема системная (например, во всех sequence) - исправлять в инфраструктуре, не точечно
5. Если после исправления инфраструктуры остаётся >5 падений - откатить и пересмотреть подэтап

## Откат изменений

### Когда нужен откат:
- Больше 5-10 падающих тестов после изменения
- Системная проблема, требующая переделки подхода
- Изменения в goldens у большинства языков (>5)
- Непонятная причина падений после 15-20 минут анализа

### Как откатить:
```bash
# Откат всех изменений
git restore .

# Проверка что вернулись к baseline
./scripts/test_adapters.sh literals all
# Должно быть: N passed (все тесты проходят)
```

### После отката:
1. Проанализировать что пошло не так
2. Разбить подэтап на более мелкие шаги
3. Обновить roadmap если требуется
4. Начать заново с более атомарным изменением

## Быстрые проверки

### Перед началом нового подэтапа:
```bash
# Убедиться что baseline чистый
git status  # должно быть: working tree clean
./scripts/test_adapters.sh literals all  # должно быть: 100 passed
```

### После завершения подэтапа:
```bash
# Проверить scope изменения
./scripts/test_adapters.sh literals <scope>  # должно быть: N passed

# Проверить что нет изменений в goldens
git status  # не должно быть modified файлов в tests/adapters/*/goldens/

# Закоммитить
git add <modified_files>
git commit -m "Stage X.Y: <description>"
```

### Перед финальным коммитом крупного этапа:
```bash
# Полная проверка
./scripts/test_adapters.sh literals all  # должно быть: 100 passed
git status  # working tree должен быть clean кроме staged changes
```

## Форматирование вывода
- Скрипт сам печатает список тестовых файлов; использовать это для быстрой фильтрации проблемных тестов.
- В pytest output искать секцию `short test summary info` для быстрого обзора падений
- Использовать `-vv` флаг для детального вывода одного теста при диагностике
