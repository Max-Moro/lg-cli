# Plan: Unified Placeholder System with Extended TRUNCATE

## Problem Statement

Currently there is logic duplication between three optimization subsystems:

1. **PlaceholderManager** — handles OMIT/TRUNCATE with auto-generated placeholder text
2. **CommentOptimizer** — handles "transform" action by calling `editor.add_replacement()` directly
3. **LiteralPipeline** — completely bypasses PlaceholderManager, uses `editor.add_replacement_composing_nested()` + `editor.add_insertion()`

## User Decisions

1. **Literals** — унифицировать, перевести на PlaceholderManager
2. **Naming** — оставить `TRUNCATE`, это бизнес-термин для сокращения контента

## Proposed Solution

### PlaceholderAction Semantics

```python
class PlaceholderAction(Enum):
    OMIT = "omitted"       # Complete removal → auto-generated placeholder comment
    TRUNCATE = "truncated"  # Partial reduction → explicit replacement_text required
```

### Extended PlaceholderSpec

```python
@dataclass
class PlaceholderSpec:
    start_char: int
    end_char: int
    element_type: str
    action: PlaceholderAction = PlaceholderAction.OMIT
    placeholder_prefix: str = ""
    count: int = 1
    lines_removed: int = 0

    # NEW: For TRUNCATE action — the shortened content
    replacement_text: Optional[str] = None

    # NEW: Flag to add suffix comment after element (auto-generated by PlaceholderManager)
    add_suffix_comment: bool = False
```

### Behavior Matrix

| Action | replacement_text | add_suffix_comment | Result |
|--------|------------------|--------------------|--------|
| OMIT | None | True | `// … element_type omitted` (standard case) |
| OMIT | None | False | Element removed completely, no comment |
| TRUNCATE | None | True | `// … element_type truncated` (function bodies) |
| TRUNCATE | None | False | Element removed completely, no comment |
| TRUNCATE | "text" | True | "text" + `// … element_type truncated` after |
| TRUNCATE | "text" | False | "text" only, no comment |

### Key Insight: replacement_text is Optional for TRUNCATE

- `replacement_text=None` → PlaceholderManager generates placeholder comment
- `replacement_text="..."` → Direct replacement with provided text

This allows:
- **Function bodies**: TRUNCATE with `replacement_text=None` → auto-generated `// … function body truncated`
- **Comments**: TRUNCATE with `replacement_text="shortened text"` → direct replacement
- **Literals**: TRUNCATE with `replacement_text="trimmed literal"` → direct replacement

### add_suffix_comment Usage by Optimization

| Optimization | Action | add_suffix_comment | Reason |
|-------------|--------|-------------------|--------|
| Function bodies | OMIT | True | Need placeholder comment |
| Function bodies | TRUNCATE | True | Need placeholder comment (embedded in body) |
| Comments | OMIT | True | Need placeholder comment |
| Comments | TRUNCATE | False | Just shortened text, no extra indication |
| Literals | TRUNCATE | Depends on PlaceholderPosition | END/INLINE → True; MIDDLE_COMMENT/NONE → False |

### Suffix Comment Auto-Generation

PlaceholderManager generates suffix comment text automatically:
- Format: `// … {element_type} {action.value}`
- Only generated if `add_suffix_comment=True` AND `placeholder_style != "none"`
- Uses context-aware positioning (skip brackets, semicolons, commas)

### Key Architecture Change: PlaceholderManager owns Editor

Currently:
```python
# In code_base.py
collapsed_edits, stats = context.placeholders.finalize_edits()
for spec, repl in collapsed_edits:
    context.editor.add_replacement(...)
```

New approach:
```python
# PlaceholderManager receives editor reference
class PlaceholderManager:
    def __init__(self, doc, comment_style, placeholder_style, editor: RangeEditor):
        self.editor = editor
        ...

    def apply_to_editor(self) -> Dict[str, Any]:
        """Apply all placeholders to editor, return stats."""
        # Uses add_replacement_composing_nested for proper nesting support
```

This enables:
1. **Composing nested placeholders** — literals inside literals handled correctly
2. **Suffix comment insertion** — PlaceholderManager adds insertions after replacements
3. **Single responsibility** — all placeholder-related edits in one place

## Files to Modify

### Core Changes

1. **`lg/adapters/placeholders.py`**
   - Add `replacement_text: Optional[str] = None` to PlaceholderSpec
   - Add `add_suffix_comment: bool = False` to PlaceholderSpec
   - Add `editor: RangeEditor` to PlaceholderManager.__init__
   - New method `apply_to_editor()` that:
     - Collapses placeholders (existing logic)
     - For OMIT/TRUNCATE with `replacement_text=None`: generates placeholder text
     - For TRUNCATE with `replacement_text`: uses provided text
     - Calls `editor.add_replacement_composing_nested()` for all cases
     - If `add_suffix_comment=True`: calls `editor.add_insertion()` after main edit
   - Remove `finalize_edits()` return of edit tuples (now returns only stats)
   - Add `_find_insertion_point()` logic (migrate from literals/utils/comment_formatter.py)

2. **`lg/adapters/context.py`**
   - Update `ProcessingContext.from_lightweight()` to pass editor to PlaceholderManager
   - Update `add_placeholder()` to accept `replacement_text` and `add_suffix_comment`
   - Update `add_placeholder_for_node()` similarly

3. **`lg/adapters/code_base.py`**
   - Update `_finalize_placeholders()` to call `context.placeholders.apply_to_editor()`
   - Remove manual loop applying edits to editor

### Optimization Updates

4. **`lg/adapters/optimizations/function_bodies/optimizer.py`**
   - `_apply_trim()`: Change to pass `replacement_text` with kept_prefix + placeholder + kept_suffix
   - No need for trimmer to return TrimResult with positions — just the composed text

5. **`lg/adapters/optimizations/comments/optimizer.py`**
   - `_apply_decision()` "transform" case: Use `context.add_placeholder_for_node()` with `replacement_text`
   - Remove direct `editor.add_replacement()` call

6. **`lg/adapters/optimizations/literals/processing/pipeline.py`**
   - `_apply_result()`: Change from `editor.add_replacement_composing_nested()` + `editor.add_insertion()`
     to `context.add_placeholder()` with `replacement_text` and `add_suffix_comment`
   - Determine `add_suffix_comment` based on profile's `PlaceholderPosition` (END/INLINE → True)
   - Remove direct editor calls

### Affected but unchanged (use default OMIT)

- `lg/adapters/optimizations/imports/optimizer.py` — no changes needed
- `lg/adapters/optimizations/public_api.py` — no changes needed

## Design Details

### Unified Placeholder/Comment Generation

PlaceholderManager uses the same `_get_placeholder_content()` logic for both:
1. **Inline placeholder** (when `replacement_text=None`) — replaces the element
2. **Suffix comment** (when `add_suffix_comment=True` and `replacement_text` is provided) — inserted after element

```python
def _get_placeholder_content(self, spec: PlaceholderSpec) -> str:
    """
    Generate placeholder/comment content.
    Used for both inline placeholders and suffix comments.
    """
    parts = ["…"]

    # Count prefix for multiple elements
    show_count = spec.count > 1 and spec.element_type not in ("comment", "docstring")
    if show_count:
        parts.append(str(spec.count))

    # Element type
    display_type = spec.element_type.replace("_", " ")
    display_type = _pluralize(display_type, spec.count) if show_count else display_type
    parts.append(display_type)

    # Action word
    parts.append(spec.action.value)

    # Lines suffix
    if spec.lines_removed > 1 and spec.lines_removed != spec.count:
        parts.append(f"({spec.lines_removed} lines)")

    return " ".join(parts)
```

### Suffix Comment Positioning (for literals)

When `add_suffix_comment=True` and `replacement_text` is provided, PlaceholderManager:
1. Applies replacement_text to element position
2. Inserts auto-generated comment AFTER the element using context-aware positioning

```python
def _format_and_position_suffix_comment(self, spec: PlaceholderSpec, text_after: str) -> tuple[str, int]:
    """Position suffix comment based on surrounding code context."""
    content = self._get_placeholder_content(spec)

    line_remainder = text_after.split('\n')[0]
    offset, needs_block = self._find_insertion_point(line_remainder)

    if needs_block:
        return f" {self.comment_style.multi_line[0]} {content} {self.comment_style.multi_line[1]}", offset
    return f" {self.comment_style.single_line} {content}", offset
```

The `_find_insertion_point()` logic handles:
- Skipping closing brackets `)]}`
- Skipping semicolons and commas
- Determining if block comment is needed (code follows on same line)

### Placeholder Collapsing with TRUNCATE

Current collapsing merges adjacent OMIT placeholders of same type.
For TRUNCATE placeholders:
- **Do NOT collapse** — each has unique replacement_text
- Add check in `can_merge_with()`: return False if action is TRUNCATE

## Risk Assessment

- **Medium complexity**: Literals migration requires careful handling of nesting
- **Good test coverage**: Extensive golden tests protect against regressions
- **Backward compat**: OMIT behavior unchanged, existing callers continue to work
- **Rollback strategy**: Each phase can be tested independently
