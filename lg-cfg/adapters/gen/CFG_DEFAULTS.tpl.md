### Короткий ответ
Если в YAML для языка не указано никаких настроек, адаптер берёт свои дефолты. Это значит:
- Никакой агрессивной “чистки” кода (публичное API, тела функций, импорты, комментарии) по умолчанию не включается.
- Включена только «умная» обрезка больших литералов (строки/массивы/объекты) по безопасным порогам.
- Языковые эвристики пропуска некоторых файлов по умолчанию активны: `__init__.py` (тривиальные) для Python и barrel-файлы для TypeScript.

### Что именно по умолчанию
- Конфиг создаётся как “пустой” для конкретного языка:
  - Python: `PythonCfg()` с `skip_trivial_inits: true`.
  - TypeScript: `TypeScriptCfg()` с `skip_barrel_files: true`.
  - Общая часть (`CodeCfg`) с дефолтами:
    - public_api_only: false
    - strip_function_bodies: false
    - comment_policy: "keep_all"
    - import_config: policy="keep_all"
    - literal_config: строки/массивы/объекты режутся по порогам (см. ниже)
    - placeholders: mode="summary", style="auto"
    - budget: None (нет лимита токенов)

### Поведение пайплайна по умолчанию (пошагово)
1) Попадание файла в обработку:
- Python: тривиальные `__init__.py` пропускаются (пусто, `pass`, `...`, реэкспорт через относительные `from` и `__all__` — только это).
- TypeScript: «barrel» файлы с реэкспортами (особенно `index.ts/tsx`) пропускаются.

2) Парсинг Tree-sitter (Python/TS): документ разбирается в AST, готов для запросов.

3) Оптимизации:
- Public API: выключено (никакие приватные/внутренние элементы не вырезаются).
- Тела функций/методов: выключено (всё остаётся как есть).
- Комментарии: policy="keep_all" — ничего не удаляется.
- Импорты: policy="keep_all" — ничего не сворачивается и не режется.
- Литералы: включено «бережное» ужатие по порогам:
  - Строки: если длина > 200 символов — укорачиваются c `...`; если общий размер > 100 байт — могут заменяться «сжатой» версией вида `"… (N bytes)"`.
  - Массивы: если > 20 элементов — показана «превью»-часть с `... and N more`; если > 10 строк — сворачиваются в `"[... X elements]"`.
  - Объекты: если > 15 свойств — аналогично «превью» + `... and N more`; если > 10 строк — `"{... X properties}"`.
- Плейсхолдеры: стиль "auto" → однострочные комментарии языка:
  - Python: `# … comment omitted`, `# … body omitted (-N)` и т. п.
  - TypeScript: `// … comment omitted` или блоки `/* … */` там, где используется блочный стиль.  
  Примечание: по умолчанию импорты/комментарии/тела не режутся, поэтому плейсхолдеры возникнут в основном при ужатии больших литералов.

4) Метаданные:
- В `meta` всегда будет `_adapter` (`"python"`/`"typescript"`), параметры группы (`_group_size`, `_group_mixed`) и счётчики только по реально сработавшим оптимизациям (в дефолте обычно видны `code.removed.literals` и экономия байт/строк, если были большие литералы).

### Итоги по языкам (без YAML-настроек)
- Python:
  - Пропуск тривиальных `__init__.py`: да (включено).
  - Тела функций/методов: не удаляются.
  - Комментарии: сохраняются.
  - Импорты: сохраняются.
  - Литералы: большие — ужимаются по порогам (200 символов/10 строк/размер 100 байт и т. п.).
- TypeScript:
  - Пропуск barrel-файлов: да (включено).
  - Тела функций/методов: не удаляются (кроме случаев, когда вы явно включите).
  - Комментарии: сохраняются.
  - Импорты: сохраняются.
  - Литералы: большие — ужимаются по тем же порогам.

Если для расширения нет специализированного адаптера, используется базовый (`BaseAdapter`) — файл остаётся без изменений.

- Короткий вывод:
  - По умолчанию вы получаете максимально «бережный» режим: структура кода и сигнатуры не трогаются, комментарии и импорты не режутся, но чрезмерные литералы аккуратно сжимаются. Плюс работают безопасные эвристики пропуска «мусорных» служебных файлов (Python `__init__.py` и TS barrel).

- Важные пороги (дефолт):
  - Строка: >200 символов или >100 байт — трим/коллапс.
  - Массив: >20 элементов или >10 строк — трим/коллапс.
  - Объект: >15 свойств или >10 строк — трим/коллапс.

- Плейсхолдеры в «auto» стиле — в одну строку, в синтаксисе комментариев языка.

- Никакого бюджетирования токенов и приоритизации по умолчанию нет (M6 ещё не включён конфигом).

- Никаких изменений в публичности/телах функций/импортах/комментариях не происходит, пока вы это явно не включите в YAML.

- Для Python и TS по умолчанию активны только «умные» пропуски «малоценного» служебного файла (`__init__.py`/barrel), плюс трим больших литералов.

- Метаданные отчётов будут содержать только фактически применённые оптимизации (в дефолте — чаще всего про литералы).