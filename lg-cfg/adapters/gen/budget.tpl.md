## Listing Generator — Budget System

### Цель

Ввести «пофайловую» систему бюджетирования токенов при генерации листингов: если обработанный файл превышает заданный лимит токенов, к нему последовательно применяются всё более сильные оптимизации в фиксированном порядке приоритетов до тех пор, пока размер не уложится в бюджет или не исчерпаны рычаги сжатия.

Система сохраняет читабельность и полезность контекста: не удаляет публичные сигнатуры и документацию целиком, а в крайнем случае сокращает документацию до первого предложения.

---

### Ключевые принципы

- Пер‑файл: бюджет применяется независимо к каждому файлу.
- Эскалация по приоритетам: оптимизации включаются ступенчато по предопределённой цепочке.
- Уважение пользовательских настроек: пользовательские политики (из секции адаптера) «встраиваются» в цепочку там, где им логически соответствует место, и являются отправной точкой для эскалации.
- Гарантии: публичные сигнатуры и их докстринги не удаляются; документация не вырезается полностью — в крайнем шаге сокращается до первого предложения.
- Система бюджета работает в изолированной песочнице, она работает по упрощенной схеме ( с отключенными плейсхолдерами) и лишь подбирает оптимальный конфиг для итогового прогона всех оптимизаторов

---

### Точки конфигурации (YAML)

В базовой модели `CodeCfg` поле `budget` расширяется и активирует бюджетный режим для файла:

```yaml
python:
  budget:
    max_tokens_per_file: 1200          # жёсткий лимит на файл; None — отключено
    priority_order:                     # необязательно; если опущено — используется дефолт
      - imports_external
      - literals
      - comments
      - imports_local
      - private_bodies
      - public_api_only
      - public_bodies
      - docstrings_first_sentence
```

Примечания:
- `priority_order` — пользователь может переопределить порядок. Если не задано, используется «сбалансированный» дефолт (см. ниже).
- `comments.max_tokens` — параметр заменяет прежний `max_length` и используется токен‑осознанно.
- `literals.levels` — (необязательно на первой итерации) ступени ужатия для крупного контента; если отсутствуют — применяется единый `literals.max_tokens`.

---

### Цепочка приоритетов по умолчанию

Сбалансированный порядок (без пресетов):

1) imports_external — удалить/свернуть внешние импорты и длинные группы импортов
2) literals — урезать крупные литералы (строки/массивы/объекты), последовательно перебирает уровни ужатия `max_tokens` по `[512, 256, 128, 64, 32]` (начиная с менее `max_tokens_per_file`).
3) comments — удалять крупные НЕ‑док комментарии (по токенам), докстринги сохранять, последовательно перебирает уровни ужатия `max_tokens` (аналогично literals).
4) imports_local — удалять/сворачивать локальные импорты
5) private_bodies — убирать тела приватных функций/методов (с сохранением сигнатур)
6) public_api_only — включать режим «только публичный API», скрывая внутренние приватные элементы
7) public_bodies — как крайняя мера убирать тела публичных функций/методов (сигнатуры и докстринги остаются)
8) docstrings_first_sentence — финально ужимать докстринги до 1‑го предложения

Обоснование: сначала дешёвые и безопасные рычаги (импорты, литералы, комментарии), затем более «разрушающие» (тела, сужение до публичного API), и только в самом конце — сокращение документации.

---

### Механизм работы контроллера бюджета

Контроллер бюджета работает до фактической `_apply_optimizations`. Он не является ее этапом, а скорее является механизмом корректировки и подбора оптимального стартового конфига для реальной работы `_apply_optimizations`.
Контроллер бюджета во время своей работы отключает систему плейсхолдеров (переводит на `none`), чтобы они не влияли на итоговый расчет токенов.

Контроллер бюджета иденпотентный — это чистая функция. он лишь подбирает итоговый конфиг `CodeCfg` для финальной работы `lg.adapters.code_base.CodeAdapter._apply_optimizations`. Он работает в изолированной песочнице. Его результатом является скорректированная конфигурация всех оптимизаторов внутри `CodeCfg`, но сырой текст документа остаются нетронутыми. Систему бюдщема можно вызывать многократно, без возникновения сайдэффектов.

Контроллер бюджета работает по системе инкрементальной эскалации. Он держит текущее состояние текста и применяет только нужные оптимизаторы на каждом шаге, без повторного полного прогона всех оптимизаций. Свою работу он начинает с применения всех базовых пользовательских политик и берет это за начальную точку эскалации.

Контроллер бюджета НИ В КОЕМ СЛУЧАЕ не должен вызывать `adapter._apply_optimizations` и уже тем более `adapter._finalize_placeholders`. Он сам знает о существовании всех конкретных оптимизаторов из пакета `lg/adapters/optimizations` и вызывает конкретно их с нужной конфигурацией. Также текущее состояние текста он сам вручную получает из `new_text, _ = context.editor.apply_edits`. Также контроллер бюджета сам пересоздает на каждом шаге Tree-sitter документ `context.doc = self.adapter.create_document(new_text, context.ext)`.

### Поведение относительно пользовательских настроек

Пользовательские опции адаптеров задают исходное состояние шагов. Бюджетный контроллер определяет точку входа в цепочку и эскалирует дальше:

- Если пользователь уже включил «imports.strip_external», бюджет начнёт хотя бы с подтверждения этого шага и, при необходимости, двинется к «imports_local».
- Если пользователь указал `strip_function_bodies: true`, бюджет может перескочить сразу к шагу 5/7 как к исходному состоянию и далее включить «public_api_only» и «docstrings_first_sentence» при необходимости.
- Для комментариев и литералов пользовательские лимиты считаются стартовыми; бюджет может ввести более жёсткий уровень (напр., меньший `max_tokens` у литералов) только на соответствующем шаге цепочки.

Правило: бюджет имеет право усиливать оптимизации сверх пользовательских настроек, но только вдоль цепочки приоритетов.

### Смысл уровней для оптимизаций `imports` и `literals`
Система уровней по «max_tokens» должна работать для literals и comments.

На самом деле уровни для этих оптимизация являются полноценными шагами в системе приорететов (просто явно пользователем не конфигурируются), точнее конфигурируются им не явно, через ручное задание `max_tokens` в конфигах. По сути пользовательский `max_tokens` является стартовой точкой в системе уровней, а далее находится ближайшая меньшая степень двойки и идет обычная степенная прогрессия (на уменьшение).

Уровни нужны, чтобы система бюджета не применяла сразу слишком жесткие политики для данных оптимизаций, а вовремя могла остановится, если общий бюджет на файл уже был достигнут.

---

## Алгоритм BudgetController (упрощенный псевдокод)

```python
class BudgetController:
    def __init__(self, adapter: CodeAdapter, tokenizer: TokenService, cfg_budget: BudgetConfig):
        self.adapter = adapter
        self.tokenizer = tokenizer
        self.cfg_budget = cfg_budget

    def fit_config(self, lightweight_ctx, base_cfg: CodeCfg) -> Tuple[CodeCfg, Dict[str, int]]:
        # TODO Создание sandbox_context из lightweight_ctx

        # TODO Прогоняем пользовательские конфигурации

        # TODO Быстрый выход, если от пользовательских настроек уже достигли бюджета
        
        # TODO Рассчитываем шаги, которые точны более эскалируемые,Ю чем пользовательское начальное состояние
        order = self._resolve_priority_order()

        for step in order: # Включая подуровни для literals и comments
            self._apply_step(step, sandbox_context)
            # промежуточный commit‑and‑reseed
            new_text, _ = sandbox_context.editor.apply_edits()
            sandbox_context.raw_text = new_text
            sandbox_context.doc = self.adapter.create_document(new_text, context.ext)
            sandbox_context.editor = RangeEditor(new_text)

            tokens = self.tok.count_text(new_text)
            if tokens <= limit:
                break
        
        return current_cfg, metrics
```

`_apply_step(step, context)`
- imports_external: включить/усилить политику импортов для внешних пакетов (strip/summarize)
- literals: уменьшить потолок для литералов (на уровень уровням, new_text подменяет только при исчерпании уровней или попадании в лимит)
- comments: удалить недок‑комментарии (на уровень уровням, new_text подменяет только при исчерпании уровней или попадании в лимит)
- imports_local: применить политику к локальным импортам
- private_bodies: включить/усилить удаление тел приватных функций/методов
- public_api_only: включить фильтрацию скрывающую приватные элементы
- public_bodies: как крайняя мера — удалить тела публичных функций/методов (сигнатуры и докстринги оставляем)
- docstrings_first_sentence: применить «первое предложение» на докстринги

Важно: реализация шагов в M7 использует уже существующие оптимизаторы; шаг лишь переключает их режимы/параметры в более «жёсткие» значения.

Когда мы проходим по уровням literals и comments, то всегда делаем перерасчет этих оптимизация с базового состояния, не подменяя
new_text. Иначе локальные бюджеты `max_tokens` будут сравниваться c уже затримленными данными комментариев или литералов, что некорректно. 

---

### Метрики и телеметрия

Каждый файл дополняется метаданными (в `ProcessedBlob.meta` через `MetricsCollector` и/или BudgetController):

```json
{
  "<lang>.budget.tokens_before": 3120,
  "<lang>.budget.tokens_after": 1184,
  "<lang>.budget.steps.imports_external": 420,
  "<lang>.budget.steps.literals": 980,
  "<lang>.budget.steps.comments": 280,
  "<lang>.budget.steps.imports_local": 180,
  "<lang>.budget.steps.private_bodies": 76
}
```

Минимальные гарантии отчётности:
- токены до/после,
- экономия в токенах на каждом шаге, если он был

---

### Гарантии и ограничения

- Никогда не удаляются публичные сигнатуры и полностью документация.
- Фильтр «экономичности» плейсхолдеров остаётся включён даже в бюджетном режиме — это предотвращает «шумовые» замены с мелким выигрышем.
- Точность токенов: используется текущая модель/энкодер из `TokenService`.