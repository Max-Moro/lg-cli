## Listing Generator — Budget System

### Цель

Ввести «пофайловую» систему бюджетирования токенов при генерации листингов: если обработанный файл превышает заданный лимит токенов, к нему последовательно применяются всё более сильные оптимизации в фиксированном порядке приоритетов до тех пор, пока размер не уложится в бюджет или не исчерпаны рычаги сжатия.

Система сохраняет читабельность и полезность контекста: не удаляет публичные сигнатуры и документацию целиком, а в крайнем случае сокращает документацию до первого предложения.

---

### Ключевые принципы

- Пер‑файл: бюджет применяется независимо к каждому файлу.
- Эскалация по приоритетам: оптимизации включаются ступенчато по предопределённой цепочке.
- Уважение пользовательских настроек: пользовательские политики (из секции адаптера) «встраиваются» в цепочку там, где им логически соответствует место, и являются отправной точкой для эскалации.
- Отсутствие «псевдоэкономии»: фильтр «экономичности» замен сохраняется — плейсхолдеры применяются только при ощутимой экономии токенов.
- Гарантии: публичные сигнатуры и их докстринги не удаляются; документация не вырезается полностью — в крайнем шаге сокращается до первого предложения.

---

### Точки конфигурации (YAML)

В базовой модели `CodeCfg` поле `budget` расширяется и активирует бюджетный режим для файла:

```yaml
python:
  budget:
    max_tokens_per_file: 1200          # жёсткий лимит на файл; None — отключено
    priority_order:                     # необязательно; если опущено — используется дефолт
      - imports_external
      - literals
      - comments
      - imports_local
      - private_bodies
      - public_api_only
      - public_bodies
      - docstrings_first_sentence
```

Примечания:
- `priority_order` — пользователь может переопределить порядок. Если не задано, используется «сбалансированный» дефолт (см. ниже).
- `comments.max_tokens` — параметр заменяет прежний `max_length` и используется токен‑осознанно.
- `literals.levels` — (необязательно на первой итерации) ступени ужатия для крупного контента; если отсутствуют — применяется единый `literals.max_tokens`.

---

### Цепочка приоритетов по умолчанию

Сбалансированный порядок (без пресетов):

1) imports_external — удалить/свернуть внешние импорты и длинные группы импортов
2) literals — урезать крупные литералы (строки/массивы/объекты), последовательно перебирает уровни ужатия `max_tokens` по `[512, 256, 128, 64, 32]` (начиная с менее `max_tokens_per_file`).
3) comments_large — удалять крупные НЕ‑док комментарии (по токенам), докстринги сохранять, последовательно перебирает уровни ужатия `max_tokens`.
4) imports_local — удалять/сворачивать локальные импорты
5) private_bodies — убирать тела приватных функций/методов (с сохранением сигнатур)
6) public_api_only — включать режим «только публичный API», скрывая внутренние приватные элементы
7) public_bodies — как крайняя мера убирать тела публичных функций/методов (сигнатуры и докстринги остаются)
8) docstrings_first_sentence — финально ужимать докстринги до 1‑го предложения

Обоснование: сначала дешёвые и безопасные рычаги (импорты, литералы, комментарии), затем более «разрушающие» (тела, сужение до публичного API), и только в самом конце — сокращение документации.

---

### Поведение относительно пользовательских настроек

Пользовательские опции адаптеров задают исходное состояние шагов. Бюджетный контроллер определяет точку входа в цепочку и эскалирует дальше:

- Если пользователь уже включил «imports.strip_external», бюджет начнёт хотя бы с подтверждения этого шага и, при необходимости, двинется к «imports_local».
- Если пользователь указал `strip_function_bodies: true`, бюджет может перескочить сразу к шагу 5/7 как к исходному состоянию и далее включить «public_api_only» и «docstrings_first_sentence» при необходимости.
- Для комментариев и литералов пользовательские лимиты считаются стартовыми; бюджет может ввести более жёсткий уровень (напр., меньший `max_tokens` у литералов) только на соответствующем шаге цепочки.

Правило: бюджет имеет право усиливать оптимизации сверх пользовательских настроек, но только вдоль цепочки приоритетов.

---

### Архитектура и встраивание

#### Новые компоненты

- BudgetController (уровень адаптера):
  - Входит в состав `CodeAdapter.process()` как дополнительный этап, если `cfg.budget.max_tokens_per_file` задан.
  - Управляет проходами по шагам, обновляет документ между шагами, контролирует остановку, собирает телеметрию.

- Commit‑and‑Reseed:
  - Утилита на базе `ProcessingContext`/`RangeEditor`, выполняющая промежуточное применение правок и пересборку `TreeSitterDocument`:
    1) `editor.apply_edits()`
    2) обновить `context.raw_text`
    3) пересоздать `doc = adapter.create_document(...)` и `editor = RangeEditor(...)`

#### Точки интеграции в существующий код

- `lg/adapters/code_base.py` (CodeAdapter.process):
  1) Построение `ProcessingContext` как сейчас
  2) Применение пользовательских оптимизаций (public_api_only, function_bodies, comments, imports, literals) — текущий порядок без бюджета
  3) Если бюджет выключен → финализация как сегодня
  4) Если бюджет включен → запустить BudgetController с текущим `context` и `tokenizer`
  5) После окончания — вызвать `_finalize_placeholders()` (фильтр экономичности сохраняется)

- `lg/adapters/context.py`:
  - Добавить метод `reseed(new_text: str)` или статический helper для «commit‑and‑reseed»; либо предоставить функцию‑утилиту рядом с RangeEditor.

- `lg/adapters/optimizations/literals.py`:
  - Опциональная поддержка уровней ужатия (список `levels`) для пошагового уменьшения бюджета на литералы.

---

### Алгоритм BudgetController (упрощенный псевдокод)

```python
class BudgetController:
    def __init__(self, adapter, tokenizer, cfg):
        self.adapter = adapter
        self.tok = tokenizer
        self.cfg = cfg

    def run(self, context: ProcessingContext) -> None:
        limit = self.cfg.budget.max_tokens_per_file
        if not limit:
            return

        def count_current():
            # Токены считаем по текущему «видимому» тексту редактора, если есть правки
            # При отсутствии правок — по исходному тексту
            text = context.editor.original_text if not context.editor.edits else context.editor.apply_edits()[0]
            return self.tok.count_text(text)

        tokens = count_current()
        if tokens <= limit:
            return

        order = self._resolve_priority_order()

        for step in order:
            self._apply_step(step, context)
            # промежуточный commit‑and‑reseed
            new_text, _ = context.editor.apply_edits()
            context.raw_text = new_text
            context.doc = self.adapter.create_document(new_text, context.ext)
            context.editor = RangeEditor(new_text)

            tokens = self.tok.count_text(new_text)
            if tokens <= limit:
                break
```

`_apply_step(step, context)`
- imports_external: включить/усилить политику импортов для внешних пакетов (strip/summarize)
- literals: уменьшить потолок для литералов (по уровням)
- comments: удалить недок‑комментарии (по уровням)
- imports_local: применить политику к локальным импортам
- private_bodies: включить/усилить удаление тел приватных функций/методов
- public_api_only: включить фильтрацию скрывающую приватные элементы
- public_bodies: как крайняя мера — удалить тела публичных функций/методов (сигнатуры и докстринги оставляем)
- docstrings_first_sentence: применить «первое предложение» на докстринги

Важно: реализация шагов в M7 использует уже существующие оптимизаторы; шаг лишь переключает их режимы/параметры в более «жёсткие» значения.

Когда мы проходим по уровням literals и comments, то всегда делаем перерасчет этих оптимизация с базового состояния, не подменяя
new_text. Иначе локальные бюджеты `max_tokens` будут сравниваться c уже затримленными данными, что некорректно. 

---

### Метрики и телеметрия

Каждый файл дополняется метаданными (в `ProcessedBlob.meta` через `MetricsCollector` и/или BudgetController):

```json
{
  "<lang>.budget.tokens_before": 3120,
  "<lang>.budget.tokens_after": 1184,
  "<lang>.budget.steps.imports_external": 420,
  "<lang>.budget.steps.literals": 980,
  "<lang>.budget.steps.comments_large": 280,
  "<lang>.budget.steps.imports_local": 180,
  "<lang>.budget.steps.private_bodies": 76
}
```

Минимальные гарантии отчётности:
- токены до/после,
- экономия в токенах на каждом шаге, если он был

---

### Гарантии и ограничения

- Никогда не удаляются публичные сигнатуры и полностью документация.
- Фильтр «экономичности» плейсхолдеров остаётся включён даже в бюджетном режиме — это предотвращает «шумовые» замены с мелким выигрышем.
- Точность токенов: используется текущая модель/энкодер из `TokenService`.

