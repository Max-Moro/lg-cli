## Listing Generator — Budget System

### Цель

Ввести «пофайловую» систему бюджетирования токенов при генерации листингов: если обработанный файл превышает заданный лимит токенов, к нему последовательно применяются всё более сильные оптимизации в фиксированном порядке приоритетов до тех пор, пока размер не уложится в бюджет или не исчерпаны рычаги сжатия.

Система сохраняет читабельность и полезность контекста: не удаляет публичные сигнатуры и документацию целиком, а в крайнем случае сокращает документацию до первого предложения.

---

### Ключевые принципы

- Пер‑файл: бюджет применяется независимо к каждому файлу.
- Эскалация по приоритетам: оптимизации включаются ступенчато по предопределённой цепочке.
- Уважение пользовательских настроек: пользовательские политики (из секции адаптера) «встраиваются» в цепочку там, где им логически соответствует место, и являются отправной точкой для эскалации.
- Гарантии: публичные сигнатуры и их докстринги не удаляются; документация не вырезается полностью — в крайнем шаге сокращается до первого предложения.
- Система бюджета работает в изолированной песочнице, она работает по упрощенной схеме ( с отключенными плейсхолдерами) и лишь подбирает оптимальный конфиг для итогового прогона всех оптимизаторов

---

### Точки конфигурации (YAML)

В базовой модели `CodeCfg` поле `budget` расширяется и активирует бюджетный режим для файла:

```yaml
python:
  budget:
    max_tokens_per_file: 1200          # жёсткий лимит на файл; None — отключено
    priority_order:                     # необязательно; если опущено — используется дефолт
      - imports_external
      - literals
      - comments
      - imports_local
      - private_bodies
      - public_api_only
      - public_bodies
      - docstrings_first_sentence
```

Примечания:
- `priority_order` — пользователь может переопределить порядок. Если не задано, используется «сбалансированный» дефолт (см. ниже).
- `comments.max_tokens` — параметр заменяет прежний `max_length` и используется токен‑осознанно.
- `literals.levels` — (необязательно на первой итерации) ступени ужатия для крупного контента; если отсутствуют — применяется единый `literals.max_tokens`.

---

### Цепочка приоритетов по умолчанию

Сбалансированный порядок (без пресетов):

1) imports_external — удалить/свернуть внешние импорты и длинные группы импортов
2) literals — урезать крупные литералы (строки/массивы/объекты), последовательно перебирает уровни ужатия `max_tokens` по `[512, 256, 128, 64, 32]` (начиная с менее `max_tokens_per_file`).
3) comments — удалять крупные НЕ‑док комментарии (по токенам), докстринги сохранять, последовательно перебирает уровни ужатия `max_tokens`.
4) imports_local — удалять/сворачивать локальные импорты
5) private_bodies — убирать тела приватных функций/методов (с сохранением сигнатур)
6) public_api_only — включать режим «только публичный API», скрывая внутренние приватные элементы
7) public_bodies — как крайняя мера убирать тела публичных функций/методов (сигнатуры и докстринги остаются)
8) docstrings_first_sentence — финально ужимать докстринги до 1‑го предложения

Обоснование: сначала дешёвые и безопасные рычаги (импорты, литералы, комментарии), затем более «разрушающие» (тела, сужение до публичного API), и только в самом конце — сокращение документации.

---

### Механизм работы контроллера бюджета

Контроллер бюджета работает до фактической `_apply_optimizations`. Он не является ее этапом, а скорее является механизмом корректировки и подбора оптимального стартового конфига для реальной работы `_apply_optimizations`.
Контроллер бюджета во время своей работы отключает систему плейсхолдеров (переводит на `none`), чтобы они не влияли на итоговый расчет токенов.

Контроллер бюджета иденпотентный — это чистая функция. он лишь подбирает итоговый конфиг `CodeCfg` для финальной работы `lg.adapters.code_base.CodeAdapter._apply_optimizations`. Он работает в изолированной песочнице. Его результатом является скорректированная конфигурация всех оптимизаторов внутри `CodeCfg`, но сырой текст документа остаются нетронутыми. Систему бюдщема можно вызывать многократно, без возникновения сайдэффектов.

### Поведение относительно пользовательских настроек

Пользовательские опции адаптеров задают исходное состояние шагов. Бюджетный контроллер определяет точку входа в цепочку и эскалирует дальше:

- Если пользователь уже включил «imports.strip_external», бюджет начнёт хотя бы с подтверждения этого шага и, при необходимости, двинется к «imports_local».
- Если пользователь указал `strip_function_bodies: true`, бюджет может перескочить сразу к шагу 5/7 как к исходному состоянию и далее включить «public_api_only» и «docstrings_first_sentence» при необходимости.
- Для комментариев и литералов пользовательские лимиты считаются стартовыми; бюджет может ввести более жёсткий уровень (напр., меньший `max_tokens` у литералов) только на соответствующем шаге цепочки.

Правило: бюджет имеет право усиливать оптимизации сверх пользовательских настроек, но только вдоль цепочки приоритетов.

### Смысл уровней для оптимизаций `imports` и `literals`
На самом деле уровни для этих оптимизация являются полноценными шагами в системе приорететов (просто явно пользователем не конфигурируются), точнее конфигурируются им не явно, через ручное задание `max_tokens` в конфигах. По сути пользовательский `max_tokens` является стартовой точкой в системе уровней, а далее находится ближайшая меньшая степень двойки и идет обычная степенная прогрессия (на уменьшение).

Уровни нужны, чтобы система бюджета не применяла сразу слишком жесткие политики для данных оптимизаций, а вовремя могла остановится, если общий бюджет на файл уже был достигнут.

---

### Метрики и телеметрия

Каждый файл дополняется метаданными (в `ProcessedBlob.meta` через `MetricsCollector` и/или BudgetController):

```json
{
  "<lang>.budget.tokens_before": 3120,
  "<lang>.budget.tokens_after": 1184,
  "<lang>.budget.steps.imports_external": 420,
  "<lang>.budget.steps.literals": 980,
  "<lang>.budget.steps.comments": 280,
  "<lang>.budget.steps.imports_local": 180,
  "<lang>.budget.steps.private_bodies": 76
}
```

Минимальные гарантии отчётности:
- токены до/после,
- экономия в токенах на каждом шаге, если он был

---

### Гарантии и ограничения

- Никогда не удаляются публичные сигнатуры и полностью документация.
- Фильтр «экономичности» плейсхолдеров остаётся включён даже в бюджетном режиме — это предотвращает «шумовые» замены с мелким выигрышем.
- Точность токенов: используется текущая модель/энкодер из `TokenService`.