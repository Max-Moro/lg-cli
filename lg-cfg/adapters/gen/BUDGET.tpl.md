### Коротко
Если задан только бюджет (`budget.max_tokens_per_file`) и больше ничего не настроено, включается «адаптивное сжатие по бюджету» поверх дефолтного режима. Логика идёт слоями и по приоритетам, пока каждый файл не уложится в лимит токенов. Никакие «ручные» политики (комментарии, импорты, тела функций) явно не менялись пользователем — но бюджет имеет право мягко переопределять их в заданном порядке важности.

### Как работает по умолчанию при наличии бюджета
- **Что остаётся как раньше:**
  - Python: пропуск тривиальных `__init__.py`.
  - TypeScript: пропуск barrel-файлов.
  - Базовое ужатие литералов (M5) с дефолтными порогами.
- **Что добавляется:**
  - Для каждого файла считаются токены «после обработок» (используется выбранная модель из CLI `--model`, по умолчанию `o3`).
  - Если токены ≤ бюджет — файл не трогаем.
  - Если токены > бюджет — запускается «бюджет‑редуктор» слоями по нисходящему приоритету сохранности содержимого.

### Порядок сжатия (по умолчанию)
Используется `priority_order` из `BudgetConfig` как шкала ценности: сначала жертвуем наименее значимым. По умолчанию порядок такой:  
`imports` (самый высокий приоритет) → `types` → `public_methods` → `fields` → `private_methods` → `docs` (самый низкий).

Значит, «режем» в обратном направлении (от менее ценного к более ценному), по слоям, останавливаясь, как только файл уложился в бюджет:

1) **Docs (низкий приоритет)**
   - У комментариев и докстрингов: переключаемся автоматически на «keep_first_sentence» с порогом длины; обычные комментарии удаляем с плейсхолдерами.
2) **Private methods / non‑exported**
   - У приватных/внутренних функций и методов: удаляем тела, оставляя сигнатуры и плейсхолдеры.
   - Для TS — у top‑level неэкспортируемых элементов аналогично.
3) **Fields**
   - Усиливаем трим инициализаторов полей и больших литералов (понижаем пороги: короче строки, меньше элементов массивов/свойств объектов; агрессивнее collapsing).
4) **Public methods/functions**
   - Если всё ещё выше бюджета — начинаем удалять тела у самых «тяжёлых» публичных функций/методов (сначала большие), сохраняя сигнатуры и плейсхолдеры.
5) **Types**
   - Типы стараемся сохранять; если бюджет всё ещё не соблюдён — применяем только безопасное «сворачивание» объёмных частей (например, большие литералы внутри типов, длинные JSDoc).
6) **Imports (высокий приоритет) — последний рубеж**
   - Импорты сохраняем максимально. В крайнем случае: сворачиваем длинные списки в краткие плейсхолдеры (с количеством), внешние импорты стараемся оставить.

Если после всех слоёв файл всё равно превышает лимит, применяется финальный «жёсткий» шаг: обрезка хвоста с общим плейсхолдером вида «… file truncated to fit budget».

### Что именно меняется по умолчанию без ручных опций
- Комментарии: базовая политика была `keep_all`, но при включённом бюджете движок сам «понижает» её по шагу 1, чтобы уложиться.
- Импорты: базовая `keep_all`, но сворачиваются только как крайняя мера.
- Тела функций/методов: по умолчанию мы их не трогаем, но бюджет разрешает выборочно вырезать тела (сигнатуры остаются), начиная с приватных и только при необходимости.
- Литералы: и без бюджета уже режутся; при бюджете пороги автоматически ужимаются сильнее на соответствующем шаге.
- Плейсхолдеры: стиль остаётся `auto`, языкоспецифичный (Python `# …`, TS `// …`/`/* … */`).

### Детали измерения и остановки
- Считаем токены на «текущем» варианте файла после каждого шага; как только токены ≤ `max_tokens_per_file`, прекращаем дальнейшее сжатие.
- Метрики в `meta` дополняются: `budget.max_tokens`, `budget.tokens_before`, `budget.tokens_after`, `budget.steps_applied`, `budget.last_step`.

### Поведение для вашего примера
```yaml
src-all:
  extensions: [".py"]
  python:
    budget:
      max_tokens_per_file: 2000
```
- Для каждого `.py`:
  - Выполняются стандартные обработки (в т. ч. трим литералов).
  - Если > 2000 токенов — последовательно: урезаем доки → приватные тела → усиливаем трим полей/литералов → (при необходимости) публичные тела → (в крайнем случае) компактируем импорты → при полном исчерпании опций — «truncate tail».
  - Останавливаемся сразу, как только файл вписался в 2000 токенов.

### Языковые нюансы по умолчанию
- Python:
  - «Приватность» — по префиксам `_` (одинарный — внутренний, двойной без dunder — приватный); `__dunder__` считаем публичным.
  - Докстринги режем до первого предложения с лимитом длины.
- TypeScript (если бюджет задан и для TS):
  - «Внутренность» — отсутствие `export` у top‑level; приватность — `private/protected`.
  - У длинных импортов — сначала суммаризация, удаление локальных импортов — только в крайнем случае.

Итого: бюджет — это «надстройка», которая аккуратно и автоматически ужимает контент по заранее заданной шкале ценности элементов, не требуя от пользователя вручную включать отдельные оптимизации.