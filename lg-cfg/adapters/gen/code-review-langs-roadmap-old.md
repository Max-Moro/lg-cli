# Дорожная карта рефакторинга языковых адаптеров

Документ описывает поэтапные, логически завершённые рефакторинги, выявленные в результате код-ревью. Каждый этап завершается стабильным состоянием: полный прогон тестов, отладка, фиксация результатов и выпуск минорной версии.

- Принципы: KISS, GRASP, DRY, YAGNI, SOLID
- Цели: устойчивость к изменениям Tree‑sitter, корректность смещений (байты ↔ строки), снижение связности, консистентные запросы, улучшение диагностики и метрик, предсказуемость плейсхолдеров, воспроизводимость бюджета токенов.

---

## (+++) Этап 1. Новая инфраструктура Tree‑sitter: `TreeSitterDocumentV2`

Самый «горячий» блок — доступ к Tree‑sitter. Создаём новый модуль и постепенно переводим код на него.

### Задачи

- [ ] Создать `lg/adapters/tree_sitter_support_v2.py` с новым классом `TreeSitterDocumentV2`:
  - [ ] Исправить использование Query API: вместо `QueryCursor(query)` → `query.captures(node)`
  - [ ] Кеширование `Query` сохранено; `captures` возвращают список `(node, capture_name)` без промежуточных структур
  - [ ] Централизовать «байто‑безопасные» утилиты:
    - [ ] `slice_by_bytes(start_byte, end_byte) -> str`
    - [ ] `line_start_byte(byte_offset) -> int`
    - [ ] `column_from_line_start(byte_offset) -> int`
    - [ ] `text_after_byte(byte_offset, max_len=None) -> str`
  - [ ] Добавить безопасные геттеры диапазонов/строк, инварианты и проверки ошибок парсинга

- [ ] Гармонизировать именование capture’ов и объединить дубли запросов (DRY):
  - [ ] Python: оставить один универсальный запрос `functions` (покрывает функции и методы); удалить/слить `methods`, скорректировать имена `@function_definition`, `@function_body`, `@function_name`, `@method_*`
  - [ ] TypeScript: согласовать симметрию имен: `function_*` и `method_*`; проверить соответствие ожиданиям `CodeAnalyzer.collect_function_like_elements`
  - [ ] Обновить: `lg/adapters/python/queries.py`, `lg/adapters/typescript/queries.py`

- [ ] Перевести потребителей на V2:
  - [ ] `CodeAdapter.create_document` → возвращает `TreeSitterDocumentV2`
  - [ ] Все оптимизаторы и анализаторы (comments/imports/literals/function_bodies/public_api) используют только методы V2; прямой доступ к `raw_text` по байтовым индексам запретить
  - [ ] Исправить места с потенциальным смешением байт/строк (например, `LiteralOptimizer`, `PlaceholderManager`)

- [ ] Прогон и стабилизация:
  - [ ] Запустить все тесты (прогон всех старых тестов сделает человек), дописать edge‑кейсы: Unicode (кириллица/эмодзи), длинные литералы, сложные декораторы/аннотации
  - [ ] Снимки (snapshot) для плейсхолдеров на нескольких реальных файлах

- [ ] Очистка от легаси:
  - [ ] Миграция вызовов на V2, удаление `TreeSitterDocument`, переименование `TreeSitterDocumentV2` → `TreeSitterDocument`. Этот этап сделаем сам разработчик (человек) через IDE.

### Критерии готовности

- В Python/TS нет дублирующих запросов, имена capture’ов консистентны
- В кодовой базе нет обращений к `raw_text` по байтовым позициям
- Падения по Tree‑sitter API отсутствуют; ошибки парсинга корректно диагностируются
- Все тесты зелёные. Unicode‑пути и многобайтные символы не ломают диапазоны и плейсхолдеры

---

## Этап (+++) 2. DRY для тримминга: единый утиль «truncate_with_ellipsis» и подсчёт оверхеда

### Задачи

- [ ] Вынести общие функции: `truncate_with_ellipsis(tokenizer, text, budget, suffix)` и расчёт резервов под закрывающие маркеры (комментарии/строки/литералы)
- [ ] Использовать в `CommentOptimizer.smart_truncate_comment` и `LiteralOptimizer`
- [ ] Тесты на граничные значения бюджета (0/1/мало/большие)

### Критерии готовности

- Согласованное поведение тримминга во всех адаптерах, меньше дублирования, проще сопровождение

---

## (++) Этап 3. Summarize импортов: семантика вместо удаления

### Задачи

- [ ] `ImportOptimizer._process_summarize_long`: менять не на удаление, а на краткую свёртку:
  - [ ] Для `{ a, b, c, ..., z }` — оставить компактный список + комментарий `/* … N omitted */`
  - [ ] Для многострочных импортов — корректное форматирование и закрывающие скобки
- [ ] Тесты: длинные списки импортов в Python/TS, в том числе смешанные `default + named`

### Критерии готовности

- «Summarize» повышает читаемость и не маскирует присутствие зависимости; метрики корректны

---

## (+) Этап 4. RangeEditor: диагностика конфликтов правок и метрики

### Задачи

- [ ] В `RangeEditor.add_edit` при пересечении правок добавлять метрику `conflicting_edits_skipped`
- [ ] Включить метрику в итоговый `meta` вместе с `edits_applied/bytes_removed/bytes_added`
- [ ] Юнит‑тест: две пересекающиеся правки → одна применяется, вторая уходит в счётчик конфликтов

### Критерии готовности

- Метрики отражают реальные конфликты; нет «молчаливого» съедания правок без следа

---

## Этап (+) 5. Плейсхолдеры и «экономичность»: предсказуемые пороги и отчётность

### Задачи

- [ ] В `CodeAdapter._finalize_placeholders`:
  - [ ] Улучшить отчётность: доля экономии по типам, число «пустых замен» (style=="none")
  - [ ] Добавить трейсинг порога экономичности (какой порог/почему замена отброшена)
- [ ] В `BudgetController`: стабилизировать порядок эскалаций и отчётность по шагам (уже частично есть)

### Критерии готовности

- Метрики достаточны, чтобы объяснить решения по бюджету и плейсхолдерам; результаты воспроизводимы

---

## Этап (+) 6. Анализаторы кода: унификация public API и классов/полей

### Задачи

- [ ] Пересмотреть `CodeAnalyzer.collect_private_elements_for_public_api` на Python/TS:
  - [ ] Привести к общей стратегии: top‑level (экспортность), методы (видимость), классы/интерфейсы/типы/поля
  - [ ] В TS расширить покрытие: поля классов с `;`, геттеры/сеттеры (есть), конструкторы (есть) — оформить тестами
- [ ] Добавить тесты на приватность/экспортность и удаление с сохранением декораторов/аннотаций

### Критерии готовности

- Единое поведение public API режима, покрыто тестами на реальных конструкциях

---

## Этап (+) 7. Unicode‑прочность, снапшоты и property‑based тесты

### Задачи

- [ ] Добавить наборы Unicode‑фрагментов (эмодзи, комбинируемые символы) для функций/строк/литералов/комментов
- [ ] Включить snapshot‑тесты для плейсхолдеров на коллекции файлов
- [ ] Добавить property‑based проверки на «после правок парсер не падает» и «инварианты диапазонов»

### Критерии готовности

- Байтовые/строковые операции устойчивы к Unicode; регрессии ловятся тестами

