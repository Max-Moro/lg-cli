# Задача по разделению шаблонизатора на модули

## Введение

В инструменте LG конечные контексты представляются в виде Markdown формата и могут собираться из множества источников по определенным правилам. По этой причине внутри LG используется довольно развитый движок шаблонизации на основе AST-based подхода — `lg/template/`.

Данный движок состоит из довольно традиционных модулей для AST-based систем:
- `nodes.py`
- `lexer.py`
- `parser.py`
- `evaluator.py`
- `resolver.py`
- `processor.py`

Так и исключительно из модулей со специфичной бизнес логикой:
- `virtual_sections.py`
- `heading_context.py`
- `context.py`
- `common.py`

На начальных этапах разработки такое разделение было логичным, но теперь, при росте функциональных возможностей его уже не достаточно.

Если рассматривать не внутреннюю математику, а именно бизнес функции движка шаблонизации, то можно выделить три крупных функциональных блока.

### Блок №1. Обработка плейсхолдеров секций и родных для LG шаблонов

- вставка секций — `${my-section}`
- вставка шаблонов — `${tpl:common/intro}`
- вставка контекста — `${ctx:api/review}`
- адресные ссылки и работа со скоупами

### Блок №2. Работа с условными конструкциями и операторами для адаптивных возможностей

- Условные конструкции
- Операторы условий
- Режимные блоки
- Комментарии

### Блок №3. Вставка не родных для LG Markdown-фрагментов через MD-плейсхолдер

Все возможности плейсхолдера `${md:…}`.

## Архитектура нового модульного шаблонизатора

Ниже представлен подробный план для создания новой версии в `lg/template_v2/`. Основная задача - разделить функциональность на логические блоки, обеспечивая гибкость и возможность независимой разработки компонентов.

### Общая структура директорий

```
lg/template_v2/
├── __init__.py
├── base.py              # Базовые интерфейсы и абстракции
├── registry.py          # Реестр компонентов
├── lexer.py             # Основа лексера
├── parser.py            # Основа парсера
├── processor.py         # Оркестрирующий компонент
├── errors.py            # Централизованная обработка ошибок
├── handlers.py          # Внутренние обработчики для модульного шаблонизатора
│
├── common_placeholders/ # Блок №1
│   ├── __init__.py
│   ├── nodes.py         # SectionNode, IncludeNode и т.д.
│   ├── tokens.py        # Определения токенов
│   ├── plugin.py        # Регистрация компонентов
│   ├── parser_rules.py  # Правила парсинга плейсхолдеров
│   ├── resolver.py      # Резолвер секций и шаблонов
│   └── processor.py     # Обработка узлов
│
├── adaptive/            # Блок №2
│   ├── __init__.py
│   ├── nodes.py         # ConditionalNode, ModeNode и т.д.
│   ├── tokens.py        # Определения токенов
│   ├── plugin.py        # Регистрация компонентов
│   ├── parser_rules.py  # Правила парсинга условий
│   ├── evaluator.py     # Вычислитель условий
│   └── processor.py     # Обработка узлов
│
└── md_placeholders/     # Блок №3
    ├── __init__.py
    ├── nodes.py         # MarkdownFileNode
    ├── tokens.py        # Определения токенов
    ├── plugin.py        # Регистрация компонентов
    ├── parser_rules.py  # Правила парсинга md-плейсхолдеров
    ├── heading_context.py # Анализ контекста заголовков
    ├── virtual_sections.py # Создание виртуальных секций
    └── processor.py     # Обработка узлов
```

## Специфика реализации каждого функционального блока

### Блок №1: Обработка плейсхолдеров секций и шаблонов

Этот блок отвечает за базовую функциональность вставки секций и шаблонов:
- Парсинг `${section_name}` и `${tpl:template_name}`
- Обработка адресных ссылок (`@origin:name`)
- Резолвинг и загрузка включаемых шаблонов

### Блок №2: Адаптивные возможности

Этот блок отвечает за условные конструкции и режимы:
- Парсинг `{% if condition %}...{% endif %}` и `{% mode ... %}`
- Вычисление условных выражений
- Управление активными режимами и тегами

### Блок №3: Вставка Markdown-фрагментов

Этот блок специализируется на обработке `${md:...}`:
- Анализ контекста заголовков
- Создание виртуальных секций
- Обработка параметров и якорей

## Преимущества новой архитектуры

1. **Модульность и расширяемость:**
   - Четкое разделение функциональных блоков
   - Легкое добавление новых возможностей через плагины
   - Независимая разработка и тестирование компонентов

2. **Улучшенная поддерживаемость:**
   - Изолированные изменения в каждом блоке
   - Уменьшение сложности отдельных модулей
   - Более четкие зависимости и API

3. **Гибкость конфигурации:**
   - Возможность включения/отключения определенных функций
   - Единообразный подход к регистрации компонентов
   - Упрощенное внедрение новых типов узлов и правил