# Listing Generator · Адаптивные возможности

## Обзор функциональности

Адаптивные возможности позволяют формировать разные срезы контекста на основе **наборов режимов** и **наборов тегов**. Эта система обеспечивает гибкую настройку генерируемых контекстов без дублирования конфигурации.

Когда вы обсуждаете код с AI, обычно требуется:
- один и тот же контекст, но разные срезы (планирование, разработка, отладка, ревью);
- быстрое переключение между AI-провайдерами и активация разных режимов работы AI-провайдеров;
- переиспользование правил составленных фильтров и языковых оптимизаций с разными вариациями.

Режимы и теги решают эти задачи. Вы используете один шаблон контекста и получаете именно тот срез, который нужен сейчас.

## Ключевые концепции

### Наборы режимов и режимы

**Набор режимов** - группа взаимоисключающих опций, представляющих определенный аспект работы (например, “AI Interaction” или “Development Stage”).

**Режим** — конкретная опция внутри набора. Он может:
- активировать теги (`tags`),
- задавать системные опции (`vcs_mode`),
- при необходимости содержать `runs` (параметры запуска провайдера).

**Правило:** после резолва всех режимов контекста **должен быть ровно один интеграционный набор**. Если интеграционных 0 или больше 1 — это ошибка.

### Наборы тегов и теги

**Набор тегов** — группа связанных тегов (например, “Языки программирования”).

**Тег** — атомарный элемент фильтрации, используемый в условиях (`tag:...`, `TAGSET:...`).

**Глобальные теги не декларируются.** Любой активный тег, не входящий ни в один набор тегов, считается глобальным и может использоваться в `tag:`.

## Структура конфигурации

Адаптивная конфигурация живёт в **секциях** (`sections.yaml` и `*.sec.yaml`).

### Пример секции с режимами и тегами

```yaml
# lg-cfg/sections.yaml
core:
  extensions: [".py", ".md"]
  filters:
    mode: allow
    allow: ["/src/"]

  mode-sets:
    ai-interaction:
      title: "AI Interaction"
      modes:
        ask:
          title: "Ask"
          description: "Question-answer mode"
          runs:
            com.anthropic.claude.cli: "--permission-mode default"
            com.github.copilot.ext: "workbench.action.chat.openask"

        agent:
          title: "Agent"
          description: "Agent mode with tools"
          tags: [agent]
          runs:
            com.anthropic.claude.cli: "--permission-mode acceptEdits"
            com.github.copilot.ext: "workbench.action.chat.openagent"

        plan:
          title: "Plan"
          description: "Planning / specification mode"
          tags: [agent, plan]
          runs:
            com.anthropic.claude.cli: "--permission-mode plan"
            com.github.copilot.ext: "workbench.action.chat.openplan"

    dev-stage:
      title: "Стадия работы над задачей"
      modes:
        common:
          title: "Основная разработка"

        testing:
          title: "Написание тестов"
          tags: [tests]
          default_task: "Напиши тесты для текущего функционального блока."

        review:
          title: "Кодревью"
          tags: [review]
          default_task: "Проведи code review изменений и дай рекомендации по улучшению."
          vcs_mode: "branch-changes"

  tag-sets:
    language:
      title: "Языки программирования"
      tags:
        python:
          title: "Python"
        typescript:
          title: "TypeScript"
        javascript:
          title: "JavaScript"
    
    code-type:
      title: "Тип кода"
      tags:
        product:
          title: "Продуктовый код"
        tests:
          title: "Тестовый код"
        generated:
          title: "Сгенерированный код"
      
    some-feature-slices:
      title: "Большой функциональный блок"
      tags:
        subfeature_foo:
          title: "Фича №1"
        subfeature_bar:
          title: "Фича №2"
        subfeature_baz:
          title: "Фича №3"
```

### Мета‑секции

**Мета‑секция** — секция **без `filters`**. Она не рендерится, но может:
- использоваться как база через `extends`,
- подключаться через frontmatter контекста.

Чаще всего мета-секции используются в качестве базы для режимов и тегов.

---

## Frontmatter в `.ctx.md`

Контексты могут подключать дополнительные мета‑секции через frontmatter. Это влияет на режимы/теги, но **не рендерит** контент.

```markdown
---
include:
  - "ai-interaction"
  - "tags"
---

# My Context

${core}
```

---

## Наследование секций

Секции могут наследовать адаптивную конфигурацию:

```yaml
src:
  extends: ["ai-interaction", "dev-stage", "tags"]
  extensions: [".py"]
  filters:
    mode: allow
    allow:
      - "/src/"
```

**Где:**
- `ai-interaction` - интеграционная мета-секция режимов в файле `lg-cfg/ai-interaction.sec.yaml`. В данном случае это стандартная интеграционная секция (генерируемая IDE-аддонами), но можно разработать свою собственную.
- `dev-stage` - контентная мета-секция режимов в файле `lg-cfg/dev-stage.sec.yaml`.
- `tags` - мета-секция с наборами тегов в `lg-cfg/tags.sec.yaml`

**Мержатся:**
- `mode-sets`, `tag-sets`, конфиги адаптеров, `extensions`, `skip_empty`, `path_labels`.

**Не мержатся:**
- `filters`, `targets`.

**Коллизии:** child wins (`mode.id`, `tag.id`, `title`, `description`).

**Важно:** при расчёте доступных режимов и тегов для контекста **условия `{% if %}` не выполняются** — все секции внутри условных блоков учитываются. Это гарантирует, что пользователь видит полный набор доступных режимов/тегов независимо от текущего выбора.

**Адресация мета-секций:**

Декларация `extends` и frontmatter `include` используют те же правила адресации, что и плейсхолдер вставки секций:
- путь относительно текущего lg-cfg;
- `@origin` для другого скоупа;
- `@/` для корневого скоупа.

Пример:
```markdown
---
include:
  - "modes/ai-interaction"
  - "@libs/core:modes/ai-interaction"
  - "@/modes/ai-interaction"
---
```

---

## Идентификаторы провайдеров (`runs`)

`runs` — это map providerId → строка, описывающий режимы запуска AI‑провайдеров в логике **LG VS Code Extension** и **LG IntelliJ Plugin**. Эта декларация необходима для правильной реакции на нажатие кнопки "Send to AI" в пользовательском интерфейсе. Сам LG CLI значения `runs` не интерпретирует, а только передаёт IDE-аддонам.

Канонический формат providerId:

```
<reverse-dns>.<product>.<type>
```

Примеры:
- `com.github.copilot.ext`
- `com.anthropic.claude.cli`
- `com.openai.codex.cli`
- `com.jetbrains.ai.ext`
- `org.jetbrains.junie.ext`

Наборы режимов делятся на два типа:
- **Интеграционные** — содержат `runs` и описывают режимы запуска AI‑провайдера.
- **Контентные** — не содержат `runs` и используются только для адаптивного контента.

Важно: после резолва всех наборов режимов для активного контекста **должен существовать ровно один интеграционный набор режимов**. Все остальные наборы — контентные. Если интеграционных наборов 0 или больше 1 — это **ошибка**.

Это правило предотвращает ситуацию, когда выбраны несколько режимов с противоречивыми `runs` и непонятно, какие параметры запуска применять при "Send to AI".

### Универсальный провайдер `clipboard`

Провайдер `clipboard` является особым — он **неявно совместим со всеми режимами**. Через буфер обмена контекст можно передать в любой AI-инструмент вручную.

Особенности:
- При `--provider clipboard` **все режимы** считаются доступными (фильтрация по `runs` не применяется)
- `list contexts --provider clipboard` возвращает **все контексты** без исключений
- Условие `provider:clipboard` в шаблонах работает как обычно

Это удобно для случаев, когда вы хотите скопировать контекст и вставить его в web-интерфейс AI или в инструмент, для которого нет прямой интеграции.

### Каноничная базовая мета‑секция

В принципе самостоятельно настраивать `runs` допустимо, но обычно это не требуется. И это может быть не безопасно. По этой причине существует стандартная мета-секция с интеграционными режимами `lg-cfg/ai-interaction.sec.yaml`, которую генерируют/обновляют IDE‑плагины (VS Code / IntelliJ). В тулбаре IDE есть кнопка, которая создает или обновляет данный файл. Там всегда содержатся актуальные `runs` для поддерживаемых провайдеров. Поэтому при своей работе рекомендуется наследовать именно мета-секцию `ai-interaction`.

Продвинутые пользователи могут добавлять свои особенные режимы и особенные `runs`-значения. IDE обновляет только известные ему режимы и `runs`-значения, неизвестная часть конфига сохраняется в нетронутом виде. При нажатии на кнопку "Send to AI" IDE будет пытаться разумным способом использовать даже неизвестные ему `runs`-значения и именно с такими параметрами запустить целевой AI-провайдер.

---

## CLI

```bash
# Список контекстов
# При передаче провайдера возвращается список совместимых с провайдером контекстов
listing-generator list contexts [--provider <provider-id>]

# Список наборов режимов со вложенными режимами + правила запуска провайдера
# Данных достаточно для формирования UI (комбобоксы)
# Интеграционный набор фильтруется по провайдеру, а контентные наборы возвращаются полностью
listing-generator list mode-sets --context my-context --provider com.anthropic.claude.cli

# Список наборов тегов со вложенными тегами
# Данных достаточно для формирования UI (наборы чекбоксов)
listing-generator list tag-sets  --context my-context

# Рендеринг с указанием режимов, в данной ситуации режим планирования
# При отправке полученного контекта в целевой провайдер, IDE-аддон обязан запустить его с `runs`-аргументами для режима планирования
listing-generator render ctx:my-context --mode ai-interaction:plan --mode dev-stage:common

# Рендеринг с указанием дополнительных тегов
# В UI теги выбираются через наборы чекбоксов в рамках TAGSET и затем формируют плоский список
listing-generator render ctx:my-context --tags python,minimal

# Комбинированное использование
listing-generator render ctx:my-context --mode ai-interaction:agent --mode dev-stage:review --tags python

# Рендеринг с указанием целевой ветки для режима branch-changes
listing-generator render ctx:my-context --mode dev-stage:review --target-branch main

# Рендеринг с указанием AI-провайдера (включает условия provider:)
listing-generator render ctx:my-context --mode ai-interaction:agent --provider com.anthropic.claude.cli
```

## Системные опции режимов

Некоторые возможности LG привязаны к дополнительным опциям режимов (а не к аргументам командной строки или конфигурации секций). Они настраиваются в определении режима внутри секции и активируются при выборе соответствующего режима.

| Опция                          | Синтаксис в YAML        | Варианты                              | По умолчанию | Описание                                                                                                                                                                                                                |
|--------------------------------|-------------------------|---------------------------------------|--------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| **Режимы VCS**                 | `vcs_mode: <вариант>`   | `all \| changes \| branch-changes`    | `all`        | Дополнительная фильтрация файлов в секциях с учетом статуса системы контроля версий:<br/>- **all** — включать все файлы<br/>- **changes** — включать только изменённые в рабочем дереве (staged + unstaged + untracked)<br/>- **branch-changes** — включать файлы, изменённые в текущей ветке относительно целевой ветки (**обязательно** указать `--target-branch`) |
| **Задача по умолчанию**        | `default_task: "текст"` | Произвольный текст                    | —            | Текст задачи, который используется для плейсхолдера `${task}`, если `--task` не передан явно (см. ниже) |

### Взаимодействие `default_task` и `${task}`

Плейсхолдер `${task}` в шаблонах получает текст задачи с учётом приоритетов:

1. **Явный `--task`** — если передан непустой аргумент командной строки, используется он.
2. **`default_task` из режимов** — если `--task` не указан, собираются `default_task` из всех активных режимов и объединяются через двойной перенос строки.
3. **Пустая строка** — если ни то, ни другое не задано.

Пример: при `--mode dev-stage:review` активируется режим с `default_task: "Проведи code review..."`, и плейсхолдер `${task}` автоматически подставит этот текст.

Подробнее о плейсхолдере `${task}` см. в документации [Шаблоны и контексты](templates.md#плейсхолдер-текущей-задачи-task).

## Условная логика

### Условия в Markdown шаблонах

```markdown
## Документация

{% if tag:docs %}
Подробная документация API...
{% endif %}

{% if TAGSET:language:python %}
### Python-специфичная реализация
${python-impl}
{% endif %}

{% if tag:agent AND NOT tag:minimal %}
### Инструменты агента
${agent-tools}
{% endif %}
```

### Условия в конфигурации секций

```yaml
# lg-cfg/sections.yaml
feature-impl:
  extensions: [".py", ".ts", ".js"]
  filters:
    mode: allow
    allow:
      - "/src/feature/**"
    
    when:
      - condition: "TAGSET:language:python"
        allow:
          - "/src/feature/python/**"
        block:
          - "/src/feature/!(python)/**"
      
      - condition: "tag:tests"
        allow:
          - "**/*_test.py"
          - "**/*.spec.ts"

  python:
    when:
      - condition: "tag:minimal"
        strip_function_bodies: true
      - condition: "tag:docs_only"
        comment_policy: "keep_doc"
```

Также условия можно применять внутри `targets` для организации поэтапной оптимизации более или менее важного для контекста кода.

```yaml
…
  # Graduated optimization following budget escalation order.
  # All optimizations disabled in review mode (tag:review) for full code visibility.

  # Level 1 (global base): lightest optimization for all Python files
  python:
    when:
      - condition: "NOT tag:review"
        imports:
          policy: "strip_external"
        literals:
          max_tokens: 100

  targets:
    # Level 2: context/type definition files — readable logic, stripped noise
    - match: # …
      python:
        when:
          - condition: "NOT tag:review"
            comment_policy: "keep_doc"
            imports:
              policy: "strip_all"

    # Level 3: infrastructure — public API visible, private bodies stripped
    - match: # …
      python:
        when:
          - condition: "NOT tag:review"
            comment_policy: "keep_doc"
            imports:
              policy: "strip_all"
            strip_function_bodies:
              policy: "keep_public"

    # Level 4: peripheral — only signatures needed
    - match: # …
      python:
        when:
          - condition: "NOT tag:review"
            comment_policy: "keep_doc"
            imports:
              policy: "strip_all"
            strip_function_bodies: true
```

### Поддерживаемые операторы условий

- `tag:<name>` - активен указанный тег
- `NOT tag:<name>` - указанный тег не активен
- `tag:<name1> AND tag:<name2>` - оба тега активны
- `tag:<name1> OR tag:<name2>` - активен хотя бы один из тегов
- `TAGSET:<set-name>:<tag-name>` - специальный оператор для срезов (разрешительный по умолчанию):
  - Истинно, если ни один тег из набора не активен
  - Истинно, если указанный тег активен
  - Ложно во всех остальных случаях
- `TAGONLY:<set-name>:<tag-name>` - эксклюзивный оператор для срезов (запретительный по умолчанию):
  - Истинно только если указанный тег активен И он единственный активный из набора
  - Ложно во всех остальных случаях

Для работы с федеративными скоупами добавляются дополнительные операторы, которые могут комбинироваться с другими операторами условий.

- `scope:local` - применяется только если рендерится из локального скоупа
- `scope:parent` - применяется при рендере из родительского скоупа

Для идентификации активного AI-провайдера доступен специализированный оператор:

- `provider:<base-id>` - проверяет текущий AI-провайдер (указанный через `--provider`):
  - Полный ID провайдера нормализуется путём отсечения технического суффикса (`.cli`, `.ext`, `.api`)
  - Например, `--provider com.anthropic.claude.cli` нормализуется до `com.anthropic.claude`
  - Специальные провайдеры без суффикса (например, `clipboard`) сравниваются как есть
  - Если `--provider` не указан, условие всегда ложно (False)

## Задание режимов в шаблонах

Иногда удобно сами режимы принудительно задавать в шаблонах.

```markdown
{% mode dev-stage:common %}
<!-- Это очень важный архитектурный код, поэтому его лучше всегда вставлять полностью, без сужающих тегов -->
<!-- Также мы гарантируем, что даже на кодревью этот код будет вставлен полностью -->
${src-arch}
{% endmode %}

<!-- А рендеринг этой секции уже полностью зависит от выбранного в UI пользователем режима и/или срезов -->
<!-- Пользователь может для этой секции включить опцию `vcs_mode` через режимы -->
${src-feature}
```

## Полный справочник возможностей шаблонизатора

### Плейсхолдеры (основные элементы вставки)

| Тип | Синтаксис | Примеры | Описание |
|-----|-----------|---------|----------|
| **Секция** (текущий скоуп) | `${name}` | `${my-section}` | Вставка секции из текущего lg-cfg |
| **Секция** (другой скоуп) | `${@origin:name}` | `${@apps/web:web-src}` | Секция из другого lg-cfg в репозитории |
| **Секция** (сложный путь) | `${@[origin]:name}` | `${@[apps/web:v1]:src}` | Для путей с двоеточиями внутри `origin` |
| **Шаблон** (текущий скоуп) | `${tpl:name}` | `${tpl:common/intro}` | Шаблон из текущего lg-cfg |
| **Шаблон** (другой скоуп) | `${tpl@origin:name}` | `${tpl@libs/math:utils}` | Шаблон из другого модуля |
| **Шаблон** (сложный путь) | `${tpl@[origin]:name}` | `${tpl@[libs/math:v2]:intro}` | Для путей с двоеточиями |
| **Контекст** (текущий скоуп) | `${ctx:name}` | `${ctx:api/review}` | Контекст из текущего lg-cfg |
| **Контекст** (другой скоуп) | `${ctx@origin:name}` | `${ctx@services/auth:guide}` | Контекст из другого модуля |
| **Контекст** (сложный путь) | `${ctx@[origin]:name}` | `${ctx@[services/auth:v1]:intro}` | Для путей с двоеточиями |

### Условные конструкции

| Конструкция | Синтаксис | Примеры | Описание |
|-------------|-----------|---------|----------|
| **If-блок** | `{% if условие %}...{% endif %}` | `{% if tag:debug %}...{% endif %}` | Базовая условная конструкция |
| **If-else** | `{% if условие %}...{% else %}...{% endif %}` | `{% if tag:python %}...{% else %}...{% endif %}` | Условие с альтернативой |
| **If-elif-else** | `{% if условие1 %}...{% elif условие2 %}...{% else %}...{% endif %}` | `{% if tag:python %}...{% elif tag:javascript %}...{% else %}...{% endif %}` | Цепочка условий |

### Операторы условий

| Оператор | Синтаксис | Примеры | Описание |
|----------|-----------|---------|----------|
| **Тег** | `tag:имя_тега` | `tag:python`, `tag:docs` | Проверяет активность тега |
| **Набор тегов** | `TAGSET:набор:тег` | `TAGSET:language:python` | Особая проверка для срезов набора тегов |
| **Отрицание** | `NOT условие` | `NOT tag:minimal` | Инвертирует условие |
| **И** | `условие1 AND условие2` | `tag:python AND tag:tests` | Истинно, если оба условия истинны |
| **ИЛИ** | `условие1 OR условие2` | `tag:python OR tag:javascript` | Истинно, если хотя бы одно условие истинно |
| **Скобки** | `(условие)` | `(tag:python OR tag:js) AND tag:tests` | Группировка для задания приоритета |
| **Скоуп** | `scope:тип` | `scope:local`, `scope:parent` | Проверка типа скоупа (локальный/родительский) |
| **Провайдер** | `provider:base-id` | `provider:com.anthropic.claude`, `provider:clipboard` | Проверка активного AI-провайдера (нормализованный, без суффикса `.cli`/`.ext`/`.api`) |

### Режимные блоки

| Конструкция | Синтаксис | Примеры | Описание |
|-------------|-----------|---------|----------|
| **Режимный блок** | `{% mode набор:режим %}...{% endmode %}` | `{% mode dev-stage:review %}...{% endmode %}` | Переключает режим для вложенного содержимого |

### Комментарии

| Конструкция | Синтаксис | Примеры | Описание |
|-------------|-----------|---------|----------|
| **Шаблонный комментарий** | `{# текст #}` | `{# Это не будет в результате #}` | Удаляется при обработке |
| **HTML-комментарий** | `<!-- текст -->` | `<!-- Примечание -->` | Проходит в итоговый результат |

---
<!-- Далее отключаем интерпретацию, чтобы иметь возможность отправить данную документацию через сам LG в неизменном виде -->
<!-- lg:raw:start -->
## Использование адаптивных возможностей в Markdown-адаптере

Markdown-адаптер также имеет поддержку условных конструкции на базе HTML-комментариев. Это позволяет использовать адаптивные возможности в обычных Markdown-документах без нарушения их читабельности в сторонних просмотрщиках.

### Синтаксис условных конструкций

Синтаксис основан на специальных HTML-комментариях с префиксами, указывающими на их роль:

#### Условные блоки

```markdown
<!-- lg:if tag:python -->
Этот текст будет видим только при активном теге python.
<!-- lg:endif -->

<!-- lg:if tag:debug -->
Отладочная информация
<!-- lg:else -->
Обычное содержимое
<!-- lg:endif -->

<!-- lg:if TAGSET:language:typescript -->
TypeScript-специфичный контент
<!-- lg:elif TAGSET:language:python -->
Python-специфичный контент
<!-- lg:else -->
Контент для других языков
<!-- lg:endif -->
```

#### Комментарии-инструкции

```markdown
<!-- lg:comment:start -->
Этот текст БУДЕТ ВИДИМ в Markdown-просмотрщиках,
но исключится при обработке LG-инструментом.
<!-- lg:comment:end -->
```

### Пример использования

#### Конфигурация в YAML

```yaml
docs:
  extensions: [".md"]
  markdown:
    max_heading_level: 2
    enable_templating: true  # Включение новой функциональности
    drop:
      sections:
        - match: { kind: text, pattern: "Installation" }
      frontmatter: true
```

#### Пример Markdown-документа с условиями

~~~markdown
# Документация API

## Введение

Это общая документация API.

<!-- lg:if tag:python -->
## Python-клиент

```python
import api_client

client = api_client.Client("apikey")
response = client.get_data()
```
<!-- lg:endif -->

<!-- lg:if tag:javascript -->
## JavaScript-клиент

```javascript
const client = new ApiClient("apikey");
const response = await client.getData();
```
<!-- lg:endif -->

<!-- lg:if tag:debug -->
## Отладка

Информация для отладки...
<!-- lg:else -->
## Использование

Стандартная инструкция по использованию...
<!-- lg:endif -->


<!-- lg:comment:start -->
TODO: Добавить документацию по новым методам API
Эта заметка не попадет в итоговый результат
<!-- lg:comment:end -->
~~~
<!-- lg:raw:end -->

---

## Типичные ошибки и диагностика

При работе с адаптивной системой LG выдаёт понятные сообщения об ошибках. Вот наиболее частые ситуации:

| Ошибка | Причина | Решение |
|--------|---------|---------|
| **Circular extends dependency** | Цикл в цепочке `extends` (A → B → A) | Проверить и устранить циклические ссылки в `extends` |
| **Cannot render meta-section** | Попытка рендерить секцию без `filters` | Мета-секции используются только для наследования; добавьте `filters` или используйте через `extends` |
| **Multiple integration mode-sets found** | В контексте обнаружено более одного интеграционного набора режимов | Оставьте только один набор с `runs`; остальные сделайте контентными (без `runs`) |
| **No integration mode-set found** | Ни одна секция контекста не содержит `runs` | Добавьте интеграционный набор через `extends` или frontmatter `include` |
| **Provider not supported** | Провайдер не поддерживается ни одним режимом интеграционного набора | Добавьте `runs` для нужного провайдера или выберите другой провайдер |
| **Mode not found** | `{% mode set:mode %}` ссылается на несуществующий режим | Проверить правильность имени набора и режима; режим должен быть определён в модели контекста |
| **Section not found in extends** | Секция из `extends` не существует | Проверить путь и имя секции; использовать `@scope:` для секций из других lg-cfg |

---

## Как выстраивать реальный рабочий процесс

### Шаг 1. Сгенерировать интеграционный шаблон режимов

В тулбаре IDE-аддона (**LG VS Code Extension** или **LG Intellij Plugin**) есть кнопка, которая создает или обновляет файл:

```
lg-cfg/ai-interaction.sec.yaml
```

Это каноническая база интеграционных режимов. IDE:
- опрашивает все свои провайдеры;
- добавляет и обновляет только те `runs`, которые понимает;
- не трогает неизвестные записи.

Запускайте эту кнопку повторно при установке новых AI-провайдеров или обновлении IDE-плагинов.

### Шаг 2. Свои контентные режимы и теги

Вы можете разработать свои собственные наборы контентных режимов и систему тегов, которая позволит вам переключать стиль работы с определёнными контекстами.

Обычно режимы используются, чтобы менять стадию работы над задачей. А теги используются, чтобы делать более узконаправленный срез кодовой базы, при работе с крупным функциональным блоком.

Задекларируйте ваши персональные наборы режимов и наборы тегов в секциях или мета-секциях (`sections.yaml` или `*.sec.yaml`).

### Шаг 3. Подключение мета-секций к контекстам

Необходимо выбрать удобный для вашей ситуации способ подключения созданных наборов режимов и наборов тегов к контекстам (`*.ctx.md`). Это можно делать следующими способами:

- Прямое указание в нужных секциях, которые вставляются в ваши контексты (`${sec_name}`), разделов `mode-sets` и `tag-sets`.
- Через наследование в секциях.  При этом используется декларация `extends` в YAML.
- Через Frontmatter и декларацию `include` в самих контекстах.

На практике разумно использовать комбинацию способов. Обычно интеграционные режимы всегда глобальны и их удобнее подключать через Frontmatter. А вот контентные режимы и наборы тегов для слайсов чаще могут быть связаны с конкретной секцией.

### Шаг 4. Разработка правил в шаблонах и манифестах

Используя операторы условной логики в шаблонах, а также декларации `when` в YAML секций, разбейте и адаптируйте весь полный контент внутри контекстов под отдельные срезы и/или фазы работы. Подумайте над тем, как теперь вместо использования разных контекстов или секций, использовать их меньшее количество. Чтобы лучше составлять более комплексные контексты, рекомендуется логически пройтись по всем функциям вашего приложения и объединить их в более крупные функциональные блоки. Подумайте также над тем, как одни и те же контексты использовать в разных AI-провайдерах с разными режимами запуска.

### Шаг 5. Работа в IDE-аддоне

1. Выберите AI-провайдера
2. Настройте дополнительные параметры запуска AI-провайдера, если они есть в UI
3. Выберите контекст
4. Выберите необходимый режим/режимы и настройте теги
5. Если это новый контекст, оптимизируйте его под необходимый процент заполнения контекстного окна, используя диалог статистики ("Show Context Stats")
6. Нажмите "Send to AI"

Провайдер запустится на основе `runs` из интеграционного набора. В данный момент IDE просто пытается применить `runs`-значения в нужном интеграционном режиме у целевого провайдера. Это касается даже пользовательских `runs`-значений, которые IDE заранее не были известны.