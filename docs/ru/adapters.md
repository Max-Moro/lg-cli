# Listing Generator · Языковые адаптеры

Этот документ описывает систему **языковых адаптеров** в Listing Generator (LG). Адаптеры позволяют интеллектуально оптимизировать листинги исходного кода, удаляя "шумные" части и сохраняя структурно важную информацию.

---

### Зачем это нужно

LLM-модели заметно лучше работают с кодом, когда:
- видят только **структурно важные части** (сигнатуры, типы, интерфейсы),
- не получают объемные **тела функций** (особенно для вспомогательных методов),
- не перегружены **обширными комментариями** или **массивными литералами**,
- не тратят токены на **ненужные импорты** или **приватные детали**.

Языковые адаптеры решают эти проблемы, трансформируя код в более **плотное представление**:

1. **Уменьшают размер контекста**, оставляя только самое важное
2. **Повышают плотность информации** на токен
3. **Снижают затраты** на большие контексты
4. **Улучшают фокусировку** модели на важных частях API

---

### Базовая конфигурация языковых адаптеров

Языковые адаптеры настраиваются через секции в YAML-конфигурации:

```yaml
api-module:
  extensions: [".py", ".ts", ".js"]
  
  lang: # Целевой язык
      # Базовая конфигурация для всей секции
      public_api_only: false  # Показывать только публичный API
      strip_function_bodies: true  # Удалять тела функций
      comment_policy: "keep_doc"  # Политика работы с комментариями
    
      # Подробные настройки конкретных аспектов
      imports:
        policy: "strip_external"
        summarize_long: true
      
      literals:
        max_tokens: 100
        
      placeholders:
        style: "inline"  # Стиль плейсхолдеров: inline, block, none
        min_savings_ratio: 2.0  # Минимальный коэффициент экономии
    
      # Бюджетирование токенов
      budget:
        max_tokens_per_file: 500
```

---

### Удаление тел функций

Настройка `strip_function_bodies` позволяет сократить объемные алгоритмические части, сохраняя важные сигнатуры:

```yaml
# Простой вариант (bool)
strip_function_bodies: true

# Расширенная конфигурация
strip_function_bodies:
  mode: "public_only"  # Возможные режимы: none, all, public_only, non_public, large_only
  min_lines: 5  # Минимальный размер для удаления при режиме large_only
  except_patterns: ["^init", "^main"]  # Не трогать функции, соответствующие regex
  keep_annotated: ["@important", "@critical"]  # Сохранять функции с аннотациями
```

Режимы:
- `none` — ничего не удалять
- `all` — удалять все тела функций
- `public_only` — удалять только у публичных функций/методов
- `non_public` — удалять только у приватных/защищенных
- `large_only` — удалять функции размером > `min_lines`

---

### Обработка комментариев

Настройка `comment_policy` определяет, как обрабатывать комментарии и документацию:

```yaml
# Простой вариант (строка)
comment_policy: "keep_doc"  # keep_all, strip_all, keep_doc, keep_first_sentence

# Расширенная конфигурация
comment_policy:
  policy: "keep_doc"  
  max_tokens: 50  # Ограничение размера комментария в токенах
  keep_annotations: ["TODO", "FIXME", "@param"]  # Сохранять с этими маркерами
  strip_patterns: ["Copyright", "License"]  # Удалять по regex
```

Политики:
- `keep_all` — сохранять все комментарии
- `strip_all` — удалять все комментарии
- `keep_doc` — сохранять только документационные комментарии
- `keep_first_sentence` — сохранять только первое предложение из документации

---

### Публичный API

Опция `public_api_only` очищает код от приватных/внутренних деталей:

```yaml
# Включение режима публичного API
public_api_only: true
```

В этом режиме:
- Удаляются приватные/защищенные функции/методы
- Удаляются внутренние классы и интерфейсы
- Сохраняются только публичные члены и экспортируемые элементы
- Сохраняется публичный API, необходимый для понимания структуры

---

### Обработка импортов

Настройка `imports` позволяет оптимизировать секции импорта:

```yaml
imports:
  policy: "strip_external"  # keep_all, strip_all, strip_external, strip_local
  summarize_long: true  # Свернуть длинные списки импортов
  max_items_before_summary: 5  # Порог для сворачивания
  external_patterns: ["^@angular/", "^lodash"]  # Паттерны внешних библиотек
```

Политики импортов:
- `keep_all` — сохранять все импорты
- `strip_all` — удалять все импорты
- `strip_external` — удалять только внешние библиотеки
- `strip_local` — удалять только локальные импорты

---

### Сокращение литералов

Настройка `literals` ограничивает размер литеральных данных:

```yaml
literals:
  max_tokens: 100  # Максимальное количество токенов для литералов
```

Обрабатываются:
- Длинные строки
- Большие массивы/списки
- Объемные объекты/словари
- JSON-структуры

Вместо полного содержимого вставляется сокращенная версия с плейсхолдером.

---

### Бюджетирование токенов

Система бюджетирования (`budget`) автоматически подбирает оптимальную степень сжатия для каждого файла:

```yaml
budget:
  max_tokens_per_file: 500  # Лимит на файл в токенах
  priority_order:  # Порядок применения оптимизаций
    - "imports_external"
    - "literals"
    - "comments"
    - "imports_local"
    - "private_bodies"
    - "public_api_only"
    - "public_bodies"
    - "docstrings_first_sentence"
```

Принцип работы:
1. LG анализирует каждый файл на число токенов
2. Если файл превышает лимит, последовательно применяет оптимизации
3. Приоритет определяет порядок применения трансформаций
4. Остановка после достижения бюджета или исчерпания доступных оптимизаций

---

### Адресная конфигурация через targets

Для разных частей кодовой базы можно задавать разные стратегии оптимизации:

```yaml
api-module:
  extensions: [".py", ".ts"]
  # Базовые настройки для всей секции
  strip_function_bodies: false
  
  # Адресные оверрайды
  targets:
    # API модули - только публичные интерфейсы
    - match: ["**/api/**", "**/interfaces/**"]
      public_api_only: true
      strip_function_bodies: true
    
    # Тесты - минимальный объем
    - match: ["**/test/**"]
      strip_function_bodies: true
      comment_policy: "strip_all"
    
    # Утилиты - бюджетирование
    - match: ["**/utils/**"]
      budget:
        max_tokens_per_file: 300
```

Правило `match` принимает как строку, так и массив glob-паттернов. При совпадении нескольких правил выигрывает более специфичное.

---

### Система плейсхолдеров

Настройка `placeholders` определяет, как обозначать удаленные участки кода:

```yaml
placeholders:
  style: "inline"  # inline, block, none
  min_savings_ratio: 2.0  # Минимальный коэффициент экономии токенов
  min_abs_savings_if_none: 5  # Минимальная абсолютная экономия для style=none
```

Стили:
- `inline` — однострочные комментарии
- `block` — блочные комментарии
- `none` — без плейсхолдеров (полное удаление)

Плейсхолдеры содержат информацию о типе удаленного элемента, его имени и размере.

---

### Метрики в отчетах

Языковые адаптеры предоставляют детальную статистику в отчетах LG:

```json
{
  "code.removed.functions": 15,
  "code.removed.methods": 8,
  "code.removed.comments": 42,
  "code.removed.imports": 3,
  "code.removed.literals": 2,
  "code.bytes_saved": 8960,
  "code.placeholders": 18,
  "code.lines_saved": 245
}
```

Эти метрики помогают понять, что именно "съедает" токены и насколько эффективны применяемые оптимизации.

---

### Язык-специфичные возможности

**Автоматический пропуск тривиальных файлов** включён по умолчанию для всех языков. Тривиальные файлы (например, `__init__.py` только с реэкспортами, barrel-файлы `index.ts`, `doc.go` только с документацией пакета) автоматически исключаются из листингов. Это можно отключить для секции через `skip_trivial_files: false`.

**Python** предоставляет специальные обработчики для декораторов (`@property`, `@classmethod`) и Python-специфичных стилей комментариев (docstrings).

**TypeScript** предлагает оптимизированную работу с JSX и декораторами, а также специальную логику для экспортируемого API.

---

### Рекомендации по практике

- Начните с базовой конфигурации `strip_function_bodies: true` и `comment_policy: "keep_doc"`
- Для API-ориентированного кода используйте `public_api_only: true`
- Для кода с множеством зависимостей включите `imports.policy: "strip_external"`
- Используйте `targets` для более точной настройки в зависимости от типа кода
- Для автоматической оптимизации используйте `budget` с разумным лимитом токенов
- Проверяйте эффект командой `lg report …` и следите за полями экономии токенов